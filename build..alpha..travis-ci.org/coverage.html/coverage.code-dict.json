{"/home/travis/build/npmtest/node-npmtest-nunjucks/test.js":"/* istanbul instrument in package npmtest_nunjucks */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nunjucks/lib.npmtest_nunjucks.js":"/* istanbul instrument in package npmtest_nunjucks */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nunjucks = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nunjucks = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nunjucks/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nunjucks && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nunjucks */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nunjucks\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nunjucks.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_nunjucks.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nunjucks.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_nunjucks.__dirname +\n                    '/lib.npmtest_nunjucks.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/index.js":"'use strict';\n\nvar lib = require('./src/lib');\nvar env = require('./src/environment');\nvar Loader = require('./src/loader');\nvar loaders = require('./src/loaders');\nvar precompile = require('./src/precompile');\n\nmodule.exports = {};\nmodule.exports.Environment = env.Environment;\nmodule.exports.Template = env.Template;\n\nmodule.exports.Loader = Loader;\nmodule.exports.FileSystemLoader = loaders.FileSystemLoader;\nmodule.exports.PrecompiledLoader = loaders.PrecompiledLoader;\nmodule.exports.WebLoader = loaders.WebLoader;\n\nmodule.exports.compiler = require('./src/compiler');\nmodule.exports.parser = require('./src/parser');\nmodule.exports.lexer = require('./src/lexer');\nmodule.exports.runtime = require('./src/runtime');\nmodule.exports.lib = lib;\nmodule.exports.nodes = require('./src/nodes');\n\nmodule.exports.installJinjaCompat = require('./src/jinja-compat.js');\n\n// A single instance of an environment, since this is so commonly used\n\nvar e;\nmodule.exports.configure = function(templatesPath, opts) {\n    opts = opts || {};\n    if(lib.isObject(templatesPath)) {\n        opts = templatesPath;\n        templatesPath = null;\n    }\n\n    var TemplateLoader;\n    if(loaders.FileSystemLoader) {\n        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {\n            watch: opts.watch,\n            noCache: opts.noCache\n        });\n    }\n    else if(loaders.WebLoader) {\n        TemplateLoader = new loaders.WebLoader(templatesPath, {\n            useCache: opts.web && opts.web.useCache,\n            async: opts.web && opts.web.async\n        });\n    }\n\n    e = new env.Environment(TemplateLoader, opts);\n\n    if(opts && opts.express) {\n        e.express(opts.express);\n    }\n\n    return e;\n};\n\nmodule.exports.compile = function(src, env, path, eagerCompile) {\n    if(!e) {\n        module.exports.configure();\n    }\n    return new module.exports.Template(src, env, path, eagerCompile);\n};\n\nmodule.exports.render = function(name, ctx, cb) {\n    if(!e) {\n        module.exports.configure();\n    }\n\n    return e.render(name, ctx, cb);\n};\n\nmodule.exports.renderString = function(src, ctx, cb) {\n    if(!e) {\n        module.exports.configure();\n    }\n\n    return e.renderString(src, ctx, cb);\n};\n\nif(precompile) {\n    module.exports.precompile = precompile.precompile;\n    module.exports.precompileString = precompile.precompileString;\n}\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/lib.js":"'use strict';\n\nvar ArrayProto = Array.prototype;\nvar ObjProto = Object.prototype;\n\nvar escapeMap = {\n    '&': '&amp;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\n\nvar escapeRegex = /[&\"'<>]/g;\n\nvar lookupEscape = function(ch) {\n    return escapeMap[ch];\n};\n\nvar exports = module.exports = {};\n\nexports.prettifyError = function(path, withInternals, err) {\n    // jshint -W022\n    // http://jslinterrors.com/do-not-assign-to-the-exception-parameter\n    if (!err.Update) {\n        // not one of ours, cast it\n        err = new exports.TemplateError(err);\n    }\n    err.Update(path);\n\n    // Unless they marked the dev flag, show them a trace from here\n    if (!withInternals) {\n        var old = err;\n        err = new Error(old.message);\n        err.name = old.name;\n    }\n\n    return err;\n};\n\nexports.TemplateError = function(message, lineno, colno) {\n    var err = this;\n\n    if (message instanceof Error) { // for casting regular js errors\n        err = message;\n        message = message.name + ': ' + message.message;\n\n        try {\n            if(err.name = '') {}\n        }\n        catch(e) {\n            // If we can't set the name of the error object in this\n            // environment, don't use it\n            err = this;\n        }\n    } else {\n        if(Error.captureStackTrace) {\n            Error.captureStackTrace(err);\n        }\n    }\n\n    err.name = 'Template render error';\n    err.message = message;\n    err.lineno = lineno;\n    err.colno = colno;\n    err.firstUpdate = true;\n\n    err.Update = function(path) {\n        var message = '(' + (path || 'unknown path') + ')';\n\n        // only show lineno + colno next to path of template\n        // where error occurred\n        if (this.firstUpdate) {\n            if(this.lineno && this.colno) {\n                message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';\n            }\n            else if(this.lineno) {\n                message += ' [Line ' + this.lineno + ']';\n            }\n        }\n\n        message += '\\n ';\n        if (this.firstUpdate) {\n            message += ' ';\n        }\n\n        this.message = message + (this.message || '');\n        this.firstUpdate = false;\n        return this;\n    };\n\n    return err;\n};\n\nexports.TemplateError.prototype = Error.prototype;\n\nexports.escape = function(val) {\n  return val.replace(escapeRegex, lookupEscape);\n};\n\nexports.isFunction = function(obj) {\n    return ObjProto.toString.call(obj) === '[object Function]';\n};\n\nexports.isArray = Array.isArray || function(obj) {\n    return ObjProto.toString.call(obj) === '[object Array]';\n};\n\nexports.isString = function(obj) {\n    return ObjProto.toString.call(obj) === '[object String]';\n};\n\nexports.isObject = function(obj) {\n    return ObjProto.toString.call(obj) === '[object Object]';\n};\n\nexports.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };\n    for(var i=0; i<obj.length; i++) {\n        var value = obj[i];\n        var key = iterator(value, i);\n        (result[key] || (result[key] = [])).push(value);\n    }\n    return result;\n};\n\nexports.toArray = function(obj) {\n    return Array.prototype.slice.call(obj);\n};\n\nexports.without = function(array) {\n    var result = [];\n    if (!array) {\n        return result;\n    }\n    var index = -1,\n    length = array.length,\n    contains = exports.toArray(arguments).slice(1);\n\n    while(++index < length) {\n        if(exports.indexOf(contains, array[index]) === -1) {\n            result.push(array[index]);\n        }\n    }\n    return result;\n};\n\nexports.extend = function(obj, obj2) {\n    for(var k in obj2) {\n        obj[k] = obj2[k];\n    }\n    return obj;\n};\n\nexports.repeat = function(char_, n) {\n    var str = '';\n    for(var i=0; i<n; i++) {\n        str += char_;\n    }\n    return str;\n};\n\nexports.each = function(obj, func, context) {\n    if(obj == null) {\n        return;\n    }\n\n    if(ArrayProto.each && obj.each === ArrayProto.each) {\n        obj.forEach(func, context);\n    }\n    else if(obj.length === +obj.length) {\n        for(var i=0, l=obj.length; i<l; i++) {\n            func.call(context, obj[i], i, obj);\n        }\n    }\n};\n\nexports.map = function(obj, func) {\n    var results = [];\n    if(obj == null) {\n        return results;\n    }\n\n    if(ArrayProto.map && obj.map === ArrayProto.map) {\n        return obj.map(func);\n    }\n\n    for(var i=0; i<obj.length; i++) {\n        results[results.length] = func(obj[i], i);\n    }\n\n    if(obj.length === +obj.length) {\n        results.length = obj.length;\n    }\n\n    return results;\n};\n\nexports.asyncIter = function(arr, iter, cb) {\n    var i = -1;\n\n    function next() {\n        i++;\n\n        if(i < arr.length) {\n            iter(arr[i], i, next, cb);\n        }\n        else {\n            cb();\n        }\n    }\n\n    next();\n};\n\nexports.asyncFor = function(obj, iter, cb) {\n    var keys = exports.keys(obj);\n    var len = keys.length;\n    var i = -1;\n\n    function next() {\n        i++;\n        var k = keys[i];\n\n        if(i < len) {\n            iter(k, obj[k], i, len, next);\n        }\n        else {\n            cb();\n        }\n    }\n\n    next();\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill\nexports.indexOf = Array.prototype.indexOf ?\n    function (arr, searchElement, fromIndex) {\n        return Array.prototype.indexOf.call(arr, searchElement, fromIndex);\n    } :\n    function (arr, searchElement, fromIndex) {\n        var length = this.length >>> 0; // Hack to convert object.length to a UInt32\n\n        fromIndex = +fromIndex || 0;\n\n        if(Math.abs(fromIndex) === Infinity) {\n            fromIndex = 0;\n        }\n\n        if(fromIndex < 0) {\n            fromIndex += length;\n            if (fromIndex < 0) {\n                fromIndex = 0;\n            }\n        }\n\n        for(;fromIndex < length; fromIndex++) {\n            if (arr[fromIndex] === searchElement) {\n                return fromIndex;\n            }\n        }\n\n        return -1;\n    };\n\nif(!Array.prototype.map) {\n    Array.prototype.map = function() {\n        throw new Error('map is unimplemented for this js engine');\n    };\n}\n\nexports.keys = function(obj) {\n    if(Object.prototype.keys) {\n        return obj.keys();\n    }\n    else {\n        var keys = [];\n        for(var k in obj) {\n            if(obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    }\n};\n\nexports.inOperator = function (key, val) {\n    if (exports.isArray(val)) {\n        return exports.indexOf(val, key) !== -1;\n    } else if (exports.isObject(val)) {\n        return key in val;\n    } else if (exports.isString(val)) {\n        return val.indexOf(key) !== -1;\n    } else {\n        throw new Error('Cannot use \"in\" operator to search for \"'\n            + key + '\" in unexpected types.');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/environment.js":"'use strict';\n\nvar path = require('path');\nvar asap = require('asap');\nvar lib = require('./lib');\nvar Obj = require('./object');\nvar compiler = require('./compiler');\nvar builtin_filters = require('./filters');\nvar builtin_loaders = require('./loaders');\nvar runtime = require('./runtime');\nvar globals = require('./globals');\nvar waterfall = require('a-sync-waterfall');\nvar Frame = runtime.Frame;\nvar Template;\n\n// Unconditionally load in this loader, even if no other ones are\n// included (possible in the slim browser build)\nbuiltin_loaders.PrecompiledLoader = require('./precompiled-loader');\n\n// If the user is using the async API, *always* call it\n// asynchronously even if the template was synchronous.\nfunction callbackAsap(cb, err, res) {\n    asap(function() { cb(err, res); });\n}\n\nvar Environment = Obj.extend({\n    init: function(loaders, opts) {\n        // The dev flag determines the trace that'll be shown on errors.\n        // If set to true, returns the full trace from the error point,\n        // otherwise will return trace starting from Template.render\n        // (the full trace from within nunjucks may confuse developers using\n        //  the library)\n        // defaults to false\n        opts = this.opts = opts || {};\n        this.opts.dev = !!opts.dev;\n\n        // The autoescape flag sets global autoescaping. If true,\n        // every string variable will be escaped by default.\n        // If false, strings can be manually escaped using the `escape` filter.\n        // defaults to true\n        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;\n\n        // If true, this will make the system throw errors if trying\n        // to output a null or undefined value\n        this.opts.throwOnUndefined = !!opts.throwOnUndefined;\n        this.opts.trimBlocks = !!opts.trimBlocks;\n        this.opts.lstripBlocks = !!opts.lstripBlocks;\n\n        this.loaders = [];\n\n        if(!loaders) {\n            // The filesystem loader is only available server-side\n            if(builtin_loaders.FileSystemLoader) {\n                this.loaders = [new builtin_loaders.FileSystemLoader('views')];\n            }\n            else if(builtin_loaders.WebLoader) {\n                this.loaders = [new builtin_loaders.WebLoader('/views')];\n            }\n        }\n        else {\n            this.loaders = lib.isArray(loaders) ? loaders : [loaders];\n        }\n\n        // It's easy to use precompiled templates: just include them\n        // before you configure nunjucks and this will automatically\n        // pick it up and use it\n        if(process.env.IS_BROWSER && window.nunjucksPrecompiled) {\n            this.loaders.unshift(\n                new builtin_loaders.PrecompiledLoader(window.nunjucksPrecompiled)\n            );\n        }\n\n        this.initCache();\n\n        this.globals = globals();\n        this.filters = {};\n        this.asyncFilters = [];\n        this.extensions = {};\n        this.extensionsList = [];\n\n        for(var name in builtin_filters) {\n            this.addFilter(name, builtin_filters[name]);\n        }\n    },\n\n    initCache: function() {\n        // Caching and cache busting\n        lib.each(this.loaders, function(loader) {\n            loader.cache = {};\n\n            if(typeof loader.on === 'function') {\n                loader.on('update', function(template) {\n                    loader.cache[template] = null;\n                });\n            }\n        });\n    },\n\n    addExtension: function(name, extension) {\n        extension._name = name;\n        this.extensions[name] = extension;\n        this.extensionsList.push(extension);\n        return this;\n    },\n\n    removeExtension: function(name) {\n        var extension = this.getExtension(name);\n        if (!extension) return;\n\n        this.extensionsList = lib.without(this.extensionsList, extension);\n        delete this.extensions[name];\n    },\n\n    getExtension: function(name) {\n        return this.extensions[name];\n    },\n\n    hasExtension: function(name) {\n        return !!this.extensions[name];\n    },\n\n    addGlobal: function(name, value) {\n        this.globals[name] = value;\n        return this;\n    },\n\n    getGlobal: function(name) {\n        if(typeof this.globals[name] === 'undefined') {\n            throw new Error('global not found: ' + name);\n        }\n        return this.globals[name];\n    },\n\n    addFilter: function(name, func, async) {\n        var wrapped = func;\n\n        if(async) {\n            this.asyncFilters.push(name);\n        }\n        this.filters[name] = wrapped;\n        return this;\n    },\n\n    getFilter: function(name) {\n        if(!this.filters[name]) {\n            throw new Error('filter not found: ' + name);\n        }\n        return this.filters[name];\n    },\n\n    resolveTemplate: function(loader, parentName, filename) {\n        var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;\n        return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;\n    },\n\n    getTemplate: function(name, eagerCompile, parentName, ignoreMissing, cb) {\n        var that = this;\n        var tmpl = null;\n        if(name && name.raw) {\n            // this fixes autoescape for templates referenced in symbols\n            name = name.raw;\n        }\n\n        if(lib.isFunction(parentName)) {\n            cb = parentName;\n            parentName = null;\n            eagerCompile = eagerCompile || false;\n        }\n\n        if(lib.isFunction(eagerCompile)) {\n            cb = eagerCompile;\n            eagerCompile = false;\n        }\n\n        if (name instanceof Template) {\n             tmpl = name;\n        }\n        else if(typeof name !== 'string') {\n            throw new Error('template names must be a string: ' + name);\n        }\n        else {\n            for (var i = 0; i < this.loaders.length; i++) {\n                var _name = this.resolveTemplate(this.loaders[i], parentName, name);\n                tmpl = this.loaders[i].cache[_name];\n                if (tmpl) break;\n            }\n        }\n\n        if(tmpl) {\n            if(eagerCompile) {\n                tmpl.compile();\n            }\n\n            if(cb) {\n                cb(null, tmpl);\n            }\n            else {\n                return tmpl;\n            }\n        } else {\n            var syncResult;\n            var _this = this;\n\n            var createTemplate = function(err, info) {\n                if(!info && !err) {\n                    if(!ignoreMissing) {\n                        err = new Error('template not found: ' + name);\n                    }\n                }\n\n                if (err) {\n                    if(cb) {\n                        cb(err);\n                    }\n                    else {\n                        throw err;\n                    }\n                }\n                else {\n                    var tmpl;\n                    if(info) {\n                        tmpl = new Template(info.src, _this,\n                                            info.path, eagerCompile);\n\n                        if(!info.noCache) {\n                            info.loader.cache[name] = tmpl;\n                        }\n                    }\n                    else {\n                        tmpl = new Template('', _this,\n                                            '', eagerCompile);\n                    }\n\n                    if(cb) {\n                        cb(null, tmpl);\n                    }\n                    else {\n                        syncResult = tmpl;\n                    }\n                }\n            };\n\n            lib.asyncIter(this.loaders, function(loader, i, next, done) {\n                function handle(err, src) {\n                    if(err) {\n                        done(err);\n                    }\n                    else if(src) {\n                        src.loader = loader;\n                        done(null, src);\n                    }\n                    else {\n                        next();\n                    }\n                }\n\n                // Resolve name relative to parentName\n                name = that.resolveTemplate(loader, parentName, name);\n\n                if(loader.async) {\n                    loader.getSource(name, handle);\n                }\n                else {\n                    handle(null, loader.getSource(name));\n                }\n            }, createTemplate);\n\n            return syncResult;\n        }\n    },\n\n    express: function(app) {\n        var env = this;\n\n        function NunjucksView(name, opts) {\n            this.name          = name;\n            this.path          = name;\n            this.defaultEngine = opts.defaultEngine;\n            this.ext           = path.extname(name);\n            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');\n            if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);\n        }\n\n        NunjucksView.prototype.render = function(opts, cb) {\n          env.render(this.name, opts, cb);\n        };\n\n        app.set('view', NunjucksView);\n        app.set('nunjucksEnv', this);\n        return this;\n    },\n\n    render: function(name, ctx, cb) {\n        if(lib.isFunction(ctx)) {\n            cb = ctx;\n            ctx = null;\n        }\n\n        // We support a synchronous API to make it easier to migrate\n        // existing code to async. This works because if you don't do\n        // anything async work, the whole thing is actually run\n        // synchronously.\n        var syncResult = null;\n\n        this.getTemplate(name, function(err, tmpl) {\n            if(err && cb) {\n                callbackAsap(cb, err);\n            }\n            else if(err) {\n                throw err;\n            }\n            else {\n                syncResult = tmpl.render(ctx, cb);\n            }\n        });\n\n        return syncResult;\n    },\n\n    renderString: function(src, ctx, opts, cb) {\n        if(lib.isFunction(opts)) {\n            cb = opts;\n            opts = {};\n        }\n        opts = opts || {};\n\n        var tmpl = new Template(src, this, opts.path);\n        return tmpl.render(ctx, cb);\n    },\n\n    waterfall: waterfall\n});\n\nvar Context = Obj.extend({\n    init: function(ctx, blocks, env) {\n        // Has to be tied to an environment so we can tap into its globals.\n        this.env = env || new Environment();\n\n        // Make a duplicate of ctx\n        this.ctx = {};\n        for(var k in ctx) {\n            if(ctx.hasOwnProperty(k)) {\n                this.ctx[k] = ctx[k];\n            }\n        }\n\n        this.blocks = {};\n        this.exported = [];\n\n        for(var name in blocks) {\n            this.addBlock(name, blocks[name]);\n        }\n    },\n\n    lookup: function(name) {\n        // This is one of the most called functions, so optimize for\n        // the typical case where the name isn't in the globals\n        if(name in this.env.globals && !(name in this.ctx)) {\n            return this.env.globals[name];\n        }\n        else {\n            return this.ctx[name];\n        }\n    },\n\n    setVariable: function(name, val) {\n        this.ctx[name] = val;\n    },\n\n    getVariables: function() {\n        return this.ctx;\n    },\n\n    addBlock: function(name, block) {\n        this.blocks[name] = this.blocks[name] || [];\n        this.blocks[name].push(block);\n        return this;\n    },\n\n    getBlock: function(name) {\n        if(!this.blocks[name]) {\n            throw new Error('unknown block \"' + name + '\"');\n        }\n\n        return this.blocks[name][0];\n    },\n\n    getSuper: function(env, name, block, frame, runtime, cb) {\n        var idx = lib.indexOf(this.blocks[name] || [], block);\n        var blk = this.blocks[name][idx + 1];\n        var context = this;\n\n        if(idx === -1 || !blk) {\n            throw new Error('no super block available for \"' + name + '\"');\n        }\n\n        blk(env, context, frame, runtime, cb);\n    },\n\n    addExport: function(name) {\n        this.exported.push(name);\n    },\n\n    getExported: function() {\n        var exported = {};\n        for(var i=0; i<this.exported.length; i++) {\n            var name = this.exported[i];\n            exported[name] = this.ctx[name];\n        }\n        return exported;\n    }\n});\n\nTemplate = Obj.extend({\n    init: function (src, env, path, eagerCompile) {\n        this.env = env || new Environment();\n\n        if(lib.isObject(src)) {\n            switch(src.type) {\n            case 'code': this.tmplProps = src.obj; break;\n            case 'string': this.tmplStr = src.obj; break;\n            }\n        }\n        else if(lib.isString(src)) {\n            this.tmplStr = src;\n        }\n        else {\n            throw new Error('src must be a string or an object describing ' +\n                            'the source');\n        }\n\n        this.path = path;\n\n        if(eagerCompile) {\n            var _this = this;\n            try {\n                _this._compile();\n            }\n            catch(err) {\n                throw lib.prettifyError(this.path, this.env.opts.dev, err);\n            }\n        }\n        else {\n            this.compiled = false;\n        }\n    },\n\n    render: function(ctx, parentFrame, cb) {\n        if (typeof ctx === 'function') {\n            cb = ctx;\n            ctx = {};\n        }\n        else if (typeof parentFrame === 'function') {\n            cb = parentFrame;\n            parentFrame = null;\n        }\n\n        var forceAsync = true;\n        if(parentFrame) {\n            // If there is a frame, we are being called from internal\n            // code of another template, and the internal system\n            // depends on the sync/async nature of the parent template\n            // to be inherited, so force an async callback\n            forceAsync = false;\n        }\n\n        var _this = this;\n        // Catch compile errors for async rendering\n        try {\n            _this.compile();\n        } catch (_err) {\n            var err = lib.prettifyError(this.path, this.env.opts.dev, _err);\n            if (cb) return callbackAsap(cb, err);\n            else throw err;\n        }\n\n        var context = new Context(ctx || {}, _this.blocks, _this.env);\n        var frame = parentFrame ? parentFrame.push(true) : new Frame();\n        frame.topLevel = true;\n        var syncResult = null;\n\n        _this.rootRenderFunc(\n            _this.env,\n            context,\n            frame || new Frame(),\n            runtime,\n            function(err, res) {\n                if(err) {\n                    err = lib.prettifyError(_this.path, _this.env.opts.dev, err);\n                }\n\n                if(cb) {\n                    if(forceAsync) {\n                        callbackAsap(cb, err, res);\n                    }\n                    else {\n                        cb(err, res);\n                    }\n                }\n                else {\n                    if(err) { throw err; }\n                    syncResult = res;\n                }\n            }\n        );\n\n        return syncResult;\n    },\n\n\n    getExported: function(ctx, parentFrame, cb) {\n        if (typeof ctx === 'function') {\n            cb = ctx;\n            ctx = {};\n        }\n\n        if (typeof parentFrame === 'function') {\n            cb = parentFrame;\n            parentFrame = null;\n        }\n\n        // Catch compile errors for async rendering\n        try {\n            this.compile();\n        } catch (e) {\n            if (cb) return cb(e);\n            else throw e;\n        }\n\n        var frame = parentFrame ? parentFrame.push() : new Frame();\n        frame.topLevel = true;\n\n        // Run the rootRenderFunc to populate the context with exported vars\n        var context = new Context(ctx || {}, this.blocks, this.env);\n        this.rootRenderFunc(this.env,\n                            context,\n                            frame,\n                            runtime,\n                            function(err) {\n        \t\t        if ( err ) {\n        \t\t\t    cb(err, null);\n        \t\t        } else {\n        \t\t\t    cb(null, context.getExported());\n        \t\t        }\n                            });\n    },\n\n    compile: function() {\n        if(!this.compiled) {\n            this._compile();\n        }\n    },\n\n    _compile: function() {\n        var props;\n\n        if(this.tmplProps) {\n            props = this.tmplProps;\n        }\n        else {\n            var source = compiler.compile(this.tmplStr,\n                                          this.env.asyncFilters,\n                                          this.env.extensionsList,\n                                          this.path,\n                                          this.env.opts);\n\n            /* jslint evil: true */\n            var func = new Function(source);\n            props = func();\n        }\n\n        this.blocks = this._getBlocks(props);\n        this.rootRenderFunc = props.root;\n        this.compiled = true;\n    },\n\n    _getBlocks: function(props) {\n        var blocks = {};\n\n        for(var k in props) {\n            if(k.slice(0, 2) === 'b_') {\n                blocks[k.slice(2)] = props[k];\n            }\n        }\n\n        return blocks;\n    }\n});\n\nmodule.exports = {\n    Environment: Environment,\n    Template: Template\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/object.js":"'use strict';\n\n// A simple class system, more documentation to come\n\nfunction extend(cls, name, props) {\n    // This does that same thing as Object.create, but with support for IE8\n    var F = function() {};\n    F.prototype = cls.prototype;\n    var prototype = new F();\n\n    // jshint undef: false\n    var fnTest = /xyz/.test(function(){ xyz; }) ? /\\bparent\\b/ : /.*/;\n    props = props || {};\n\n    for(var k in props) {\n        var src = props[k];\n        var parent = prototype[k];\n\n        if(typeof parent === 'function' &&\n           typeof src === 'function' &&\n           fnTest.test(src)) {\n            /*jshint -W083 */\n            prototype[k] = (function (src, parent) {\n                return function() {\n                    // Save the current parent method\n                    var tmp = this.parent;\n\n                    // Set parent to the previous method, call, and restore\n                    this.parent = parent;\n                    var res = src.apply(this, arguments);\n                    this.parent = tmp;\n\n                    return res;\n                };\n            })(src, parent);\n        }\n        else {\n            prototype[k] = src;\n        }\n    }\n\n    prototype.typename = name;\n\n    var new_cls = function() {\n        if(prototype.init) {\n            prototype.init.apply(this, arguments);\n        }\n    };\n\n    new_cls.prototype = prototype;\n    new_cls.prototype.constructor = new_cls;\n\n    new_cls.extend = function(name, props) {\n        if(typeof name === 'object') {\n            props = name;\n            name = 'anonymous';\n        }\n        return extend(new_cls, name, props);\n    };\n\n    return new_cls;\n}\n\nmodule.exports = extend(Object, 'Object', {});\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/compiler.js":"'use strict';\n\nvar lib = require('./lib');\nvar parser = require('./parser');\nvar transformer = require('./transformer');\nvar nodes = require('./nodes');\n// jshint -W079\nvar Object = require('./object');\nvar Frame = require('./runtime').Frame;\n\n// These are all the same for now, but shouldn't be passed straight\n// through\nvar compareOps = {\n    '==': '==',\n    '===': '===',\n    '!=': '!=',\n    '!==': '!==',\n    '<': '<',\n    '>': '>',\n    '<=': '<=',\n    '>=': '>='\n};\n\n// A common pattern is to emit binary operators\nfunction binOpEmitter(str) {\n    return function(node, frame) {\n        this.compile(node.left, frame);\n        this.emit(str);\n        this.compile(node.right, frame);\n    };\n}\n\nvar Compiler = Object.extend({\n    init: function(templateName, throwOnUndefined) {\n        this.templateName = templateName;\n        this.codebuf = [];\n        this.lastId = 0;\n        this.buffer = null;\n        this.bufferStack = [];\n        this.scopeClosers = '';\n        this.inBlock = false;\n        this.throwOnUndefined = throwOnUndefined;\n    },\n\n    fail: function (msg, lineno, colno) {\n        if (lineno !== undefined) lineno += 1;\n        if (colno !== undefined) colno += 1;\n\n        throw new lib.TemplateError(msg, lineno, colno);\n    },\n\n    pushBufferId: function(id) {\n        this.bufferStack.push(this.buffer);\n        this.buffer = id;\n        this.emit('var ' + this.buffer + ' = \"\";');\n    },\n\n    popBufferId: function() {\n        this.buffer = this.bufferStack.pop();\n    },\n\n    emit: function(code) {\n        this.codebuf.push(code);\n    },\n\n    emitLine: function(code) {\n        this.emit(code + '\\n');\n    },\n\n    emitLines: function() {\n        lib.each(lib.toArray(arguments), function(line) {\n            this.emitLine(line);\n        }, this);\n    },\n\n    emitFuncBegin: function(name) {\n        this.buffer = 'output';\n        this.scopeClosers = '';\n        this.emitLine('function ' + name + '(env, context, frame, runtime, cb) {');\n        this.emitLine('var lineno = null;');\n        this.emitLine('var colno = null;');\n        this.emitLine('var ' + this.buffer + ' = \"\";');\n        this.emitLine('try {');\n    },\n\n    emitFuncEnd: function(noReturn) {\n        if(!noReturn) {\n            this.emitLine('cb(null, ' + this.buffer +');');\n        }\n\n        this.closeScopeLevels();\n        this.emitLine('} catch (e) {');\n        this.emitLine('  cb(runtime.handleError(e, lineno, colno));');\n        this.emitLine('}');\n        this.emitLine('}');\n        this.buffer = null;\n    },\n\n    addScopeLevel: function() {\n        this.scopeClosers += '})';\n    },\n\n    closeScopeLevels: function() {\n        this.emitLine(this.scopeClosers + ';');\n        this.scopeClosers = '';\n    },\n\n    withScopedSyntax: function(func) {\n        var scopeClosers = this.scopeClosers;\n        this.scopeClosers = '';\n\n        func.call(this);\n\n        this.closeScopeLevels();\n        this.scopeClosers = scopeClosers;\n    },\n\n    makeCallback: function(res) {\n        var err = this.tmpid();\n\n        return 'function(' + err + (res ? ',' + res : '') + ') {\\n' +\n            'if(' + err + ') { cb(' + err + '); return; }';\n    },\n\n    tmpid: function() {\n        this.lastId++;\n        return 't_' + this.lastId;\n    },\n\n    _templateName: function() {\n        return this.templateName == null? 'undefined' : JSON.stringify(this.templateName);\n    },\n\n    _compileChildren: function(node, frame) {\n        var children = node.children;\n        for(var i=0, l=children.length; i<l; i++) {\n            this.compile(children[i], frame);\n        }\n    },\n\n    _compileAggregate: function(node, frame, startChar, endChar) {\n        if(startChar) {\n            this.emit(startChar);\n        }\n\n        for(var i=0; i<node.children.length; i++) {\n            if(i > 0) {\n                this.emit(',');\n            }\n\n            this.compile(node.children[i], frame);\n        }\n\n        if(endChar) {\n            this.emit(endChar);\n        }\n    },\n\n    _compileExpression: function(node, frame) {\n        // TODO: I'm not really sure if this type check is worth it or\n        // not.\n        this.assertType(\n            node,\n            nodes.Literal,\n            nodes.Symbol,\n            nodes.Group,\n            nodes.Array,\n            nodes.Dict,\n            nodes.FunCall,\n            nodes.Caller,\n            nodes.Filter,\n            nodes.LookupVal,\n            nodes.Compare,\n            nodes.InlineIf,\n            nodes.In,\n            nodes.And,\n            nodes.Or,\n            nodes.Not,\n            nodes.Add,\n            nodes.Concat,\n            nodes.Sub,\n            nodes.Mul,\n            nodes.Div,\n            nodes.FloorDiv,\n            nodes.Mod,\n            nodes.Pow,\n            nodes.Neg,\n            nodes.Pos,\n            nodes.Compare,\n            nodes.NodeList\n        );\n        this.compile(node, frame);\n    },\n\n    assertType: function(node /*, types */) {\n        var types = lib.toArray(arguments).slice(1);\n        var success = false;\n\n        for(var i=0; i<types.length; i++) {\n            if(node instanceof types[i]) {\n                success = true;\n            }\n        }\n\n        if(!success) {\n            this.fail('assertType: invalid type: ' + node.typename,\n                      node.lineno,\n                      node.colno);\n        }\n    },\n\n    compileCallExtension: function(node, frame, async) {\n        var args = node.args;\n        var contentArgs = node.contentArgs;\n        var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;\n\n        if(!async) {\n            this.emit(this.buffer + ' += runtime.suppressValue(');\n        }\n\n        this.emit('env.getExtension(\"' + node.extName + '\")[\"' + node.prop + '\"](');\n        this.emit('context');\n\n        if(args || contentArgs) {\n            this.emit(',');\n        }\n\n        if(args) {\n            if(!(args instanceof nodes.NodeList)) {\n                this.fail('compileCallExtension: arguments must be a NodeList, ' +\n                          'use `parser.parseSignature`');\n            }\n\n            lib.each(args.children, function(arg, i) {\n                // Tag arguments are passed normally to the call. Note\n                // that keyword arguments are turned into a single js\n                // object as the last argument, if they exist.\n                this._compileExpression(arg, frame);\n\n                if(i !== args.children.length - 1 || contentArgs.length) {\n                    this.emit(',');\n                }\n            }, this);\n        }\n\n        if(contentArgs.length) {\n            lib.each(contentArgs, function(arg, i) {\n                if(i > 0) {\n                    this.emit(',');\n                }\n\n                if(arg) {\n                    var id = this.tmpid();\n\n                    this.emitLine('function(cb) {');\n                    this.emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');\n                    this.pushBufferId(id);\n\n                    this.withScopedSyntax(function() {\n                        this.compile(arg, frame);\n                        this.emitLine('cb(null, ' + id + ');');\n                    });\n\n                    this.popBufferId();\n                    this.emitLine('return ' + id + ';');\n                    this.emitLine('}');\n                }\n                else {\n                    this.emit('null');\n                }\n            }, this);\n        }\n\n        if(async) {\n            var res = this.tmpid();\n            this.emitLine(', ' + this.makeCallback(res));\n            this.emitLine(this.buffer + ' += runtime.suppressValue(' + res + ', ' + autoescape + ' && env.opts.autoescape);');\n            this.addScopeLevel();\n        }\n        else {\n            this.emit(')');\n            this.emit(', ' + autoescape + ' && env.opts.autoescape);\\n');\n        }\n    },\n\n    compileCallExtensionAsync: function(node, frame) {\n        this.compileCallExtension(node, frame, true);\n    },\n\n    compileNodeList: function(node, frame) {\n        this._compileChildren(node, frame);\n    },\n\n    compileLiteral: function(node) {\n        if(typeof node.value === 'string') {\n            var val = node.value.replace(/\\\\/g, '\\\\\\\\');\n            val = val.replace(/\"/g, '\\\\\"');\n            val = val.replace(/\\n/g, '\\\\n');\n            val = val.replace(/\\r/g, '\\\\r');\n            val = val.replace(/\\t/g, '\\\\t');\n            this.emit('\"' + val  + '\"');\n        }\n        else if (node.value === null) {\n            this.emit('null');\n        }\n        else {\n            this.emit(node.value.toString());\n        }\n    },\n\n    compileSymbol: function(node, frame) {\n        var name = node.value;\n        var v;\n\n        if((v = frame.lookup(name))) {\n            this.emit(v);\n        }\n        else {\n            this.emit('runtime.contextOrFrameLookup(' +\n                      'context, frame, \"' + name + '\")');\n        }\n    },\n\n    compileGroup: function(node, frame) {\n        this._compileAggregate(node, frame, '(', ')');\n    },\n\n    compileArray: function(node, frame) {\n        this._compileAggregate(node, frame, '[', ']');\n    },\n\n    compileDict: function(node, frame) {\n        this._compileAggregate(node, frame, '{', '}');\n    },\n\n    compilePair: function(node, frame) {\n        var key = node.key;\n        var val = node.value;\n\n        if(key instanceof nodes.Symbol) {\n            key = new nodes.Literal(key.lineno, key.colno, key.value);\n        }\n        else if(!(key instanceof nodes.Literal &&\n                  typeof key.value === 'string')) {\n            this.fail('compilePair: Dict keys must be strings or names',\n                      key.lineno,\n                      key.colno);\n        }\n\n        this.compile(key, frame);\n        this.emit(': ');\n        this._compileExpression(val, frame);\n    },\n\n    compileInlineIf: function(node, frame) {\n        this.emit('(');\n        this.compile(node.cond, frame);\n        this.emit('?');\n        this.compile(node.body, frame);\n        this.emit(':');\n        if(node.else_ !== null)\n            this.compile(node.else_, frame);\n        else\n            this.emit('\"\"');\n        this.emit(')');\n    },\n\n    compileIn: function(node, frame) {\n      this.emit('runtime.inOperator(');\n      this.compile(node.left, frame);\n      this.emit(',');\n      this.compile(node.right, frame);\n      this.emit(')');\n    },\n\n    compileOr: binOpEmitter(' || '),\n    compileAnd: binOpEmitter(' && '),\n    compileAdd: binOpEmitter(' + '),\n    // ensure concatenation instead of addition\n    // by adding empty string in between\n    compileConcat: binOpEmitter(' + \"\" + '),\n    compileSub: binOpEmitter(' - '),\n    compileMul: binOpEmitter(' * '),\n    compileDiv: binOpEmitter(' / '),\n    compileMod: binOpEmitter(' % '),\n\n    compileNot: function(node, frame) {\n        this.emit('!');\n        this.compile(node.target, frame);\n    },\n\n    compileFloorDiv: function(node, frame) {\n        this.emit('Math.floor(');\n        this.compile(node.left, frame);\n        this.emit(' / ');\n        this.compile(node.right, frame);\n        this.emit(')');\n    },\n\n    compilePow: function(node, frame) {\n        this.emit('Math.pow(');\n        this.compile(node.left, frame);\n        this.emit(', ');\n        this.compile(node.right, frame);\n        this.emit(')');\n    },\n\n    compileNeg: function(node, frame) {\n        this.emit('-');\n        this.compile(node.target, frame);\n    },\n\n    compilePos: function(node, frame) {\n        this.emit('+');\n        this.compile(node.target, frame);\n    },\n\n    compileCompare: function(node, frame) {\n        this.compile(node.expr, frame);\n\n        for(var i=0; i<node.ops.length; i++) {\n            var n = node.ops[i];\n            this.emit(' ' + compareOps[n.type] + ' ');\n            this.compile(n.expr, frame);\n        }\n    },\n\n    compileLookupVal: function(node, frame) {\n        this.emit('runtime.memberLookup((');\n        this._compileExpression(node.target, frame);\n        this.emit('),');\n        this._compileExpression(node.val, frame);\n        this.emit(')');\n    },\n\n    _getNodeName: function(node) {\n        switch (node.typename) {\n            case 'Symbol':\n                return node.value;\n            case 'FunCall':\n                return 'the return value of (' + this._getNodeName(node.name) + ')';\n            case 'LookupVal':\n                return this._getNodeName(node.target) + '[\"' +\n                       this._getNodeName(node.val) + '\"]';\n            case 'Literal':\n                return node.value.toString();\n            default:\n                return '--expression--';\n        }\n    },\n\n    compileFunCall: function(node, frame) {\n        // Keep track of line/col info at runtime by settings\n        // variables within an expression. An expression in javascript\n        // like (x, y, z) returns the last value, and x and y can be\n        // anything\n        this.emit('(lineno = ' + node.lineno +\n                  ', colno = ' + node.colno + ', ');\n\n        this.emit('runtime.callWrap(');\n        // Compile it as normal.\n        this._compileExpression(node.name, frame);\n\n        // Output the name of what we're calling so we can get friendly errors\n        // if the lookup fails.\n        this.emit(', \"' + this._getNodeName(node.name).replace(/\"/g, '\\\\\"') + '\", context, ');\n\n        this._compileAggregate(node.args, frame, '[', '])');\n\n        this.emit(')');\n    },\n\n    compileFilter: function(node, frame) {\n        var name = node.name;\n        this.assertType(name, nodes.Symbol);\n        this.emit('env.getFilter(\"' + name.value + '\").call(context, ');\n        this._compileAggregate(node.args, frame);\n        this.emit(')');\n    },\n\n    compileFilterAsync: function(node, frame) {\n        var name = node.name;\n        this.assertType(name, nodes.Symbol);\n\n        var symbol = node.symbol.value;\n        frame.set(symbol, symbol);\n\n        this.emit('env.getFilter(\"' + name.value + '\").call(context, ');\n        this._compileAggregate(node.args, frame);\n        this.emitLine(', ' + this.makeCallback(symbol));\n\n        this.addScopeLevel();\n    },\n\n    compileKeywordArgs: function(node, frame) {\n        var names = [];\n\n        lib.each(node.children, function(pair) {\n            names.push(pair.key.value);\n        });\n\n        this.emit('runtime.makeKeywordArgs(');\n        this.compileDict(node, frame);\n        this.emit(')');\n    },\n\n    compileSet: function(node, frame) {\n        var ids = [];\n\n        // Lookup the variable names for each identifier and create\n        // new ones if necessary\n        lib.each(node.targets, function(target) {\n            var name = target.value;\n            var id = frame.lookup(name);\n\n            if (id === null || id === undefined) {\n                id = this.tmpid();\n\n                // Note: This relies on js allowing scope across\n                // blocks, in case this is created inside an `if`\n                this.emitLine('var ' + id + ';');\n            }\n\n            ids.push(id);\n        }, this);\n\n        if (node.value) {\n          this.emit(ids.join(' = ') + ' = ');\n          this._compileExpression(node.value, frame);\n          this.emitLine(';');\n        }\n        else {\n          this.emit(ids.join(' = ') + ' = ');\n          this.compile(node.body, frame);\n          this.emitLine(';');\n        }\n\n        lib.each(node.targets, function(target, i) {\n            var id = ids[i];\n            var name = target.value;\n\n            // We are running this for every var, but it's very\n            // uncommon to assign to multiple vars anyway\n            this.emitLine('frame.set(\"' + name + '\", ' + id + ', true);');\n\n            this.emitLine('if(frame.topLevel) {');\n            this.emitLine('context.setVariable(\"' + name + '\", ' + id + ');');\n            this.emitLine('}');\n\n            if(name.charAt(0) !== '_') {\n                this.emitLine('if(frame.topLevel) {');\n                this.emitLine('context.addExport(\"' + name + '\", ' + id + ');');\n                this.emitLine('}');\n            }\n        }, this);\n    },\n\n    compileIf: function(node, frame, async) {\n        this.emit('if(');\n        this._compileExpression(node.cond, frame);\n        this.emitLine(') {');\n\n        this.withScopedSyntax(function() {\n            this.compile(node.body, frame);\n\n            if(async) {\n                this.emit('cb()');\n            }\n        });\n\n        if(node.else_) {\n            this.emitLine('}\\nelse {');\n\n            this.withScopedSyntax(function() {\n                this.compile(node.else_, frame);\n\n                if(async) {\n                    this.emit('cb()');\n                }\n            });\n        } else if(async) {\n            this.emitLine('}\\nelse {');\n            this.emit('cb()');\n        }\n\n        this.emitLine('}');\n    },\n\n    compileIfAsync: function(node, frame) {\n        this.emit('(function(cb) {');\n        this.compileIf(node, frame, true);\n        this.emit('})(' + this.makeCallback());\n        this.addScopeLevel();\n    },\n\n    emitLoopBindings: function(node, arr, i, len) {\n        var bindings = {\n            index: i + ' + 1',\n            index0: i,\n            revindex: len + ' - ' + i,\n            revindex0: len + ' - ' + i + ' - 1',\n            first: i + ' === 0',\n            last: i + ' === ' + len + ' - 1',\n            length: len\n        };\n\n        for (var name in bindings) {\n            this.emitLine('frame.set(\"loop.' + name + '\", ' + bindings[name] + ');');\n        }\n    },\n\n    compileFor: function(node, frame) {\n        // Some of this code is ugly, but it keeps the generated code\n        // as fast as possible. ForAsync also shares some of this, but\n        // not much.\n\n        var v;\n        var i = this.tmpid();\n        var len = this.tmpid();\n        var arr = this.tmpid();\n        frame = frame.push();\n\n        this.emitLine('frame = frame.push();');\n\n        this.emit('var ' + arr + ' = ');\n        this._compileExpression(node.arr, frame);\n        this.emitLine(';');\n\n        this.emit('if(' + arr + ') {');\n\n        // If multiple names are passed, we need to bind them\n        // appropriately\n        if(node.name instanceof nodes.Array) {\n            this.emitLine('var ' + i + ';');\n\n            // The object could be an arroy or object. Note that the\n            // body of the loop is duplicated for each condition, but\n            // we are optimizing for speed over size.\n            this.emitLine('if(runtime.isArray(' + arr + ')) {'); {\n                this.emitLine('var ' + len + ' = ' + arr + '.length;');\n                this.emitLine('for(' + i + '=0; ' + i + ' < ' + arr + '.length; '\n                              + i + '++) {');\n\n                // Bind each declared var\n                for (var u=0; u < node.name.children.length; u++) {\n                    var tid = this.tmpid();\n                    this.emitLine('var ' + tid + ' = ' + arr + '[' + i + '][' + u + ']');\n                    this.emitLine('frame.set(\"' + node.name.children[u].value\n                                  + '\", ' + arr + '[' + i + '][' + u + ']' + ');');\n                    frame.set(node.name.children[u].value, tid);\n                }\n\n                this.emitLoopBindings(node, arr, i, len);\n                this.withScopedSyntax(function() {\n                    this.compile(node.body, frame);\n                });\n                this.emitLine('}');\n            }\n\n            this.emitLine('} else {'); {\n                // Iterate over the key/values of an object\n                var key = node.name.children[0];\n                var val = node.name.children[1];\n                var k = this.tmpid();\n                v = this.tmpid();\n                frame.set(key.value, k);\n                frame.set(val.value, v);\n\n                this.emitLine(i + ' = -1;');\n                this.emitLine('var ' + len + ' = runtime.keys(' + arr + ').length;');\n                this.emitLine('for(var ' + k + ' in ' + arr + ') {');\n                this.emitLine(i + '++;');\n                this.emitLine('var ' + v + ' = ' + arr + '[' + k + '];');\n                this.emitLine('frame.set(\"' + key.value + '\", ' + k + ');');\n                this.emitLine('frame.set(\"' + val.value + '\", ' + v + ');');\n\n                this.emitLoopBindings(node, arr, i, len);\n                this.withScopedSyntax(function() {\n                    this.compile(node.body, frame);\n                });\n                this.emitLine('}');\n            }\n\n            this.emitLine('}');\n        }\n        else {\n            // Generate a typical array iteration\n            v = this.tmpid();\n            frame.set(node.name.value, v);\n\n            this.emitLine('var ' + len + ' = ' + arr + '.length;');\n            this.emitLine('for(var ' + i + '=0; ' + i + ' < ' + arr + '.length; ' +\n                          i + '++) {');\n            this.emitLine('var ' + v + ' = ' + arr + '[' + i + '];');\n            this.emitLine('frame.set(\"' + node.name.value + '\", ' + v + ');');\n\n            this.emitLoopBindings(node, arr, i, len);\n\n            this.withScopedSyntax(function() {\n                this.compile(node.body, frame);\n            });\n\n            this.emitLine('}');\n        }\n\n        this.emitLine('}');\n        if (node.else_) {\n          this.emitLine('if (!' + len + ') {');\n          this.compile(node.else_, frame);\n          this.emitLine('}');\n        }\n\n        this.emitLine('frame = frame.pop();');\n    },\n\n    _compileAsyncLoop: function(node, frame, parallel) {\n        // This shares some code with the For tag, but not enough to\n        // worry about. This iterates across an object asynchronously,\n        // but not in parallel.\n\n        var i = this.tmpid();\n        var len = this.tmpid();\n        var arr = this.tmpid();\n        var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';\n        frame = frame.push();\n\n        this.emitLine('frame = frame.push();');\n\n        this.emit('var ' + arr + ' = ');\n        this._compileExpression(node.arr, frame);\n        this.emitLine(';');\n\n        if(node.name instanceof nodes.Array) {\n            this.emit('runtime.' + asyncMethod + '(' + arr + ', ' +\n                      node.name.children.length + ', function(');\n\n            lib.each(node.name.children, function(name) {\n                this.emit(name.value + ',');\n            }, this);\n\n            this.emit(i + ',' + len + ',next) {');\n\n            lib.each(node.name.children, function(name) {\n                var id = name.value;\n                frame.set(id, id);\n                this.emitLine('frame.set(\"' + id + '\", ' + id + ');');\n            }, this);\n        }\n        else {\n            var id = node.name.value;\n            this.emitLine('runtime.' + asyncMethod + '(' + arr + ', 1, function(' + id + ', ' + i + ', ' + len + ',next) {');\n            this.emitLine('frame.set(\"' + id + '\", ' + id + ');');\n            frame.set(id, id);\n        }\n\n        this.emitLoopBindings(node, arr, i, len);\n\n        this.withScopedSyntax(function() {\n            var buf;\n            if(parallel) {\n                buf = this.tmpid();\n                this.pushBufferId(buf);\n            }\n\n            this.compile(node.body, frame);\n            this.emitLine('next(' + i + (buf ? ',' + buf : '') + ');');\n\n            if(parallel) {\n                this.popBufferId();\n            }\n        });\n\n        var output = this.tmpid();\n        this.emitLine('}, ' + this.makeCallback(output));\n        this.addScopeLevel();\n\n        if(parallel) {\n            this.emitLine(this.buffer + ' += ' + output + ';');\n        }\n\n        if (node.else_) {\n          this.emitLine('if (!' + arr + '.length) {');\n          this.compile(node.else_, frame);\n          this.emitLine('}');\n        }\n\n        this.emitLine('frame = frame.pop();');\n    },\n\n    compileAsyncEach: function(node, frame) {\n        this._compileAsyncLoop(node, frame);\n    },\n\n    compileAsyncAll: function(node, frame) {\n        this._compileAsyncLoop(node, frame, true);\n    },\n\n    _compileMacro: function(node) {\n        var args = [];\n        var kwargs = null;\n        var funcId = 'macro_' + this.tmpid();\n\n        // Type check the definition of the args\n        lib.each(node.args.children, function(arg, i) {\n            if(i === node.args.children.length - 1 &&\n               arg instanceof nodes.Dict) {\n                kwargs = arg;\n            }\n            else {\n                this.assertType(arg, nodes.Symbol);\n                args.push(arg);\n            }\n        }, this);\n\n        var realNames = lib.map(args, function(n) { return 'l_' + n.value; });\n        realNames.push('kwargs');\n\n        // Quoted argument names\n        var argNames = lib.map(args, function(n) { return '\"' + n.value + '\"'; });\n        var kwargNames = lib.map((kwargs && kwargs.children) || [],\n                                 function(n) { return '\"' + n.key.value + '\"'; });\n\n        // We pass a function to makeMacro which destructures the\n        // arguments so support setting positional args with keywords\n        // args and passing keyword args as positional args\n        // (essentially default values). See runtime.js.\n        var frame = new Frame();\n        this.emitLines(\n            'var ' + funcId + ' = runtime.makeMacro(',\n            '[' + argNames.join(', ') + '], ',\n            '[' + kwargNames.join(', ') + '], ',\n            'function (' + realNames.join(', ') + ') {',\n            'var callerFrame = frame;',\n            'frame = new runtime.Frame();',\n            'kwargs = kwargs || {};',\n            'if (kwargs.hasOwnProperty(\"caller\")) {',\n            'frame.set(\"caller\", kwargs.caller); }'\n        );\n\n        // Expose the arguments to the template. Don't need to use\n        // random names because the function\n        // will create a new run-time scope for us\n        lib.each(args, function(arg) {\n            this.emitLine('frame.set(\"' + arg.value + '\", ' +\n                          'l_' + arg.value + ');');\n            frame.set(arg.value, 'l_' + arg.value);\n        }, this);\n\n        // Expose the keyword arguments\n        if(kwargs) {\n            lib.each(kwargs.children, function(pair) {\n                var name = pair.key.value;\n                this.emit('frame.set(\"' + name + '\", ' +\n                          'kwargs.hasOwnProperty(\"' + name + '\") ? ' +\n                          'kwargs[\"' + name + '\"] : ');\n                this._compileExpression(pair.value, frame);\n                this.emitLine(');');\n            }, this);\n        }\n\n        var bufferId = this.tmpid();\n        this.pushBufferId(bufferId);\n\n        this.withScopedSyntax(function () {\n          this.compile(node.body, frame);\n        });\n\n        this.emitLine('frame = callerFrame;');\n        this.emitLine('return new runtime.SafeString(' + bufferId + ');');\n        this.emitLine('});');\n        this.popBufferId();\n\n        return funcId;\n    },\n\n    compileMacro: function(node, frame) {\n        var funcId = this._compileMacro(node, frame);\n\n        // Expose the macro to the templates\n        var name = node.name.value;\n        frame.set(name, funcId);\n\n        if(frame.parent) {\n            this.emitLine('frame.set(\"' + name + '\", ' + funcId + ');');\n        }\n        else {\n            if(node.name.value.charAt(0) !== '_') {\n                this.emitLine('context.addExport(\"' + name + '\");');\n            }\n            this.emitLine('context.setVariable(\"' + name + '\", ' + funcId + ');');\n        }\n    },\n\n    compileCaller: function(node, frame) {\n        // basically an anonymous \"macro expression\"\n        this.emit('(function (){');\n        var funcId = this._compileMacro(node, frame);\n        this.emit('return ' + funcId + ';})()');\n    },\n\n    compileImport: function(node, frame) {\n        var id = this.tmpid();\n        var target = node.target.value;\n\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(id));\n        this.addScopeLevel();\n\n        this.emitLine(id + '.getExported(' +\n            (node.withContext ? 'context.getVariables(), frame, ' : '') +\n            this.makeCallback(id));\n        this.addScopeLevel();\n\n        frame.set(target, id);\n\n        if(frame.parent) {\n            this.emitLine('frame.set(\"' + target + '\", ' + id + ');');\n        }\n        else {\n            this.emitLine('context.setVariable(\"' + target + '\", ' + id + ');');\n        }\n    },\n\n    compileFromImport: function(node, frame) {\n        var importedId = this.tmpid();\n\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(importedId));\n        this.addScopeLevel();\n\n        this.emitLine(importedId + '.getExported(' +\n            (node.withContext ? 'context.getVariables(), frame, ' : '') +\n            this.makeCallback(importedId));\n        this.addScopeLevel();\n\n        lib.each(node.names.children, function(nameNode) {\n            var name;\n            var alias;\n            var id = this.tmpid();\n\n            if(nameNode instanceof nodes.Pair) {\n                name = nameNode.key.value;\n                alias = nameNode.value.value;\n            }\n            else {\n                name = nameNode.value;\n                alias = name;\n            }\n\n            this.emitLine('if(' + importedId + '.hasOwnProperty(\"' + name + '\")) {');\n            this.emitLine('var ' + id + ' = ' + importedId + '.' + name + ';');\n            this.emitLine('} else {');\n            this.emitLine('cb(new Error(\"cannot import \\'' + name + '\\'\")); return;');\n            this.emitLine('}');\n\n            frame.set(alias, id);\n\n            if(frame.parent) {\n                this.emitLine('frame.set(\"' + alias + '\", ' + id + ');');\n            }\n            else {\n                this.emitLine('context.setVariable(\"' + alias + '\", ' + id + ');');\n            }\n        }, this);\n    },\n\n    compileBlock: function(node) {\n        var id = this.tmpid();\n\n        // If we are executing outside a block (creating a top-level\n        // block), we really don't want to execute its code because it\n        // will execute twice: once when the child template runs and\n        // again when the parent template runs. Note that blocks\n        // within blocks will *always* execute immediately *and*\n        // wherever else they are invoked (like used in a parent\n        // template). This may have behavioral differences from jinja\n        // because blocks can have side effects, but it seems like a\n        // waste of performance to always execute huge top-level\n        // blocks twice\n        if(!this.inBlock) {\n            this.emit('(parentTemplate ? function(e, c, f, r, cb) { cb(\"\"); } : ');\n        }\n        this.emit('context.getBlock(\"' + node.name.value + '\")');\n        if(!this.inBlock) {\n            this.emit(')');\n        }\n        this.emitLine('(env, context, frame, runtime, ' + this.makeCallback(id));\n        this.emitLine(this.buffer + ' += ' + id + ';');\n        this.addScopeLevel();\n    },\n\n    compileSuper: function(node, frame) {\n        var name = node.blockName.value;\n        var id = node.symbol.value;\n\n        this.emitLine('context.getSuper(env, ' +\n                      '\"' + name + '\", ' +\n                      'b_' + name + ', ' +\n                      'frame, runtime, '+\n                      this.makeCallback(id));\n        this.emitLine(id + ' = runtime.markSafe(' + id + ');');\n        this.addScopeLevel();\n        frame.set(id, id);\n    },\n\n    compileExtends: function(node, frame) {\n        var k = this.tmpid();\n\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', true, '+this._templateName()+', false, ' + this.makeCallback('_parentTemplate'));\n\n        // extends is a dynamic tag and can occur within a block like\n        // `if`, so if this happens we need to capture the parent\n        // template in the top-level scope\n        this.emitLine('parentTemplate = _parentTemplate');\n\n        this.emitLine('for(var ' + k + ' in parentTemplate.blocks) {');\n        this.emitLine('context.addBlock(' + k +\n                      ', parentTemplate.blocks[' + k + ']);');\n        this.emitLine('}');\n\n        this.addScopeLevel();\n    },\n\n    compileInclude: function(node, frame) {\n        var id = this.tmpid();\n        var id2 = this.tmpid();\n\n        this.emitLine('var tasks = [];');\n        this.emitLine('tasks.push(');\n        this.emitLine('function(callback) {');\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', false, '+this._templateName()+', ' + node.ignoreMissing + ', ' + this.makeCallback(id));\n        this.emitLine('callback(null,' + id + ');});');\n        this.emitLine('});');\n\n        this.emitLine('tasks.push(');\n        this.emitLine('function(template, callback){');\n        this.emitLine('template.render(' +\n            'context.getVariables(), frame, ' + this.makeCallback(id2));\n        this.emitLine('callback(null,' + id2 + ');});');\n        this.emitLine('});');\n\n        this.emitLine('tasks.push(');\n        this.emitLine('function(result, callback){');\n        this.emitLine(this.buffer + ' += result;');\n        this.emitLine('callback(null);');\n        this.emitLine('});');\n        this.emitLine('env.waterfall(tasks, function(){');\n        this.addScopeLevel();\n    },\n\n    compileTemplateData: function(node, frame) {\n        this.compileLiteral(node, frame);\n    },\n\n    compileCapture: function(node, frame) {\n        this.emitLine('(function() {');\n        this.emitLine('var output = \"\";');\n        this.withScopedSyntax(function () {\n            this.compile(node.body, frame);\n        });\n        this.emitLine('return output;');\n        this.emitLine('})()');\n    },\n\n    compileOutput: function(node, frame) {\n        var children = node.children;\n        for(var i=0, l=children.length; i<l; i++) {\n            // TemplateData is a special case because it is never\n            // autoescaped, so simply output it for optimization\n            if(children[i] instanceof nodes.TemplateData) {\n                if(children[i].value) {\n                    this.emit(this.buffer + ' += ');\n                    this.compileLiteral(children[i], frame);\n                    this.emitLine(';');\n                }\n            }\n            else {\n                this.emit(this.buffer + ' += runtime.suppressValue(');\n                if(this.throwOnUndefined) {\n                    this.emit('runtime.ensureDefined(');\n                }\n                this.compile(children[i], frame);\n                if(this.throwOnUndefined) {\n                    this.emit(',' + node.lineno + ',' + node.colno + ')');\n                }\n                this.emit(', env.opts.autoescape);\\n');\n            }\n        }\n    },\n\n    compileRoot: function(node, frame) {\n        if(frame) {\n            this.fail('compileRoot: root node can\\'t have frame');\n        }\n\n        frame = new Frame();\n\n        this.emitFuncBegin('root');\n        this.emitLine('var parentTemplate = null;');\n        this._compileChildren(node, frame);\n        this.emitLine('if(parentTemplate) {');\n        this.emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');\n        this.emitLine('} else {');\n        this.emitLine('cb(null, ' + this.buffer +');');\n        this.emitLine('}');\n        this.emitFuncEnd(true);\n\n        this.inBlock = true;\n\n        var blockNames = [];\n\n        var i, name, block, blocks = node.findAll(nodes.Block);\n        for (i = 0; i < blocks.length; i++) {\n            block = blocks[i];\n            name = block.name.value;\n\n            if (blockNames.indexOf(name) !== -1) {\n                throw new Error('Block \"' + name + '\" defined more than once.');\n            }\n            blockNames.push(name);\n\n            this.emitFuncBegin('b_' + name);\n\n            var tmpFrame = new Frame();\n            this.emitLine('var frame = frame.push(true);');\n            this.compile(block.body, tmpFrame);\n            this.emitFuncEnd();\n        }\n\n        this.emitLine('return {');\n        for (i = 0; i < blocks.length; i++) {\n            block = blocks[i];\n            name = 'b_' + block.name.value;\n            this.emitLine(name + ': ' + name + ',');\n        }\n        this.emitLine('root: root\\n};');\n    },\n\n    compile: function (node, frame) {\n        var _compile = this['compile' + node.typename];\n        if(_compile) {\n            _compile.call(this, node, frame);\n        }\n        else {\n            this.fail('compile: Cannot compile node: ' + node.typename,\n                      node.lineno,\n                      node.colno);\n        }\n    },\n\n    getCode: function() {\n        return this.codebuf.join('');\n    }\n});\n\n// var c = new Compiler();\n// var src = 'hello {% filter title %}' +\n//     'Hello madam how are you' +\n//     '{% endfilter %}'\n// var ast = transformer.transform(parser.parse(src));\n// nodes.printNodes(ast);\n// c.compile(ast);\n// var tmpl = c.getCode();\n// console.log(tmpl);\n\nmodule.exports = {\n    compile: function(src, asyncFilters, extensions, name, opts) {\n        var c = new Compiler(name, opts.throwOnUndefined);\n\n        // Run the extension preprocessors against the source.\n        if(extensions && extensions.length) {\n            for(var i=0; i<extensions.length; i++) {\n                if('preprocess' in extensions[i]) {\n                    src = extensions[i].preprocess(src, name);\n                }\n            }\n        }\n\n        c.compile(transformer.transform(\n            parser.parse(src,\n                         extensions,\n                         opts),\n            asyncFilters,\n            name\n        ));\n        return c.getCode();\n    },\n\n    Compiler: Compiler\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/parser.js":"'use strict';\n\nvar lexer = require('./lexer');\nvar nodes = require('./nodes');\n// jshint -W079\nvar Object = require('./object');\nvar lib = require('./lib');\n\nvar Parser = Object.extend({\n    init: function (tokens) {\n        this.tokens = tokens;\n        this.peeked = null;\n        this.breakOnBlocks = null;\n        this.dropLeadingWhitespace = false;\n\n        this.extensions = [];\n    },\n\n    nextToken: function (withWhitespace) {\n        var tok;\n\n        if(this.peeked) {\n            if(!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {\n                this.peeked = null;\n            }\n            else {\n                tok = this.peeked;\n                this.peeked = null;\n                return tok;\n            }\n        }\n\n        tok = this.tokens.nextToken();\n\n        if(!withWhitespace) {\n            while(tok && tok.type === lexer.TOKEN_WHITESPACE) {\n                tok = this.tokens.nextToken();\n            }\n        }\n\n        return tok;\n    },\n\n    peekToken: function () {\n        this.peeked = this.peeked || this.nextToken();\n        return this.peeked;\n    },\n\n    pushToken: function(tok) {\n        if(this.peeked) {\n            throw new Error('pushToken: can only push one token on between reads');\n        }\n        this.peeked = tok;\n    },\n\n    fail: function (msg, lineno, colno) {\n        if((lineno === undefined || colno === undefined) && this.peekToken()) {\n            var tok = this.peekToken();\n            lineno = tok.lineno;\n            colno = tok.colno;\n        }\n        if (lineno !== undefined) lineno += 1;\n        if (colno !== undefined) colno += 1;\n\n        throw new lib.TemplateError(msg, lineno, colno);\n    },\n\n    skip: function(type) {\n        var tok = this.nextToken();\n        if(!tok || tok.type !== type) {\n            this.pushToken(tok);\n            return false;\n        }\n        return true;\n    },\n\n    expect: function(type) {\n        var tok = this.nextToken();\n        if(tok.type !== type) {\n            this.fail('expected ' + type + ', got ' + tok.type,\n                      tok.lineno,\n                      tok.colno);\n        }\n        return tok;\n    },\n\n    skipValue: function(type, val) {\n        var tok = this.nextToken();\n        if(!tok || tok.type !== type || tok.value !== val) {\n            this.pushToken(tok);\n            return false;\n        }\n        return true;\n    },\n\n    skipSymbol: function(val) {\n        return this.skipValue(lexer.TOKEN_SYMBOL, val);\n    },\n\n    advanceAfterBlockEnd: function(name) {\n        var tok;\n        if(!name) {\n            tok = this.peekToken();\n\n            if(!tok) {\n                this.fail('unexpected end of file');\n            }\n\n            if(tok.type !== lexer.TOKEN_SYMBOL) {\n                this.fail('advanceAfterBlockEnd: expected symbol token or ' +\n                          'explicit name to be passed');\n            }\n\n            name = this.nextToken().value;\n        }\n\n        tok = this.nextToken();\n\n        if(tok && tok.type === lexer.TOKEN_BLOCK_END) {\n            if(tok.value.charAt(0) === '-') {\n                this.dropLeadingWhitespace = true;\n            }\n        }\n        else {\n            this.fail('expected block end in ' + name + ' statement');\n        }\n\n        return tok;\n    },\n\n    advanceAfterVariableEnd: function() {\n        var tok = this.nextToken();\n\n        if(tok && tok.type === lexer.TOKEN_VARIABLE_END) {\n            this.dropLeadingWhitespace = tok.value.charAt(\n                tok.value.length - this.tokens.tags.VARIABLE_END.length - 1\n            ) === '-';\n        } else {\n            this.pushToken(tok);\n            this.fail('expected variable end');\n        }\n    },\n\n    parseFor: function() {\n        var forTok = this.peekToken();\n        var node;\n        var endBlock;\n\n        if(this.skipSymbol('for')) {\n            node = new nodes.For(forTok.lineno, forTok.colno);\n            endBlock = 'endfor';\n        }\n        else if(this.skipSymbol('asyncEach')) {\n            node = new nodes.AsyncEach(forTok.lineno, forTok.colno);\n            endBlock = 'endeach';\n        }\n        else if(this.skipSymbol('asyncAll')) {\n            node = new nodes.AsyncAll(forTok.lineno, forTok.colno);\n            endBlock = 'endall';\n        }\n        else {\n            this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);\n        }\n\n        node.name = this.parsePrimary();\n\n        if(!(node.name instanceof nodes.Symbol)) {\n            this.fail('parseFor: variable name expected for loop');\n        }\n\n        var type = this.peekToken().type;\n        if(type === lexer.TOKEN_COMMA) {\n            // key/value iteration\n            var key = node.name;\n            node.name = new nodes.Array(key.lineno, key.colno);\n            node.name.addChild(key);\n\n            while(this.skip(lexer.TOKEN_COMMA)) {\n                var prim = this.parsePrimary();\n                node.name.addChild(prim);\n            }\n        }\n\n        if(!this.skipSymbol('in')) {\n            this.fail('parseFor: expected \"in\" keyword for loop',\n                      forTok.lineno,\n                      forTok.colno);\n        }\n\n        node.arr = this.parseExpression();\n        this.advanceAfterBlockEnd(forTok.value);\n\n        node.body = this.parseUntilBlocks(endBlock, 'else');\n\n        if(this.skipSymbol('else')) {\n            this.advanceAfterBlockEnd('else');\n            node.else_ = this.parseUntilBlocks(endBlock);\n        }\n\n        this.advanceAfterBlockEnd();\n\n        return node;\n    },\n\n    parseMacro: function() {\n        var macroTok = this.peekToken();\n        if(!this.skipSymbol('macro')) {\n            this.fail('expected macro');\n        }\n\n        var name = this.parsePrimary(true);\n        var args = this.parseSignature();\n        var node = new nodes.Macro(macroTok.lineno,\n                                   macroTok.colno,\n                                   name,\n                                   args);\n\n        this.advanceAfterBlockEnd(macroTok.value);\n        node.body = this.parseUntilBlocks('endmacro');\n        this.advanceAfterBlockEnd();\n\n        return node;\n    },\n\n    parseCall: function() {\n        // a call block is parsed as a normal FunCall, but with an added\n        // 'caller' kwarg which is a Caller node.\n        var callTok = this.peekToken();\n        if(!this.skipSymbol('call')) {\n            this.fail('expected call');\n        }\n\n        var callerArgs = this.parseSignature(true) || new nodes.NodeList();\n        var macroCall = this.parsePrimary();\n\n        this.advanceAfterBlockEnd(callTok.value);\n        var body = this.parseUntilBlocks('endcall');\n        this.advanceAfterBlockEnd();\n\n        var callerName = new nodes.Symbol(callTok.lineno,\n                                          callTok.colno,\n                                          'caller');\n        var callerNode = new nodes.Caller(callTok.lineno,\n                                          callTok.colno,\n                                          callerName,\n                                          callerArgs,\n                                          body);\n\n        // add the additional caller kwarg, adding kwargs if necessary\n        var args = macroCall.args.children;\n        if (!(args[args.length-1] instanceof nodes.KeywordArgs)) {\n          args.push(new nodes.KeywordArgs());\n        }\n        var kwargs = args[args.length - 1];\n        kwargs.addChild(new nodes.Pair(callTok.lineno,\n                                       callTok.colno,\n                                       callerName,\n                                       callerNode));\n\n        return new nodes.Output(callTok.lineno,\n                                callTok.colno,\n                                [macroCall]);\n    },\n\n    parseWithContext: function() {\n        var tok = this.peekToken();\n\n        var withContext = null;\n\n        if(this.skipSymbol('with')) {\n            withContext = true;\n        }\n        else if(this.skipSymbol('without')) {\n            withContext = false;\n        }\n\n        if(withContext !== null) {\n            if(!this.skipSymbol('context')) {\n                this.fail('parseFrom: expected context after with/without',\n                            tok.lineno,\n                            tok.colno);\n            }\n        }\n\n        return withContext;\n    },\n\n    parseImport: function() {\n        var importTok = this.peekToken();\n        if(!this.skipSymbol('import')) {\n            this.fail('parseImport: expected import',\n                      importTok.lineno,\n                      importTok.colno);\n        }\n\n        var template = this.parseExpression();\n\n        if(!this.skipSymbol('as')) {\n            this.fail('parseImport: expected \"as\" keyword',\n                            importTok.lineno,\n                            importTok.colno);\n        }\n\n        var target = this.parseExpression();\n\n        var withContext = this.parseWithContext();\n\n        var node = new nodes.Import(importTok.lineno,\n                                    importTok.colno,\n                                    template,\n                                    target,\n                                    withContext);\n\n        this.advanceAfterBlockEnd(importTok.value);\n\n        return node;\n    },\n\n    parseFrom: function() {\n        var fromTok = this.peekToken();\n        if(!this.skipSymbol('from')) {\n            this.fail('parseFrom: expected from');\n        }\n\n        var template = this.parseExpression();\n\n        if(!this.skipSymbol('import')) {\n            this.fail('parseFrom: expected import',\n                            fromTok.lineno,\n                            fromTok.colno);\n        }\n\n        var names = new nodes.NodeList(),\n            withContext;\n\n        while(1) {\n            var nextTok = this.peekToken();\n            if(nextTok.type === lexer.TOKEN_BLOCK_END) {\n                if(!names.children.length) {\n                    this.fail('parseFrom: Expected at least one import name',\n                              fromTok.lineno,\n                              fromTok.colno);\n                }\n\n                // Since we are manually advancing past the block end,\n                // need to keep track of whitespace control (normally\n                // this is done in `advanceAfterBlockEnd`\n                if(nextTok.value.charAt(0) === '-') {\n                    this.dropLeadingWhitespace = true;\n                }\n\n                this.nextToken();\n                break;\n            }\n\n            if(names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {\n                this.fail('parseFrom: expected comma',\n                                fromTok.lineno,\n                                fromTok.colno);\n            }\n\n            var name = this.parsePrimary();\n            if(name.value.charAt(0) === '_') {\n                this.fail('parseFrom: names starting with an underscore ' +\n                          'cannot be imported',\n                          name.lineno,\n                          name.colno);\n            }\n\n            if(this.skipSymbol('as')) {\n                var alias = this.parsePrimary();\n                names.addChild(new nodes.Pair(name.lineno,\n                                              name.colno,\n                                              name,\n                                              alias));\n            }\n            else {\n                names.addChild(name);\n            }\n\n            withContext = this.parseWithContext();\n        }\n\n        return new nodes.FromImport(fromTok.lineno,\n                                    fromTok.colno,\n                                    template,\n                                    names,\n                                    withContext);\n    },\n\n    parseBlock: function() {\n        var tag = this.peekToken();\n        if(!this.skipSymbol('block')) {\n            this.fail('parseBlock: expected block', tag.lineno, tag.colno);\n        }\n\n        var node = new nodes.Block(tag.lineno, tag.colno);\n\n        node.name = this.parsePrimary();\n        if(!(node.name instanceof nodes.Symbol)) {\n            this.fail('parseBlock: variable name expected',\n                      tag.lineno,\n                      tag.colno);\n        }\n\n        this.advanceAfterBlockEnd(tag.value);\n\n        node.body = this.parseUntilBlocks('endblock');\n        this.skipSymbol('endblock');\n        this.skipSymbol(node.name.value);\n\n        var tok = this.peekToken();\n        if(!tok) {\n            this.fail('parseBlock: expected endblock, got end of file');\n        }\n\n        this.advanceAfterBlockEnd(tok.value);\n\n        return node;\n    },\n\n    parseExtends: function() {\n        var tagName = 'extends';\n        var tag = this.peekToken();\n        if(!this.skipSymbol(tagName)) {\n            this.fail('parseTemplateRef: expected '+ tagName);\n        }\n\n        var node = new nodes.Extends(tag.lineno, tag.colno);\n        node.template = this.parseExpression();\n\n        this.advanceAfterBlockEnd(tag.value);\n        return node;\n    },\n\n    parseInclude: function() {\n        var tagName = 'include';\n        var tag = this.peekToken();\n        if(!this.skipSymbol(tagName)) {\n            this.fail('parseInclude: expected '+ tagName);\n        }\n\n        var node = new nodes.Include(tag.lineno, tag.colno);\n        node.template = this.parseExpression();\n\n        if(this.skipSymbol('ignore') && this.skipSymbol('missing')) {\n            node.ignoreMissing = true;\n        }\n\n        this.advanceAfterBlockEnd(tag.value);\n        return node;\n    },\n\n    parseIf: function() {\n        var tag = this.peekToken();\n        var node;\n\n        if(this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {\n            node = new nodes.If(tag.lineno, tag.colno);\n        }\n        else if(this.skipSymbol('ifAsync')) {\n            node = new nodes.IfAsync(tag.lineno, tag.colno);\n        }\n        else {\n            this.fail('parseIf: expected if, elif, or elseif',\n                      tag.lineno,\n                      tag.colno);\n        }\n\n        node.cond = this.parseExpression();\n        this.advanceAfterBlockEnd(tag.value);\n\n        node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');\n        var tok = this.peekToken();\n\n        switch(tok && tok.value) {\n        case 'elseif':\n        case 'elif':\n            node.else_ = this.parseIf();\n            break;\n        case 'else':\n            this.advanceAfterBlockEnd();\n            node.else_ = this.parseUntilBlocks('endif');\n            this.advanceAfterBlockEnd();\n            break;\n        case 'endif':\n            node.else_ = null;\n            this.advanceAfterBlockEnd();\n            break;\n        default:\n            this.fail('parseIf: expected elif, else, or endif, ' +\n                      'got end of file');\n        }\n\n        return node;\n    },\n\n    parseSet: function() {\n        var tag = this.peekToken();\n        if(!this.skipSymbol('set')) {\n            this.fail('parseSet: expected set', tag.lineno, tag.colno);\n        }\n\n        var node = new nodes.Set(tag.lineno, tag.colno, []);\n\n        var target;\n        while((target = this.parsePrimary())) {\n            node.targets.push(target);\n\n            if(!this.skip(lexer.TOKEN_COMMA)) {\n                break;\n            }\n        }\n\n        if(!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {\n            if (!this.skip(lexer.TOKEN_BLOCK_END)) {\n                this.fail('parseSet: expected = or block end in set tag',\n                          tag.lineno,\n                          tag.colno);\n            }\n            else {\n                node.body = new nodes.Capture(\n                    tag.lineno,\n                    tag.colno,\n                    this.parseUntilBlocks('endset')\n                );\n                node.value = null;\n                this.advanceAfterBlockEnd();\n            }\n        }\n        else {\n            node.value = this.parseExpression();\n            this.advanceAfterBlockEnd(tag.value);\n        }\n\n        return node;\n    },\n\n    parseStatement: function () {\n        var tok = this.peekToken();\n        var node;\n\n        if(tok.type !== lexer.TOKEN_SYMBOL) {\n            this.fail('tag name expected', tok.lineno, tok.colno);\n        }\n\n        if(this.breakOnBlocks &&\n           lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {\n            return null;\n        }\n\n        switch(tok.value) {\n        case 'raw': return this.parseRaw();\n        case 'verbatim': return this.parseRaw('verbatim');\n        case 'if':\n        case 'ifAsync':\n            return this.parseIf();\n        case 'for':\n        case 'asyncEach':\n        case 'asyncAll':\n            return this.parseFor();\n        case 'block': return this.parseBlock();\n        case 'extends': return this.parseExtends();\n        case 'include': return this.parseInclude();\n        case 'set': return this.parseSet();\n        case 'macro': return this.parseMacro();\n        case 'call': return this.parseCall();\n        case 'import': return this.parseImport();\n        case 'from': return this.parseFrom();\n        case 'filter': return this.parseFilterStatement();\n        default:\n            if (this.extensions.length) {\n                for (var i = 0; i < this.extensions.length; i++) {\n                    var ext = this.extensions[i];\n                    if (lib.indexOf(ext.tags || [], tok.value) !== -1) {\n                        return ext.parse(this, nodes, lexer);\n                    }\n                }\n            }\n            this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);\n        }\n\n        return node;\n    },\n\n    parseRaw: function(tagName) {\n        tagName = tagName || 'raw';\n        var endTagName = 'end' + tagName;\n        // Look for upcoming raw blocks (ignore all other kinds of blocks)\n        var rawBlockRegex = new RegExp('([\\\\s\\\\S]*?){%\\\\s*(' + tagName + '|' + endTagName + ')\\\\s*(?=%})%}');\n        var rawLevel = 1;\n        var str = '';\n        var matches = null;\n\n        // Skip opening raw token\n        // Keep this token to track line and column numbers\n        var begun = this.advanceAfterBlockEnd();\n\n        // Exit when there's nothing to match\n        // or when we've found the matching \"endraw\" block\n        while((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {\n            var all = matches[0];\n            var pre = matches[1];\n            var blockName = matches[2];\n\n            // Adjust rawlevel\n            if(blockName === tagName) {\n                rawLevel += 1;\n            } else if(blockName === endTagName) {\n                rawLevel -= 1;\n            }\n\n            // Add to str\n            if(rawLevel === 0) {\n                // We want to exclude the last \"endraw\"\n                str += pre;\n                // Move tokenizer to beginning of endraw block\n                this.tokens.backN(all.length - pre.length);\n            } else {\n                str += all;\n            }\n        }\n\n        return new nodes.Output(\n            begun.lineno,\n            begun.colno,\n            [new nodes.TemplateData(begun.lineno, begun.colno, str)]\n        );\n    },\n\n    parsePostfix: function(node) {\n        var lookup, tok = this.peekToken();\n\n        while(tok) {\n            if(tok.type === lexer.TOKEN_LEFT_PAREN) {\n                // Function call\n                node = new nodes.FunCall(tok.lineno,\n                                         tok.colno,\n                                         node,\n                                         this.parseSignature());\n            }\n            else if(tok.type === lexer.TOKEN_LEFT_BRACKET) {\n                // Reference\n                lookup = this.parseAggregate();\n                if(lookup.children.length > 1) {\n                    this.fail('invalid index');\n                }\n\n                node =  new nodes.LookupVal(tok.lineno,\n                                            tok.colno,\n                                            node,\n                                            lookup.children[0]);\n            }\n            else if(tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {\n                // Reference\n                this.nextToken();\n                var val = this.nextToken();\n\n                if(val.type !== lexer.TOKEN_SYMBOL) {\n                    this.fail('expected name as lookup value, got ' + val.value,\n                              val.lineno,\n                              val.colno);\n                }\n\n                // Make a literal string because it's not a variable\n                // reference\n                lookup = new nodes.Literal(val.lineno,\n                                               val.colno,\n                                               val.value);\n\n                node =  new nodes.LookupVal(tok.lineno,\n                                            tok.colno,\n                                            node,\n                                            lookup);\n            }\n            else {\n                break;\n            }\n\n            tok = this.peekToken();\n        }\n\n        return node;\n    },\n\n    parseExpression: function() {\n        var node = this.parseInlineIf();\n        return node;\n    },\n\n    parseInlineIf: function() {\n        var node = this.parseOr();\n        if(this.skipSymbol('if')) {\n            var cond_node = this.parseOr();\n            var body_node = node;\n            node = new nodes.InlineIf(node.lineno, node.colno);\n            node.body = body_node;\n            node.cond = cond_node;\n            if(this.skipSymbol('else')) {\n                node.else_ = this.parseOr();\n            } else {\n                node.else_ = null;\n            }\n        }\n\n        return node;\n    },\n\n    parseOr: function() {\n        var node = this.parseAnd();\n        while(this.skipSymbol('or')) {\n            var node2 = this.parseAnd();\n            node = new nodes.Or(node.lineno,\n                                node.colno,\n                                node,\n                                node2);\n        }\n        return node;\n    },\n\n    parseAnd: function() {\n        var node = this.parseNot();\n        while(this.skipSymbol('and')) {\n            var node2 = this.parseNot();\n            node = new nodes.And(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseNot: function() {\n        var tok = this.peekToken();\n        if(this.skipSymbol('not')) {\n            return new nodes.Not(tok.lineno,\n                                 tok.colno,\n                                 this.parseNot());\n        }\n        return this.parseIn();\n    },\n\n    parseIn: function() {\n      var node = this.parseCompare();\n      while(1) {\n        // check if the next token is 'not'\n        var tok = this.nextToken();\n        if (!tok) { break; }\n        var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not';\n        // if it wasn't 'not', put it back\n        if (!invert) { this.pushToken(tok); }\n        if (this.skipSymbol('in')) {\n          var node2 = this.parseCompare();\n          node = new nodes.In(node.lineno,\n                              node.colno,\n                              node,\n                              node2);\n          if (invert) {\n            node = new nodes.Not(node.lineno,\n                                 node.colno,\n                                 node);\n          }\n        }\n        else {\n          // if we'd found a 'not' but this wasn't an 'in', put back the 'not'\n          if (invert) { this.pushToken(tok); }\n          break;\n        }\n      }\n      return node;\n    },\n\n    parseCompare: function() {\n        var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];\n        var expr = this.parseConcat();\n        var ops = [];\n\n        while(1) {\n            var tok = this.nextToken();\n\n            if(!tok) {\n                break;\n            }\n            else if(lib.indexOf(compareOps, tok.value) !== -1) {\n                ops.push(new nodes.CompareOperand(tok.lineno,\n                                                  tok.colno,\n                                                  this.parseConcat(),\n                                                  tok.value));\n            }\n            else {\n                this.pushToken(tok);\n                break;\n            }\n        }\n\n        if(ops.length) {\n            return new nodes.Compare(ops[0].lineno,\n                                     ops[0].colno,\n                                     expr,\n                                     ops);\n        }\n        else {\n            return expr;\n        }\n    },\n\n    // finds the '~' for string concatenation\n    parseConcat: function(){\n        var node = this.parseAdd();\n        while(this.skipValue(lexer.TOKEN_TILDE, '~')) {\n            var node2 = this.parseAdd();\n            node = new nodes.Concat(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseAdd: function() {\n        var node = this.parseSub();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {\n            var node2 = this.parseSub();\n            node = new nodes.Add(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseSub: function() {\n        var node = this.parseMul();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {\n            var node2 = this.parseMul();\n            node = new nodes.Sub(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseMul: function() {\n        var node = this.parseDiv();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '*')) {\n            var node2 = this.parseDiv();\n            node = new nodes.Mul(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseDiv: function() {\n        var node = this.parseFloorDiv();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '/')) {\n            var node2 = this.parseFloorDiv();\n            node = new nodes.Div(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseFloorDiv: function() {\n        var node = this.parseMod();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '//')) {\n            var node2 = this.parseMod();\n            node = new nodes.FloorDiv(node.lineno,\n                                      node.colno,\n                                      node,\n                                      node2);\n        }\n        return node;\n    },\n\n    parseMod: function() {\n        var node = this.parsePow();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '%')) {\n            var node2 = this.parsePow();\n            node = new nodes.Mod(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parsePow: function() {\n        var node = this.parseUnary();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '**')) {\n            var node2 = this.parseUnary();\n            node = new nodes.Pow(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseUnary: function(noFilters) {\n        var tok = this.peekToken();\n        var node;\n\n        if(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {\n            node = new nodes.Neg(tok.lineno,\n                                 tok.colno,\n                                 this.parseUnary(true));\n        }\n        else if(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {\n            node = new nodes.Pos(tok.lineno,\n                                 tok.colno,\n                                 this.parseUnary(true));\n        }\n        else {\n            node = this.parsePrimary();\n        }\n\n        if(!noFilters) {\n            node = this.parseFilter(node);\n        }\n\n        return node;\n    },\n\n    parsePrimary: function (noPostfix) {\n        var tok = this.nextToken();\n        var val;\n        var node = null;\n\n        if(!tok) {\n            this.fail('expected expression, got end of file');\n        }\n        else if(tok.type === lexer.TOKEN_STRING) {\n            val = tok.value;\n        }\n        else if(tok.type === lexer.TOKEN_INT) {\n            val = parseInt(tok.value, 10);\n        }\n        else if(tok.type === lexer.TOKEN_FLOAT) {\n            val = parseFloat(tok.value);\n        }\n        else if(tok.type === lexer.TOKEN_BOOLEAN) {\n            if(tok.value === 'true') {\n                val = true;\n            }\n            else if(tok.value === 'false') {\n                val = false;\n            }\n            else {\n                this.fail('invalid boolean: ' + tok.value,\n                          tok.lineno,\n                          tok.colno);\n            }\n        }\n        else if(tok.type === lexer.TOKEN_NONE) {\n            val = null;\n        }\n        else if (tok.type === lexer.TOKEN_REGEX) {\n            val = new RegExp(tok.value.body, tok.value.flags);\n        }\n\n        if(val !== undefined) {\n            node = new nodes.Literal(tok.lineno, tok.colno, val);\n        }\n        else if(tok.type === lexer.TOKEN_SYMBOL) {\n            node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);\n\n            if(!noPostfix) {\n                node = this.parsePostfix(node);\n            }\n        }\n        else {\n            // See if it's an aggregate type, we need to push the\n            // current delimiter token back on\n            this.pushToken(tok);\n            node = this.parseAggregate();\n        }\n\n        if(node) {\n            return node;\n        }\n        else {\n            this.fail('unexpected token: ' + tok.value,\n                      tok.lineno,\n                      tok.colno);\n        }\n    },\n\n    parseFilterName: function() {\n        var tok = this.expect(lexer.TOKEN_SYMBOL);\n        var name = tok.value;\n\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '.')) {\n            name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;\n        }\n\n        return new nodes.Symbol(tok.lineno, tok.colno, name);\n    },\n\n    parseFilterArgs: function(node) {\n        if(this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {\n            // Get a FunCall node and add the parameters to the\n            // filter\n            var call = this.parsePostfix(node);\n            return call.args.children;\n        }\n        return [];\n    },\n\n    parseFilter: function(node) {\n        while(this.skip(lexer.TOKEN_PIPE)) {\n            var name = this.parseFilterName();\n\n            node = new nodes.Filter(\n                name.lineno,\n                name.colno,\n                name,\n                new nodes.NodeList(\n                    name.lineno,\n                    name.colno,\n                    [node].concat(this.parseFilterArgs(node))\n                )\n            );\n        }\n\n        return node;\n    },\n\n    parseFilterStatement: function() {\n        var filterTok = this.peekToken();\n        if(!this.skipSymbol('filter')) {\n            this.fail('parseFilterStatement: expected filter');\n        }\n\n        var name = this.parseFilterName();\n        var args = this.parseFilterArgs(name);\n\n        this.advanceAfterBlockEnd(filterTok.value);\n        var body = new nodes.Capture(\n            name.lineno,\n            name.colno,\n            this.parseUntilBlocks('endfilter')\n        );\n        this.advanceAfterBlockEnd();\n\n        var node = new nodes.Filter(\n            name.lineno,\n            name.colno,\n            name,\n            new nodes.NodeList(\n                name.lineno,\n                name.colno,\n                [body].concat(args)\n            )\n        );\n\n        return new nodes.Output(\n            name.lineno,\n            name.colno,\n            [node]\n        );\n    },\n\n    parseAggregate: function() {\n        var tok = this.nextToken();\n        var node;\n\n        switch(tok.type) {\n        case lexer.TOKEN_LEFT_PAREN:\n            node = new nodes.Group(tok.lineno, tok.colno); break;\n        case lexer.TOKEN_LEFT_BRACKET:\n            node = new nodes.Array(tok.lineno, tok.colno); break;\n        case lexer.TOKEN_LEFT_CURLY:\n            node = new nodes.Dict(tok.lineno, tok.colno); break;\n        default:\n            return null;\n        }\n\n        while(1) {\n            var type = this.peekToken().type;\n            if(type === lexer.TOKEN_RIGHT_PAREN ||\n               type === lexer.TOKEN_RIGHT_BRACKET ||\n               type === lexer.TOKEN_RIGHT_CURLY) {\n                this.nextToken();\n                break;\n            }\n\n            if(node.children.length > 0) {\n                if(!this.skip(lexer.TOKEN_COMMA)) {\n                    this.fail('parseAggregate: expected comma after expression',\n                              tok.lineno,\n                              tok.colno);\n                }\n            }\n\n            if(node instanceof nodes.Dict) {\n                // TODO: check for errors\n                var key = this.parsePrimary();\n\n                // We expect a key/value pair for dicts, separated by a\n                // colon\n                if(!this.skip(lexer.TOKEN_COLON)) {\n                    this.fail('parseAggregate: expected colon after dict key',\n                        tok.lineno,\n                        tok.colno);\n                }\n\n                // TODO: check for errors\n                var value = this.parseExpression();\n                node.addChild(new nodes.Pair(key.lineno,\n                                             key.colno,\n                                             key,\n                                             value));\n            }\n            else {\n                // TODO: check for errors\n                var expr = this.parseExpression();\n                node.addChild(expr);\n            }\n        }\n\n        return node;\n    },\n\n    parseSignature: function(tolerant, noParens) {\n        var tok = this.peekToken();\n        if(!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {\n            if(tolerant) {\n                return null;\n            }\n            else {\n                this.fail('expected arguments', tok.lineno, tok.colno);\n            }\n        }\n\n        if(tok.type === lexer.TOKEN_LEFT_PAREN) {\n            tok = this.nextToken();\n        }\n\n        var args = new nodes.NodeList(tok.lineno, tok.colno);\n        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);\n        var checkComma = false;\n\n        while(1) {\n            tok = this.peekToken();\n            if(!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {\n                this.nextToken();\n                break;\n            }\n            else if(noParens && tok.type === lexer.TOKEN_BLOCK_END) {\n                break;\n            }\n\n            if(checkComma && !this.skip(lexer.TOKEN_COMMA)) {\n                this.fail('parseSignature: expected comma after expression',\n                          tok.lineno,\n                          tok.colno);\n            }\n            else {\n                var arg = this.parseExpression();\n\n                if(this.skipValue(lexer.TOKEN_OPERATOR, '=')) {\n                    kwargs.addChild(\n                        new nodes.Pair(arg.lineno,\n                                       arg.colno,\n                                       arg,\n                                       this.parseExpression())\n                    );\n                }\n                else {\n                    args.addChild(arg);\n                }\n            }\n\n            checkComma = true;\n        }\n\n        if(kwargs.children.length) {\n            args.addChild(kwargs);\n        }\n\n        return args;\n    },\n\n    parseUntilBlocks: function(/* blockNames */) {\n        var prev = this.breakOnBlocks;\n        this.breakOnBlocks = lib.toArray(arguments);\n\n        var ret = this.parse();\n\n        this.breakOnBlocks = prev;\n        return ret;\n    },\n\n    parseNodes: function () {\n        var tok;\n        var buf = [];\n\n        while((tok = this.nextToken())) {\n            if(tok.type === lexer.TOKEN_DATA) {\n                var data = tok.value;\n                var nextToken = this.peekToken();\n                var nextVal = nextToken && nextToken.value;\n\n                // If the last token has \"-\" we need to trim the\n                // leading whitespace of the data. This is marked with\n                // the `dropLeadingWhitespace` variable.\n                if(this.dropLeadingWhitespace) {\n                    // TODO: this could be optimized (don't use regex)\n                    data = data.replace(/^\\s*/, '');\n                    this.dropLeadingWhitespace = false;\n                }\n\n                // Same for the succeeding block start token\n                if(nextToken &&\n                    ((nextToken.type === lexer.TOKEN_BLOCK_START &&\n                      nextVal.charAt(nextVal.length - 1) === '-') ||\n                    (nextToken.type === lexer.TOKEN_VARIABLE_START &&\n                      nextVal.charAt(this.tokens.tags.VARIABLE_START.length)\n                        === '-') ||\n                    (nextToken.type === lexer.TOKEN_COMMENT &&\n                      nextVal.charAt(this.tokens.tags.COMMENT_START.length)\n                        === '-'))) {\n                    // TODO: this could be optimized (don't use regex)\n                    data = data.replace(/\\s*$/, '');\n                }\n\n                buf.push(new nodes.Output(tok.lineno,\n                                          tok.colno,\n                                          [new nodes.TemplateData(tok.lineno,\n                                                                  tok.colno,\n                                                                  data)]));\n            }\n            else if(tok.type === lexer.TOKEN_BLOCK_START) {\n                this.dropLeadingWhitespace = false;\n                var n = this.parseStatement();\n                if(!n) {\n                    break;\n                }\n                buf.push(n);\n            }\n            else if(tok.type === lexer.TOKEN_VARIABLE_START) {\n                var e = this.parseExpression();\n                this.dropLeadingWhitespace = false;\n                this.advanceAfterVariableEnd();\n                buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));\n            }\n            else if(tok.type === lexer.TOKEN_COMMENT) {\n                this.dropLeadingWhitespace = tok.value.charAt(\n                    tok.value.length - this.tokens.tags.COMMENT_END.length - 1\n                ) === '-';\n            } else {\n                // Ignore comments, otherwise this should be an error\n                this.fail('Unexpected token at top-level: ' +\n                                tok.type, tok.lineno, tok.colno);\n\n            }\n        }\n\n        return buf;\n    },\n\n    parse: function() {\n        return new nodes.NodeList(0, 0, this.parseNodes());\n    },\n\n    parseAsRoot: function() {\n        return new nodes.Root(0, 0, this.parseNodes());\n    }\n});\n\n// var util = require('util');\n\n// var l = lexer.lex('{%- if x -%}\\n hello {% endif %}');\n// var t;\n// while((t = l.nextToken())) {\n//     console.log(util.inspect(t));\n// }\n\n// var p = new Parser(lexer.lex('hello {% filter title %}' +\n//                              'Hello madam how are you' +\n//                              '{% endfilter %}'));\n// var n = p.parseAsRoot();\n// nodes.printNodes(n);\n\nmodule.exports = {\n    parse: function(src, extensions, opts) {\n        var p = new Parser(lexer.lex(src, opts));\n        if (extensions !== undefined) {\n            p.extensions = extensions;\n        }\n        return p.parseAsRoot();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/lexer.js":"'use strict';\n\nvar lib = require('./lib');\n\nvar whitespaceChars = ' \\n\\t\\r\\u00A0';\nvar delimChars = '()[]{}%*-+~/#,:|.<>=!';\nvar intChars = '0123456789';\n\nvar BLOCK_START = '{%';\nvar BLOCK_END = '%}';\nvar VARIABLE_START = '{{';\nvar VARIABLE_END = '}}';\nvar COMMENT_START = '{#';\nvar COMMENT_END = '#}';\n\nvar TOKEN_STRING = 'string';\nvar TOKEN_WHITESPACE = 'whitespace';\nvar TOKEN_DATA = 'data';\nvar TOKEN_BLOCK_START = 'block-start';\nvar TOKEN_BLOCK_END = 'block-end';\nvar TOKEN_VARIABLE_START = 'variable-start';\nvar TOKEN_VARIABLE_END = 'variable-end';\nvar TOKEN_COMMENT = 'comment';\nvar TOKEN_LEFT_PAREN = 'left-paren';\nvar TOKEN_RIGHT_PAREN = 'right-paren';\nvar TOKEN_LEFT_BRACKET = 'left-bracket';\nvar TOKEN_RIGHT_BRACKET = 'right-bracket';\nvar TOKEN_LEFT_CURLY = 'left-curly';\nvar TOKEN_RIGHT_CURLY = 'right-curly';\nvar TOKEN_OPERATOR = 'operator';\nvar TOKEN_COMMA = 'comma';\nvar TOKEN_COLON = 'colon';\nvar TOKEN_TILDE = 'tilde';\nvar TOKEN_PIPE = 'pipe';\nvar TOKEN_INT = 'int';\nvar TOKEN_FLOAT = 'float';\nvar TOKEN_BOOLEAN = 'boolean';\nvar TOKEN_NONE = 'none';\nvar TOKEN_SYMBOL = 'symbol';\nvar TOKEN_SPECIAL = 'special';\nvar TOKEN_REGEX = 'regex';\n\nfunction token(type, value, lineno, colno) {\n    return {\n        type: type,\n        value: value,\n        lineno: lineno,\n        colno: colno\n    };\n}\n\nfunction Tokenizer(str, opts) {\n    this.str = str;\n    this.index = 0;\n    this.len = str.length;\n    this.lineno = 0;\n    this.colno = 0;\n\n    this.in_code = false;\n\n    opts = opts || {};\n\n    var tags = opts.tags || {};\n    this.tags = {\n        BLOCK_START: tags.blockStart || BLOCK_START,\n        BLOCK_END: tags.blockEnd || BLOCK_END,\n        VARIABLE_START: tags.variableStart || VARIABLE_START,\n        VARIABLE_END: tags.variableEnd || VARIABLE_END,\n        COMMENT_START: tags.commentStart || COMMENT_START,\n        COMMENT_END: tags.commentEnd || COMMENT_END\n    };\n\n    this.trimBlocks = !!opts.trimBlocks;\n    this.lstripBlocks = !!opts.lstripBlocks;\n}\n\nTokenizer.prototype.nextToken = function() {\n    var lineno = this.lineno;\n    var colno = this.colno;\n    var tok;\n\n    if(this.in_code) {\n        // Otherwise, if we are in a block parse it as code\n        var cur = this.current();\n\n        if(this.is_finished()) {\n            // We have nothing else to parse\n            return null;\n        }\n        else if(cur === '\"' || cur === '\\'') {\n            // We've hit a string\n            return token(TOKEN_STRING, this.parseString(cur), lineno, colno);\n        }\n        else if((tok = this._extract(whitespaceChars))) {\n            // We hit some whitespace\n            return token(TOKEN_WHITESPACE, tok, lineno, colno);\n        }\n        else if((tok = this._extractString(this.tags.BLOCK_END)) ||\n                (tok = this._extractString('-' + this.tags.BLOCK_END))) {\n            // Special check for the block end tag\n            //\n            // It is a requirement that start and end tags are composed of\n            // delimiter characters (%{}[] etc), and our code always\n            // breaks on delimiters so we can assume the token parsing\n            // doesn't consume these elsewhere\n            this.in_code = false;\n            if(this.trimBlocks) {\n                cur = this.current();\n                if(cur === '\\n') {\n                    // Skip newline\n                    this.forward();\n                }else if(cur === '\\r'){\n                    // Skip CRLF newline\n                    this.forward();\n                    cur = this.current();\n                    if(cur === '\\n'){\n                        this.forward();\n                    }else{\n                        // Was not a CRLF, so go back\n                        this.back();\n                    }\n                }\n            }\n            return token(TOKEN_BLOCK_END, tok, lineno, colno);\n        }\n        else if((tok = this._extractString(this.tags.VARIABLE_END)) ||\n                (tok = this._extractString('-' + this.tags.VARIABLE_END))) {\n            // Special check for variable end tag (see above)\n            this.in_code = false;\n            return token(TOKEN_VARIABLE_END, tok, lineno, colno);\n        }\n        else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {\n            // Skip past 'r/'.\n            this.forwardN(2);\n\n            // Extract until the end of the regex -- / ends it, \\/ does not.\n            var regexBody = '';\n            while (!this.is_finished()) {\n                if (this.current() === '/' && this.previous() !== '\\\\') {\n                    this.forward();\n                    break;\n                } else {\n                    regexBody += this.current();\n                    this.forward();\n                }\n            }\n\n            // Check for flags.\n            // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n            var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];\n            var regexFlags = '';\n            while (!this.is_finished()) {\n                var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;\n                if (isCurrentAFlag) {\n                    regexFlags += this.current();\n                    this.forward();\n                } else {\n                    break;\n                }\n            }\n\n            return token(TOKEN_REGEX, {body: regexBody, flags: regexFlags}, lineno, colno);\n        }\n        else if(delimChars.indexOf(cur) !== -1) {\n            // We've hit a delimiter (a special char like a bracket)\n            this.forward();\n            var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];\n            var curComplex = cur + this.current();\n            var type;\n\n            if(lib.indexOf(complexOps, curComplex) !== -1) {\n                this.forward();\n                cur = curComplex;\n\n                // See if this is a strict equality/inequality comparator\n                if(lib.indexOf(complexOps, curComplex + this.current()) !== -1) {\n                    cur = curComplex + this.current();\n                    this.forward();\n                }\n            }\n\n            switch(cur) {\n            case '(': type = TOKEN_LEFT_PAREN; break;\n            case ')': type = TOKEN_RIGHT_PAREN; break;\n            case '[': type = TOKEN_LEFT_BRACKET; break;\n            case ']': type = TOKEN_RIGHT_BRACKET; break;\n            case '{': type = TOKEN_LEFT_CURLY; break;\n            case '}': type = TOKEN_RIGHT_CURLY; break;\n            case ',': type = TOKEN_COMMA; break;\n            case ':': type = TOKEN_COLON; break;\n            case '~': type = TOKEN_TILDE; break;\n            case '|': type = TOKEN_PIPE; break;\n            default: type = TOKEN_OPERATOR;\n            }\n\n            return token(type, cur, lineno, colno);\n        }\n        else {\n            // We are not at whitespace or a delimiter, so extract the\n            // text and parse it\n            tok = this._extractUntil(whitespaceChars + delimChars);\n\n            if(tok.match(/^[-+]?[0-9]+$/)) {\n                if(this.current() === '.') {\n                    this.forward();\n                    var dec = this._extract(intChars);\n                    return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);\n                }\n                else {\n                    return token(TOKEN_INT, tok, lineno, colno);\n                }\n            }\n            else if(tok.match(/^(true|false)$/)) {\n                return token(TOKEN_BOOLEAN, tok, lineno, colno);\n            }\n            else if(tok === 'none') {\n                return token(TOKEN_NONE, tok, lineno, colno);\n            }\n            else if(tok) {\n                return token(TOKEN_SYMBOL, tok, lineno, colno);\n            }\n            else {\n                throw new Error('Unexpected value while parsing: ' + tok);\n            }\n        }\n    }\n    else {\n        // Parse out the template text, breaking on tag\n        // delimiters because we need to look for block/variable start\n        // tags (don't use the full delimChars for optimization)\n        var beginChars = (this.tags.BLOCK_START.charAt(0) +\n                          this.tags.VARIABLE_START.charAt(0) +\n                          this.tags.COMMENT_START.charAt(0) +\n                          this.tags.COMMENT_END.charAt(0));\n\n        if(this.is_finished()) {\n            return null;\n        }\n        else if((tok = this._extractString(this.tags.BLOCK_START + '-')) ||\n                (tok = this._extractString(this.tags.BLOCK_START))) {\n            this.in_code = true;\n            return token(TOKEN_BLOCK_START, tok, lineno, colno);\n        }\n        else if((tok = this._extractString(this.tags.VARIABLE_START + '-')) ||\n                (tok = this._extractString(this.tags.VARIABLE_START))) {\n            this.in_code = true;\n            return token(TOKEN_VARIABLE_START, tok, lineno, colno);\n        }\n        else {\n            tok = '';\n            var data;\n            var in_comment = false;\n\n            if(this._matches(this.tags.COMMENT_START)) {\n                in_comment = true;\n                tok = this._extractString(this.tags.COMMENT_START);\n            }\n\n            // Continually consume text, breaking on the tag delimiter\n            // characters and checking to see if it's a start tag.\n            //\n            // We could hit the end of the template in the middle of\n            // our looping, so check for the null return value from\n            // _extractUntil\n            while((data = this._extractUntil(beginChars)) !== null) {\n                tok += data;\n\n                if((this._matches(this.tags.BLOCK_START) ||\n                    this._matches(this.tags.VARIABLE_START) ||\n                    this._matches(this.tags.COMMENT_START)) &&\n                  !in_comment) {\n                    if(this.lstripBlocks &&\n                        this._matches(this.tags.BLOCK_START) &&\n                        this.colno > 0 &&\n                        this.colno <= tok.length) {\n                        var lastLine = tok.slice(-this.colno);\n                        if(/^\\s+$/.test(lastLine)) {\n                            // Remove block leading whitespace from beginning of the string\n                            tok = tok.slice(0, -this.colno);\n                            if(!tok.length) {\n                                // All data removed, collapse to avoid unnecessary nodes\n                                // by returning next token (block start)\n                                return this.nextToken();\n                            }\n                        }\n                    }\n                    // If it is a start tag, stop looping\n                    break;\n                }\n                else if(this._matches(this.tags.COMMENT_END)) {\n                    if(!in_comment) {\n                        throw new Error('unexpected end of comment');\n                    }\n                    tok += this._extractString(this.tags.COMMENT_END);\n                    break;\n                }\n                else {\n                    // It does not match any tag, so add the character and\n                    // carry on\n                    tok += this.current();\n                    this.forward();\n                }\n            }\n\n            if(data === null && in_comment) {\n                throw new Error('expected end of comment, got end of file');\n            }\n\n            return token(in_comment ? TOKEN_COMMENT : TOKEN_DATA,\n                         tok,\n                         lineno,\n                         colno);\n        }\n    }\n\n    throw new Error('Could not parse text');\n};\n\nTokenizer.prototype.parseString = function(delimiter) {\n    this.forward();\n\n    var str = '';\n\n    while(!this.is_finished() && this.current() !== delimiter) {\n        var cur = this.current();\n\n        if(cur === '\\\\') {\n            this.forward();\n            switch(this.current()) {\n            case 'n': str += '\\n'; break;\n            case 't': str += '\\t'; break;\n            case 'r': str += '\\r'; break;\n            default:\n                str += this.current();\n            }\n            this.forward();\n        }\n        else {\n            str += cur;\n            this.forward();\n        }\n    }\n\n    this.forward();\n    return str;\n};\n\nTokenizer.prototype._matches = function(str) {\n    if(this.index + str.length > this.len) {\n        return null;\n    }\n\n    var m = this.str.slice(this.index, this.index + str.length);\n    return m === str;\n};\n\nTokenizer.prototype._extractString = function(str) {\n    if(this._matches(str)) {\n        this.index += str.length;\n        return str;\n    }\n    return null;\n};\n\nTokenizer.prototype._extractUntil = function(charString) {\n    // Extract all non-matching chars, with the default matching set\n    // to everything\n    return this._extractMatching(true, charString || '');\n};\n\nTokenizer.prototype._extract = function(charString) {\n    // Extract all matching chars (no default, so charString must be\n    // explicit)\n    return this._extractMatching(false, charString);\n};\n\nTokenizer.prototype._extractMatching = function (breakOnMatch, charString) {\n    // Pull out characters until a breaking char is hit.\n    // If breakOnMatch is false, a non-matching char stops it.\n    // If breakOnMatch is true, a matching char stops it.\n\n    if(this.is_finished()) {\n        return null;\n    }\n\n    var first = charString.indexOf(this.current());\n\n    // Only proceed if the first character doesn't meet our condition\n    if((breakOnMatch && first === -1) ||\n       (!breakOnMatch && first !== -1)) {\n        var t = this.current();\n        this.forward();\n\n        // And pull out all the chars one at a time until we hit a\n        // breaking char\n        var idx = charString.indexOf(this.current());\n\n        while(((breakOnMatch && idx === -1) ||\n               (!breakOnMatch && idx !== -1)) && !this.is_finished()) {\n            t += this.current();\n            this.forward();\n\n            idx = charString.indexOf(this.current());\n        }\n\n        return t;\n    }\n\n    return '';\n};\n\nTokenizer.prototype._extractRegex = function(regex) {\n    var matches = this.currentStr().match(regex);\n    if(!matches) {\n        return null;\n    }\n\n    // Move forward whatever was matched\n    this.forwardN(matches[0].length);\n\n    return matches;\n};\n\nTokenizer.prototype.is_finished = function() {\n    return this.index >= this.len;\n};\n\nTokenizer.prototype.forwardN = function(n) {\n    for(var i=0; i<n; i++) {\n        this.forward();\n    }\n};\n\nTokenizer.prototype.forward = function() {\n    this.index++;\n\n    if(this.previous() === '\\n') {\n        this.lineno++;\n        this.colno = 0;\n    }\n    else {\n        this.colno++;\n    }\n};\n\nTokenizer.prototype.backN = function(n) {\n    for(var i=0; i<n; i++) {\n        this.back();\n    }\n};\n\nTokenizer.prototype.back = function() {\n    this.index--;\n\n    if(this.current() === '\\n') {\n        this.lineno--;\n\n        var idx = this.src.lastIndexOf('\\n', this.index-1);\n        if(idx === -1) {\n            this.colno = this.index;\n        }\n        else {\n            this.colno = this.index - idx;\n        }\n    }\n    else {\n        this.colno--;\n    }\n};\n\n// current returns current character\nTokenizer.prototype.current = function() {\n    if(!this.is_finished()) {\n        return this.str.charAt(this.index);\n    }\n    return '';\n};\n\n// currentStr returns what's left of the unparsed string\nTokenizer.prototype.currentStr = function() {\n    if(!this.is_finished()) {\n        return this.str.substr(this.index);\n    }\n    return '';\n};\n\nTokenizer.prototype.previous = function() {\n    return this.str.charAt(this.index-1);\n};\n\nmodule.exports = {\n    lex: function(src, opts) {\n        return new Tokenizer(src, opts);\n    },\n\n    TOKEN_STRING: TOKEN_STRING,\n    TOKEN_WHITESPACE: TOKEN_WHITESPACE,\n    TOKEN_DATA: TOKEN_DATA,\n    TOKEN_BLOCK_START: TOKEN_BLOCK_START,\n    TOKEN_BLOCK_END: TOKEN_BLOCK_END,\n    TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,\n    TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,\n    TOKEN_COMMENT: TOKEN_COMMENT,\n    TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,\n    TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,\n    TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,\n    TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,\n    TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,\n    TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,\n    TOKEN_OPERATOR: TOKEN_OPERATOR,\n    TOKEN_COMMA: TOKEN_COMMA,\n    TOKEN_COLON: TOKEN_COLON,\n    TOKEN_TILDE: TOKEN_TILDE,\n    TOKEN_PIPE: TOKEN_PIPE,\n    TOKEN_INT: TOKEN_INT,\n    TOKEN_FLOAT: TOKEN_FLOAT,\n    TOKEN_BOOLEAN: TOKEN_BOOLEAN,\n    TOKEN_NONE: TOKEN_NONE,\n    TOKEN_SYMBOL: TOKEN_SYMBOL,\n    TOKEN_SPECIAL: TOKEN_SPECIAL,\n    TOKEN_REGEX: TOKEN_REGEX\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/nodes.js":"'use strict';\n\nvar lib = require('./lib');\n// jshint -W079\nvar Object = require('./object');\n\nfunction traverseAndCheck(obj, type, results) {\n    if(obj instanceof type) {\n        results.push(obj);\n    }\n\n    if(obj instanceof Node) {\n        obj.findAll(type, results);\n    }\n}\n\nvar Node = Object.extend('Node', {\n    init: function(lineno, colno) {\n        this.lineno = lineno;\n        this.colno = colno;\n\n        var fields = this.fields;\n        for(var i = 0, l = fields.length; i < l; i++) {\n            var field = fields[i];\n\n            // The first two args are line/col numbers, so offset by 2\n            var val = arguments[i + 2];\n\n            // Fields should never be undefined, but null. It makes\n            // testing easier to normalize values.\n            if(val === undefined) {\n                val = null;\n            }\n\n            this[field] = val;\n        }\n    },\n\n    findAll: function(type, results) {\n        results = results || [];\n\n        var i, l;\n        if(this instanceof NodeList) {\n            var children = this.children;\n\n            for(i = 0, l = children.length; i < l; i++) {\n                traverseAndCheck(children[i], type, results);\n            }\n        }\n        else {\n            var fields = this.fields;\n\n            for(i = 0, l = fields.length; i < l; i++) {\n                traverseAndCheck(this[fields[i]], type, results);\n            }\n        }\n\n        return results;\n    },\n\n    iterFields: function(func) {\n        lib.each(this.fields, function(field) {\n            func(this[field], field);\n        }, this);\n    }\n});\n\n// Abstract nodes\nvar Value = Node.extend('Value', { fields: ['value'] });\n\n// Concrete nodes\nvar NodeList = Node.extend('NodeList', {\n    fields: ['children'],\n\n    init: function(lineno, colno, nodes) {\n        this.parent(lineno, colno, nodes || []);\n    },\n\n    addChild: function(node) {\n        this.children.push(node);\n    }\n});\n\nvar Root = NodeList.extend('Root');\nvar Literal = Value.extend('Literal');\nvar Symbol = Value.extend('Symbol');\nvar Group = NodeList.extend('Group');\nvar Array = NodeList.extend('Array');\nvar Pair = Node.extend('Pair', { fields: ['key', 'value'] });\nvar Dict = NodeList.extend('Dict');\nvar LookupVal = Node.extend('LookupVal', { fields: ['target', 'val'] });\nvar If = Node.extend('If', { fields: ['cond', 'body', 'else_'] });\nvar IfAsync = If.extend('IfAsync');\nvar InlineIf = Node.extend('InlineIf', { fields: ['cond', 'body', 'else_'] });\nvar For = Node.extend('For', { fields: ['arr', 'name', 'body', 'else_'] });\nvar AsyncEach = For.extend('AsyncEach');\nvar AsyncAll = For.extend('AsyncAll');\nvar Macro = Node.extend('Macro', { fields: ['name', 'args', 'body'] });\nvar Caller = Macro.extend('Caller');\nvar Import = Node.extend('Import', { fields: ['template', 'target', 'withContext'] });\nvar FromImport = Node.extend('FromImport', {\n    fields: ['template', 'names', 'withContext'],\n\n    init: function(lineno, colno, template, names, withContext) {\n        this.parent(lineno, colno,\n                    template,\n                    names || new NodeList(), withContext);\n    }\n});\nvar FunCall = Node.extend('FunCall', { fields: ['name', 'args'] });\nvar Filter = FunCall.extend('Filter');\nvar FilterAsync = Filter.extend('FilterAsync', {\n    fields: ['name', 'args', 'symbol']\n});\nvar KeywordArgs = Dict.extend('KeywordArgs');\nvar Block = Node.extend('Block', { fields: ['name', 'body'] });\nvar Super = Node.extend('Super', { fields: ['blockName', 'symbol'] });\nvar TemplateRef = Node.extend('TemplateRef', { fields: ['template'] });\nvar Extends = TemplateRef.extend('Extends');\nvar Include = Node.extend('Include', { fields: ['template', 'ignoreMissing'] });\nvar Set = Node.extend('Set', { fields: ['targets', 'value'] });\nvar Output = NodeList.extend('Output');\nvar Capture = Node.extend('Capture', { fields: ['body'] });\nvar TemplateData = Literal.extend('TemplateData');\nvar UnaryOp = Node.extend('UnaryOp', { fields: ['target'] });\nvar BinOp = Node.extend('BinOp', { fields: ['left', 'right'] });\nvar In = BinOp.extend('In');\nvar Or = BinOp.extend('Or');\nvar And = BinOp.extend('And');\nvar Not = UnaryOp.extend('Not');\nvar Add = BinOp.extend('Add');\nvar Concat = BinOp.extend('Concat');\nvar Sub = BinOp.extend('Sub');\nvar Mul = BinOp.extend('Mul');\nvar Div = BinOp.extend('Div');\nvar FloorDiv = BinOp.extend('FloorDiv');\nvar Mod = BinOp.extend('Mod');\nvar Pow = BinOp.extend('Pow');\nvar Neg = UnaryOp.extend('Neg');\nvar Pos = UnaryOp.extend('Pos');\nvar Compare = Node.extend('Compare', { fields: ['expr', 'ops'] });\nvar CompareOperand = Node.extend('CompareOperand', {\n    fields: ['expr', 'type']\n});\n\nvar CallExtension = Node.extend('CallExtension', {\n    fields: ['extName', 'prop', 'args', 'contentArgs'],\n\n    init: function(ext, prop, args, contentArgs) {\n        this.extName = ext._name || ext;\n        this.prop = prop;\n        this.args = args || new NodeList();\n        this.contentArgs = contentArgs || [];\n        this.autoescape = ext.autoescape;\n    }\n});\n\nvar CallExtensionAsync = CallExtension.extend('CallExtensionAsync');\n\n// Print the AST in a nicely formatted tree format for debuggin\nfunction printNodes(node, indent) {\n    indent = indent || 0;\n\n    // This is hacky, but this is just a debugging function anyway\n    function print(str, indent, inline) {\n        var lines = str.split('\\n');\n\n        for(var i=0; i<lines.length; i++) {\n            if(lines[i]) {\n                if((inline && i > 0) || !inline) {\n                    for(var j=0; j<indent; j++) {\n                        process.stdout.write(' ');\n                    }\n                }\n            }\n\n            if(i === lines.length-1) {\n                process.stdout.write(lines[i]);\n            }\n            else {\n                process.stdout.write(lines[i] + '\\n');\n            }\n        }\n    }\n\n    print(node.typename + ': ', indent);\n\n    if(node instanceof NodeList) {\n        print('\\n');\n        lib.each(node.children, function(n) {\n            printNodes(n, indent + 2);\n        });\n    }\n    else if(node instanceof CallExtension) {\n        print(node.extName + '.' + node.prop);\n        print('\\n');\n\n        if(node.args) {\n            printNodes(node.args, indent + 2);\n        }\n\n        if(node.contentArgs) {\n            lib.each(node.contentArgs, function(n) {\n                printNodes(n, indent + 2);\n            });\n        }\n    }\n    else {\n        var nodes = null;\n        var props = null;\n\n        node.iterFields(function(val, field) {\n            if(val instanceof Node) {\n                nodes = nodes || {};\n                nodes[field] = val;\n            }\n            else {\n                props = props || {};\n                props[field] = val;\n            }\n        });\n\n        if(props) {\n            print(JSON.stringify(props, null, 2) + '\\n', null, true);\n        }\n        else {\n            print('\\n');\n        }\n\n        if(nodes) {\n            for(var k in nodes) {\n                printNodes(nodes[k], indent + 2);\n            }\n        }\n\n    }\n}\n\n// var t = new NodeList(0, 0,\n//                      [new Value(0, 0, 3),\n//                       new Value(0, 0, 10),\n//                       new Pair(0, 0,\n//                                new Value(0, 0, 'key'),\n//                                new Value(0, 0, 'value'))]);\n// printNodes(t);\n\nmodule.exports = {\n    Node: Node,\n    Root: Root,\n    NodeList: NodeList,\n    Value: Value,\n    Literal: Literal,\n    Symbol: Symbol,\n    Group: Group,\n    Array: Array,\n    Pair: Pair,\n    Dict: Dict,\n    Output: Output,\n    Capture: Capture,\n    TemplateData: TemplateData,\n    If: If,\n    IfAsync: IfAsync,\n    InlineIf: InlineIf,\n    For: For,\n    AsyncEach: AsyncEach,\n    AsyncAll: AsyncAll,\n    Macro: Macro,\n    Caller: Caller,\n    Import: Import,\n    FromImport: FromImport,\n    FunCall: FunCall,\n    Filter: Filter,\n    FilterAsync: FilterAsync,\n    KeywordArgs: KeywordArgs,\n    Block: Block,\n    Super: Super,\n    Extends: Extends,\n    Include: Include,\n    Set: Set,\n    LookupVal: LookupVal,\n    BinOp: BinOp,\n    In: In,\n    Or: Or,\n    And: And,\n    Not: Not,\n    Add: Add,\n    Concat: Concat,\n    Sub: Sub,\n    Mul: Mul,\n    Div: Div,\n    FloorDiv: FloorDiv,\n    Mod: Mod,\n    Pow: Pow,\n    Neg: Neg,\n    Pos: Pos,\n    Compare: Compare,\n    CompareOperand: CompareOperand,\n\n    CallExtension: CallExtension,\n    CallExtensionAsync: CallExtensionAsync,\n\n    printNodes: printNodes\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/transformer.js":"'use strict';\n\nvar nodes = require('./nodes');\nvar lib = require('./lib');\n\nvar sym = 0;\nfunction gensym() {\n    return 'hole_' + sym++;\n}\n\n// copy-on-write version of map\nfunction mapCOW(arr, func) {\n    var res = null;\n\n    for(var i=0; i<arr.length; i++) {\n        var item = func(arr[i]);\n\n        if(item !== arr[i]) {\n            if(!res) {\n                res = arr.slice();\n            }\n\n            res[i] = item;\n        }\n    }\n\n    return res || arr;\n}\n\nfunction walk(ast, func, depthFirst) {\n    if(!(ast instanceof nodes.Node)) {\n        return ast;\n    }\n\n    if(!depthFirst) {\n        var astT = func(ast);\n\n        if(astT && astT !== ast) {\n            return astT;\n        }\n    }\n\n    if(ast instanceof nodes.NodeList) {\n        var children = mapCOW(ast.children, function(node) {\n            return walk(node, func, depthFirst);\n        });\n\n        if(children !== ast.children) {\n            ast = new nodes[ast.typename](ast.lineno, ast.colno, children);\n        }\n    }\n    else if(ast instanceof nodes.CallExtension) {\n        var args = walk(ast.args, func, depthFirst);\n\n        var contentArgs = mapCOW(ast.contentArgs, function(node) {\n            return walk(node, func, depthFirst);\n        });\n\n        if(args !== ast.args || contentArgs !== ast.contentArgs) {\n            ast = new nodes[ast.typename](ast.extName,\n                                          ast.prop,\n                                          args,\n                                          contentArgs);\n        }\n    }\n    else {\n        var props = ast.fields.map(function(field) {\n            return ast[field];\n        });\n\n        var propsT = mapCOW(props, function(prop) {\n            return walk(prop, func, depthFirst);\n        });\n\n        if(propsT !== props) {\n            ast = new nodes[ast.typename](ast.lineno, ast.colno);\n\n            propsT.forEach(function(prop, i) {\n                ast[ast.fields[i]] = prop;\n            });\n        }\n    }\n\n    return depthFirst ? (func(ast) || ast) : ast;\n}\n\nfunction depthWalk(ast, func) {\n    return walk(ast, func, true);\n}\n\nfunction _liftFilters(node, asyncFilters, prop) {\n    var children = [];\n\n    var walked = depthWalk(prop ? node[prop] : node, function(node) {\n        if(node instanceof nodes.Block) {\n            return node;\n        }\n        else if((node instanceof nodes.Filter &&\n                 lib.indexOf(asyncFilters, node.name.value) !== -1) ||\n                node instanceof nodes.CallExtensionAsync) {\n            var symbol = new nodes.Symbol(node.lineno,\n                                          node.colno,\n                                          gensym());\n\n            children.push(new nodes.FilterAsync(node.lineno,\n                                                node.colno,\n                                                node.name,\n                                                node.args,\n                                                symbol));\n            return symbol;\n        }\n    });\n\n    if(prop) {\n        node[prop] = walked;\n    }\n    else {\n        node = walked;\n    }\n\n    if(children.length) {\n        children.push(node);\n\n        return new nodes.NodeList(\n            node.lineno,\n            node.colno,\n            children\n        );\n    }\n    else {\n        return node;\n    }\n}\n\nfunction liftFilters(ast, asyncFilters) {\n    return depthWalk(ast, function(node) {\n        if(node instanceof nodes.Output) {\n            return _liftFilters(node, asyncFilters);\n        }\n        else if(node instanceof nodes.Set) {\n            return _liftFilters(node, asyncFilters, 'value');\n        }\n        else if(node instanceof nodes.For) {\n            return _liftFilters(node, asyncFilters, 'arr');\n        }\n        else if(node instanceof nodes.If) {\n            return _liftFilters(node, asyncFilters, 'cond');\n        }\n        else if(node instanceof nodes.CallExtension) {\n            return _liftFilters(node, asyncFilters, 'args');\n        }\n    });\n}\n\nfunction liftSuper(ast) {\n    return walk(ast, function(blockNode) {\n        if(!(blockNode instanceof nodes.Block)) {\n            return;\n        }\n\n        var hasSuper = false;\n        var symbol = gensym();\n\n        blockNode.body = walk(blockNode.body, function(node) {\n            if(node instanceof nodes.FunCall &&\n               node.name.value === 'super') {\n                hasSuper = true;\n                return new nodes.Symbol(node.lineno, node.colno, symbol);\n            }\n        });\n\n        if(hasSuper) {\n            blockNode.body.children.unshift(new nodes.Super(\n                0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)\n            ));\n        }\n    });\n}\n\nfunction convertStatements(ast) {\n    return depthWalk(ast, function(node) {\n        if(!(node instanceof nodes.If) &&\n           !(node instanceof nodes.For)) {\n            return;\n        }\n\n        var async = false;\n        walk(node, function(node) {\n            if(node instanceof nodes.FilterAsync ||\n               node instanceof nodes.IfAsync ||\n               node instanceof nodes.AsyncEach ||\n               node instanceof nodes.AsyncAll ||\n               node instanceof nodes.CallExtensionAsync) {\n                async = true;\n                // Stop iterating by returning the node\n                return node;\n            }\n        });\n\n        if(async) {\n\t        if(node instanceof nodes.If) {\n                return new nodes.IfAsync(\n                    node.lineno,\n                    node.colno,\n                    node.cond,\n                    node.body,\n                    node.else_\n                );\n            }\n            else if(node instanceof nodes.For) {\n                return new nodes.AsyncEach(\n                    node.lineno,\n                    node.colno,\n                    node.arr,\n                    node.name,\n                    node.body,\n                    node.else_\n                );\n            }\n        }\n    });\n}\n\nfunction cps(ast, asyncFilters) {\n    return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));\n}\n\nfunction transform(ast, asyncFilters) {\n    return cps(ast, asyncFilters || []);\n}\n\n// var parser = require('./parser');\n// var src = 'hello {% foo %}{% endfoo %} end';\n// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);\n// nodes.printNodes(ast);\n\nmodule.exports = {\n    transform: transform\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/runtime.js":"'use strict';\n\nvar lib = require('./lib');\nvar Obj = require('./object');\n\n// Frames keep track of scoping both at compile-time and run-time so\n// we know how to access variables. Block tags can introduce special\n// variables, for example.\nvar Frame = Obj.extend({\n    init: function(parent, isolateWrites) {\n        this.variables = {};\n        this.parent = parent;\n        this.topLevel = false;\n        // if this is true, writes (set) should never propagate upwards past\n        // this frame to its parent (though reads may).\n        this.isolateWrites = isolateWrites;\n    },\n\n    set: function(name, val, resolveUp) {\n        // Allow variables with dots by automatically creating the\n        // nested structure\n        var parts = name.split('.');\n        var obj = this.variables;\n        var frame = this;\n\n        if(resolveUp) {\n            if((frame = this.resolve(parts[0], true))) {\n                frame.set(name, val);\n                return;\n            }\n        }\n\n        for(var i=0; i<parts.length - 1; i++) {\n            var id = parts[i];\n\n            if(!obj[id]) {\n                obj[id] = {};\n            }\n            obj = obj[id];\n        }\n\n        obj[parts[parts.length - 1]] = val;\n    },\n\n    get: function(name) {\n        var val = this.variables[name];\n        if(val !== undefined) {\n            return val;\n        }\n        return null;\n    },\n\n    lookup: function(name) {\n        var p = this.parent;\n        var val = this.variables[name];\n        if(val !== undefined) {\n            return val;\n        }\n        return p && p.lookup(name);\n    },\n\n    resolve: function(name, forWrite) {\n        var p = (forWrite && this.isolateWrites) ? undefined : this.parent;\n        var val = this.variables[name];\n        if(val !== undefined) {\n            return this;\n        }\n        return p && p.resolve(name);\n    },\n\n    push: function(isolateWrites) {\n        return new Frame(this, isolateWrites);\n    },\n\n    pop: function() {\n        return this.parent;\n    }\n});\n\nfunction makeMacro(argNames, kwargNames, func) {\n    return function() {\n        var argCount = numArgs(arguments);\n        var args;\n        var kwargs = getKeywordArgs(arguments);\n        var i;\n\n        if(argCount > argNames.length) {\n            args = Array.prototype.slice.call(arguments, 0, argNames.length);\n\n            // Positional arguments that should be passed in as\n            // keyword arguments (essentially default values)\n            var vals = Array.prototype.slice.call(arguments, args.length, argCount);\n            for(i = 0; i < vals.length; i++) {\n                if(i < kwargNames.length) {\n                    kwargs[kwargNames[i]] = vals[i];\n                }\n            }\n\n            args.push(kwargs);\n        }\n        else if(argCount < argNames.length) {\n            args = Array.prototype.slice.call(arguments, 0, argCount);\n\n            for(i = argCount; i < argNames.length; i++) {\n                var arg = argNames[i];\n\n                // Keyword arguments that should be passed as\n                // positional arguments, i.e. the caller explicitly\n                // used the name of a positional arg\n                args.push(kwargs[arg]);\n                delete kwargs[arg];\n            }\n\n            args.push(kwargs);\n        }\n        else {\n            args = arguments;\n        }\n\n        return func.apply(this, args);\n    };\n}\n\nfunction makeKeywordArgs(obj) {\n    obj.__keywords = true;\n    return obj;\n}\n\nfunction getKeywordArgs(args) {\n    var len = args.length;\n    if(len) {\n        var lastArg = args[len - 1];\n        if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n            return lastArg;\n        }\n    }\n    return {};\n}\n\nfunction numArgs(args) {\n    var len = args.length;\n    if(len === 0) {\n        return 0;\n    }\n\n    var lastArg = args[len - 1];\n    if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n        return len - 1;\n    }\n    else {\n        return len;\n    }\n}\n\n// A SafeString object indicates that the string should not be\n// autoescaped. This happens magically because autoescaping only\n// occurs on primitive string objects.\nfunction SafeString(val) {\n    if(typeof val !== 'string') {\n        return val;\n    }\n\n    this.val = val;\n    this.length = val.length;\n}\n\nSafeString.prototype = Object.create(String.prototype, {\n    length: { writable: true, configurable: true, value: 0 }\n});\nSafeString.prototype.valueOf = function() {\n    return this.val;\n};\nSafeString.prototype.toString = function() {\n    return this.val;\n};\n\nfunction copySafeness(dest, target) {\n    if(dest instanceof SafeString) {\n        return new SafeString(target);\n    }\n    return target.toString();\n}\n\nfunction markSafe(val) {\n    var type = typeof val;\n\n    if(type === 'string') {\n        return new SafeString(val);\n    }\n    else if(type !== 'function') {\n        return val;\n    }\n    else {\n        return function() {\n            var ret = val.apply(this, arguments);\n\n            if(typeof ret === 'string') {\n                return new SafeString(ret);\n            }\n\n            return ret;\n        };\n    }\n}\n\nfunction suppressValue(val, autoescape) {\n    val = (val !== undefined && val !== null) ? val : '';\n\n    if(autoescape && !(val instanceof SafeString)) {\n        val = lib.escape(val.toString());\n    }\n\n    return val;\n}\n\nfunction ensureDefined(val, lineno, colno) {\n    if(val === null || val === undefined) {\n        throw new lib.TemplateError(\n            'attempted to output null or undefined value',\n            lineno + 1,\n            colno + 1\n        );\n    }\n    return val;\n}\n\nfunction memberLookup(obj, val) {\n    obj = obj || {};\n\n    if(typeof obj[val] === 'function') {\n        return function() {\n            return obj[val].apply(obj, arguments);\n        };\n    }\n\n    return obj[val];\n}\n\nfunction callWrap(obj, name, context, args) {\n    if(!obj) {\n        throw new Error('Unable to call `' + name + '`, which is undefined or falsey');\n    }\n    else if(typeof obj !== 'function') {\n        throw new Error('Unable to call `' + name + '`, which is not a function');\n    }\n\n    // jshint validthis: true\n    return obj.apply(context, args);\n}\n\nfunction contextOrFrameLookup(context, frame, name) {\n    var val = frame.lookup(name);\n    return (val !== undefined) ?\n        val :\n        context.lookup(name);\n}\n\nfunction handleError(error, lineno, colno) {\n    if(error.lineno) {\n        return error;\n    }\n    else {\n        return new lib.TemplateError(error, lineno, colno);\n    }\n}\n\nfunction asyncEach(arr, dimen, iter, cb) {\n    if(lib.isArray(arr)) {\n        var len = arr.length;\n\n        lib.asyncIter(arr, function(item, i, next) {\n            switch(dimen) {\n            case 1: iter(item, i, len, next); break;\n            case 2: iter(item[0], item[1], i, len, next); break;\n            case 3: iter(item[0], item[1], item[2], i, len, next); break;\n            default:\n                item.push(i, next);\n                iter.apply(this, item);\n            }\n        }, cb);\n    }\n    else {\n        lib.asyncFor(arr, function(key, val, i, len, next) {\n            iter(key, val, i, len, next);\n        }, cb);\n    }\n}\n\nfunction asyncAll(arr, dimen, func, cb) {\n    var finished = 0;\n    var len, i;\n    var outputArr;\n\n    function done(i, output) {\n        finished++;\n        outputArr[i] = output;\n\n        if(finished === len) {\n            cb(null, outputArr.join(''));\n        }\n    }\n\n    if(lib.isArray(arr)) {\n        len = arr.length;\n        outputArr = new Array(len);\n\n        if(len === 0) {\n            cb(null, '');\n        }\n        else {\n            for(i = 0; i < arr.length; i++) {\n                var item = arr[i];\n\n                switch(dimen) {\n                case 1: func(item, i, len, done); break;\n                case 2: func(item[0], item[1], i, len, done); break;\n                case 3: func(item[0], item[1], item[2], i, len, done); break;\n                default:\n                    item.push(i, done);\n                    // jshint validthis: true\n                    func.apply(this, item);\n                }\n            }\n        }\n    }\n    else {\n        var keys = lib.keys(arr);\n        len = keys.length;\n        outputArr = new Array(len);\n\n        if(len === 0) {\n            cb(null, '');\n        }\n        else {\n            for(i = 0; i < keys.length; i++) {\n                var k = keys[i];\n                func(k, arr[k], i, len, done);\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    Frame: Frame,\n    makeMacro: makeMacro,\n    makeKeywordArgs: makeKeywordArgs,\n    numArgs: numArgs,\n    suppressValue: suppressValue,\n    ensureDefined: ensureDefined,\n    memberLookup: memberLookup,\n    contextOrFrameLookup: contextOrFrameLookup,\n    callWrap: callWrap,\n    handleError: handleError,\n    isArray: lib.isArray,\n    keys: lib.keys,\n    SafeString: SafeString,\n    copySafeness: copySafeness,\n    markSafe: markSafe,\n    asyncEach: asyncEach,\n    asyncAll: asyncAll,\n    inOperator: lib.inOperator\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/filters.js":"'use strict';\n\nvar lib = require('./lib');\nvar r = require('./runtime');\n\nfunction normalize(value, defaultValue) {\n    if(value === null || value === undefined || value === false) {\n        return defaultValue;\n    }\n    return value;\n}\n\nvar filters = {\n    abs: function(n) {\n        return Math.abs(n);\n    },\n\n    batch: function(arr, linecount, fill_with) {\n        var i;\n        var res = [];\n        var tmp = [];\n\n        for(i = 0; i < arr.length; i++) {\n            if(i % linecount === 0 && tmp.length) {\n                res.push(tmp);\n                tmp = [];\n            }\n\n            tmp.push(arr[i]);\n        }\n\n        if(tmp.length) {\n            if(fill_with) {\n                for(i = tmp.length; i < linecount; i++) {\n                    tmp.push(fill_with);\n                }\n            }\n\n            res.push(tmp);\n        }\n\n        return res;\n    },\n\n    capitalize: function(str) {\n        str = normalize(str, '');\n        var ret = str.toLowerCase();\n        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));\n    },\n\n    center: function(str, width) {\n        str = normalize(str, '');\n        width = width || 80;\n\n        if(str.length >= width) {\n            return str;\n        }\n\n        var spaces = width - str.length;\n        var pre = lib.repeat(' ', spaces/2 - spaces % 2);\n        var post = lib.repeat(' ', spaces/2);\n        return r.copySafeness(str, pre + str + post);\n    },\n\n    'default': function(val, def, bool) {\n        if(bool) {\n            return val ? val : def;\n        }\n        else {\n            return (val !== undefined) ? val : def;\n        }\n    },\n\n    dictsort: function(val, case_sensitive, by) {\n        if (!lib.isObject(val)) {\n            throw new lib.TemplateError('dictsort filter: val must be an object');\n        }\n\n        var array = [];\n        for (var k in val) {\n            // deliberately include properties from the object's prototype\n            array.push([k,val[k]]);\n        }\n\n        var si;\n        if (by === undefined || by === 'key') {\n            si = 0;\n        } else if (by === 'value') {\n            si = 1;\n        } else {\n            throw new lib.TemplateError(\n                'dictsort filter: You can only sort by either key or value');\n        }\n\n        array.sort(function(t1, t2) {\n            var a = t1[si];\n            var b = t2[si];\n\n            if (!case_sensitive) {\n                if (lib.isString(a)) {\n                    a = a.toUpperCase();\n                }\n                if (lib.isString(b)) {\n                    b = b.toUpperCase();\n                }\n            }\n\n            return a > b ? 1 : (a === b ? 0 : -1);\n        });\n\n        return array;\n    },\n\n    dump: function(obj, spaces) {\n        return JSON.stringify(obj, null, spaces);\n    },\n\n    escape: function(str) {\n        if(str instanceof r.SafeString) {\n            return str;\n        }\n        str = (str === null || str === undefined) ? '' : str;\n        return r.markSafe(lib.escape(str.toString()));\n    },\n\n    safe: function(str) {\n        if (str instanceof r.SafeString) {\n            return str;\n        }\n        str = (str === null || str === undefined) ? '' : str;\n        return r.markSafe(str.toString());\n    },\n\n    first: function(arr) {\n        return arr[0];\n    },\n\n    groupby: function(arr, attr) {\n        return lib.groupBy(arr, attr);\n    },\n\n    indent: function(str, width, indentfirst) {\n        str = normalize(str, '');\n\n        if (str === '') return '';\n\n        width = width || 4;\n        var res = '';\n        var lines = str.split('\\n');\n        var sp = lib.repeat(' ', width);\n\n        for(var i=0; i<lines.length; i++) {\n            if(i === 0 && !indentfirst) {\n                res += lines[i] + '\\n';\n            }\n            else {\n                res += sp + lines[i] + '\\n';\n            }\n        }\n\n        return r.copySafeness(str, res);\n    },\n\n    join: function(arr, del, attr) {\n        del = del || '';\n\n        if(attr) {\n            arr = lib.map(arr, function(v) {\n                return v[attr];\n            });\n        }\n\n        return arr.join(del);\n    },\n\n    last: function(arr) {\n        return arr[arr.length-1];\n    },\n\n    length: function(val) {\n        var value = normalize(val, '');\n\n        if(value !== undefined) {\n            if(\n                (typeof Map === 'function' && value instanceof Map) ||\n                (typeof Set === 'function' && value instanceof Set)\n            ) {\n                // ECMAScript 2015 Maps and Sets\n                return value.size;\n            }\n            if(lib.isObject(value) && !(value instanceof r.SafeString)) {\n                // Objects (besides SafeStrings), non-primative Arrays\n                return Object.keys(value).length;\n            }\n            return value.length;\n        }\n        return 0;\n    },\n\n    list: function(val) {\n        if(lib.isString(val)) {\n            return val.split('');\n        }\n        else if(lib.isObject(val)) {\n            var keys = [];\n\n            if(Object.keys) {\n                keys = Object.keys(val);\n            }\n            else {\n                for(var k in val) {\n                    keys.push(k);\n                }\n            }\n\n            return lib.map(keys, function(k) {\n                return { key: k,\n                         value: val[k] };\n            });\n        }\n        else if(lib.isArray(val)) {\n          return val;\n        }\n        else {\n            throw new lib.TemplateError('list filter: type not iterable');\n        }\n    },\n\n    lower: function(str) {\n        str = normalize(str, '');\n        return str.toLowerCase();\n    },\n\n    nl2br: function(str) {\n        if (str === null || str === undefined) {\n            return '';\n        }\n        return r.copySafeness(str, str.replace(/\\r\\n|\\n/g, '<br />\\n'));\n    },\n\n    random: function(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    },\n\n    rejectattr: function(arr, attr) {\n      return arr.filter(function (item) {\n        return !item[attr];\n      });\n    },\n\n    selectattr: function(arr, attr) {\n      return arr.filter(function (item) {\n        return !!item[attr];\n      });\n    },\n\n    replace: function(str, old, new_, maxCount) {\n        var originalStr = str;\n\n        if (old instanceof RegExp) {\n            return str.replace(old, new_);\n        }\n\n        if(typeof maxCount === 'undefined'){\n            maxCount = -1;\n        }\n\n        var res = '';  // Output\n\n        // Cast Numbers in the search term to string\n        if(typeof old === 'number'){\n            old = old + '';\n        }\n        else if(typeof old !== 'string') {\n            // If it is something other than number or string,\n            // return the original string\n            return str;\n        }\n\n        // Cast numbers in the replacement to string\n        if(typeof str === 'number'){\n            str = str + '';\n        }\n\n        // If by now, we don't have a string, throw it back\n        if(typeof str !== 'string' && !(str instanceof r.SafeString)){\n            return str;\n        }\n\n        // ShortCircuits\n        if(old === ''){\n            // Mimic the python behaviour: empty string is replaced\n            // by replacement e.g. \"abc\"|replace(\"\", \".\") -> .a.b.c.\n            res = new_ + str.split('').join(new_) + new_;\n            return r.copySafeness(str, res);\n        }\n\n        var nextIndex = str.indexOf(old);\n        // if # of replacements to perform is 0, or the string to does\n        // not contain the old value, return the string\n        if(maxCount === 0 || nextIndex === -1){\n            return str;\n        }\n\n        var pos = 0;\n        var count = 0; // # of replacements made\n\n        while(nextIndex  > -1 && (maxCount === -1 || count < maxCount)){\n            // Grab the next chunk of src string and add it with the\n            // replacement, to the result\n            res += str.substring(pos, nextIndex) + new_;\n            // Increment our pointer in the src string\n            pos = nextIndex + old.length;\n            count++;\n            // See if there are any more replacements to be made\n            nextIndex = str.indexOf(old, pos);\n        }\n\n        // We've either reached the end, or done the max # of\n        // replacements, tack on any remaining string\n        if(pos < str.length) {\n            res += str.substring(pos);\n        }\n\n        return r.copySafeness(originalStr, res);\n    },\n\n    reverse: function(val) {\n        var arr;\n        if(lib.isString(val)) {\n            arr = filters.list(val);\n        }\n        else {\n            // Copy it\n            arr = lib.map(val, function(v) { return v; });\n        }\n\n        arr.reverse();\n\n        if(lib.isString(val)) {\n            return r.copySafeness(val, arr.join(''));\n        }\n        return arr;\n    },\n\n    round: function(val, precision, method) {\n        precision = precision || 0;\n        var factor = Math.pow(10, precision);\n        var rounder;\n\n        if(method === 'ceil') {\n            rounder = Math.ceil;\n        }\n        else if(method === 'floor') {\n            rounder = Math.floor;\n        }\n        else {\n            rounder = Math.round;\n        }\n\n        return rounder(val * factor) / factor;\n    },\n\n    slice: function(arr, slices, fillWith) {\n        var sliceLength = Math.floor(arr.length / slices);\n        var extra = arr.length % slices;\n        var offset = 0;\n        var res = [];\n\n        for(var i=0; i<slices; i++) {\n            var start = offset + i * sliceLength;\n            if(i < extra) {\n                offset++;\n            }\n            var end = offset + (i + 1) * sliceLength;\n\n            var slice = arr.slice(start, end);\n            if(fillWith && i >= extra) {\n                slice.push(fillWith);\n            }\n            res.push(slice);\n        }\n\n        return res;\n    },\n\n    sum: function(arr, attr, start) {\n        var sum = 0;\n\n        if(typeof start === 'number'){\n            sum += start;\n        }\n\n        if(attr) {\n            arr = lib.map(arr, function(v) {\n                return v[attr];\n            });\n        }\n\n        for(var i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n\n        return sum;\n    },\n\n    sort: r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function(arr, reverse, caseSens, attr) {\n         // Copy it\n        arr = lib.map(arr, function(v) { return v; });\n\n        arr.sort(function(a, b) {\n            var x, y;\n\n            if(attr) {\n                x = a[attr];\n                y = b[attr];\n            }\n            else {\n                x = a;\n                y = b;\n            }\n\n            if(!caseSens && lib.isString(x) && lib.isString(y)) {\n                x = x.toLowerCase();\n                y = y.toLowerCase();\n            }\n\n            if(x < y) {\n                return reverse ? 1 : -1;\n            }\n            else if(x > y) {\n                return reverse ? -1: 1;\n            }\n            else {\n                return 0;\n            }\n        });\n\n        return arr;\n    }),\n\n    string: function(obj) {\n        return r.copySafeness(obj, obj);\n    },\n\n    striptags: function(input, preserve_linebreaks) {\n        input = normalize(input, '');\n        preserve_linebreaks = preserve_linebreaks || false;\n        var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>|<!--[\\s\\S]*?-->/gi;\n        var trimmedInput = filters.trim(input.replace(tags, ''));\n        var res = '';\n        if (preserve_linebreaks) {\n            res = trimmedInput\n                .replace(/^ +| +$/gm, '')     // remove leading and trailing spaces\n                .replace(/ +/g, ' ')          // squash adjacent spaces\n                .replace(/(\\r\\n)/g, '\\n')     // normalize linebreaks (CRLF -> LF)\n                .replace(/\\n\\n\\n+/g, '\\n\\n'); // squash abnormal adjacent linebreaks\n        } else {\n            res = trimmedInput.replace(/\\s+/gi, ' ');\n        }\n        return r.copySafeness(input, res);\n    },\n\n    title: function(str) {\n        str = normalize(str, '');\n        var words = str.split(' ');\n        for(var i = 0; i < words.length; i++) {\n            words[i] = filters.capitalize(words[i]);\n        }\n        return r.copySafeness(str, words.join(' '));\n    },\n\n    trim: function(str) {\n        return r.copySafeness(str, str.replace(/^\\s*|\\s*$/g, ''));\n    },\n\n    truncate: function(input, length, killwords, end) {\n        var orig = input;\n        input = normalize(input, '');\n        length = length || 255;\n\n        if (input.length <= length)\n            return input;\n\n        if (killwords) {\n            input = input.substring(0, length);\n        } else {\n            var idx = input.lastIndexOf(' ', length);\n            if(idx === -1) {\n                idx = length;\n            }\n\n            input = input.substring(0, idx);\n        }\n\n        input += (end !== undefined && end !== null) ? end : '...';\n        return r.copySafeness(orig, input);\n    },\n\n    upper: function(str) {\n        str = normalize(str, '');\n        return str.toUpperCase();\n    },\n\n    urlencode: function(obj) {\n        var enc = encodeURIComponent;\n        if (lib.isString(obj)) {\n            return enc(obj);\n        } else {\n            var parts;\n            if (lib.isArray(obj)) {\n                parts = obj.map(function(item) {\n                    return enc(item[0]) + '=' + enc(item[1]);\n                });\n            } else {\n                parts = [];\n                for (var k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        parts.push(enc(k) + '=' + enc(obj[k]));\n                    }\n                }\n            }\n            return parts.join('&');\n        }\n    },\n\n    urlize: function(str, length, nofollow) {\n        if (isNaN(length)) length = Infinity;\n\n        var noFollowAttr = (nofollow === true ? ' rel=\"nofollow\"' : '');\n\n        // For the jinja regexp, see\n        // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23\n        var puncRE = /^(?:\\(|<|&lt;)?(.*?)(?:\\.|,|\\)|\\n|&gt;)?$/;\n        // from http://blog.gerv.net/2011/05/html5_email_address_regexp/\n        var emailRE = /^[\\w.!#$%&'*+\\-\\/=?\\^`{|}~]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)+$/i;\n        var httpHttpsRE = /^https?:\\/\\/.*$/;\n        var wwwRE = /^www\\./;\n        var tldRE = /\\.(?:org|net|com)(?:\\:|\\/|$)/;\n\n        var words = str.split(/(\\s+)/).filter(function(word) {\n          // If the word has no length, bail. This can happen for str with\n          // trailing whitespace.\n          return word && word.length;\n        }).map(function(word) {\n          var matches = word.match(puncRE);\n          var possibleUrl = matches && matches[1] || word;\n\n          // url that starts with http or https\n          if (httpHttpsRE.test(possibleUrl))\n            return '<a href=\"' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n          // url that starts with www.\n          if (wwwRE.test(possibleUrl))\n            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n          // an email address of the form username@domain.tld\n          if (emailRE.test(possibleUrl))\n            return '<a href=\"mailto:' + possibleUrl + '\">' + possibleUrl + '</a>';\n\n          // url that ends in .com, .org or .net that is not an email address\n          if (tldRE.test(possibleUrl))\n            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n          return word;\n\n        });\n\n        return words.join('');\n    },\n\n    wordcount: function(str) {\n        str = normalize(str, '');\n        var words = (str) ? str.match(/\\w+/g) : null;\n        return (words) ? words.length : null;\n    },\n\n    'float': function(val, def) {\n        var res = parseFloat(val);\n        return isNaN(res) ? def : res;\n    },\n\n    'int': function(val, def) {\n        var res = parseInt(val, 10);\n        return isNaN(res) ? def : res;\n    }\n};\n\n// Aliases\nfilters.d = filters['default'];\nfilters.e = filters.escape;\n\nmodule.exports = filters;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/loaders.js":"// This file will automatically be rewired to web-loader.js when\n// building for the browser\nmodule.exports = require('./node-loaders');\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/node-loaders.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar lib = require('./lib');\nvar Loader = require('./loader');\nvar PrecompiledLoader = require('./precompiled-loader.js');\n\n// Node <0.7.1 compatibility\nvar existsSync = fs.existsSync || path.existsSync;\n\nvar FileSystemLoader = Loader.extend({\n    init: function(searchPaths, opts) {\n        if(typeof opts === 'boolean') {\n            console.log(\n                '[nunjucks] Warning: you passed a boolean as the second ' +\n                'argument to FileSystemLoader, but it now takes an options ' +\n                'object. See http://mozilla.github.io/nunjucks/api.html#filesystemloader'\n            );\n        }\n\n        opts = opts || {};\n        this.pathsToNames = {};\n        this.noCache = !!opts.noCache;\n\n        if(searchPaths) {\n            searchPaths = lib.isArray(searchPaths) ? searchPaths : [searchPaths];\n            // For windows, convert to forward slashes\n            this.searchPaths = searchPaths.map(path.normalize);\n        }\n        else {\n            this.searchPaths = ['.'];\n        }\n\n        if(opts.watch) {\n            // Watch all the templates in the paths and fire an event when\n            // they change\n            var chokidar = require('chokidar');\n            var paths = this.searchPaths.filter(function(p) { return existsSync(p); });\n            var watcher = chokidar.watch(paths);\n            var _this = this;\n            watcher.on('all', function(event, fullname) {\n                fullname = path.resolve(fullname);\n                if(event === 'change' && fullname in _this.pathsToNames) {\n                    _this.emit('update', _this.pathsToNames[fullname]);\n                }\n            });\n            watcher.on('error', function(error) {\n                console.log('Watcher error: ' + error);\n            });\n        }\n    },\n\n    getSource: function(name) {\n        var fullpath = null;\n        var paths = this.searchPaths;\n\n        for(var i=0; i<paths.length; i++) {\n            var basePath = path.resolve(paths[i]);\n            var p = path.resolve(paths[i], name);\n\n            // Only allow the current directory and anything\n            // underneath it to be searched\n            if(p.indexOf(basePath) === 0 && existsSync(p)) {\n                fullpath = p;\n                break;\n            }\n        }\n\n        if(!fullpath) {\n            return null;\n        }\n\n        this.pathsToNames[fullpath] = name;\n\n        return { src: fs.readFileSync(fullpath, 'utf-8'),\n                 path: fullpath,\n                 noCache: this.noCache };\n    }\n});\n\nmodule.exports = {\n    FileSystemLoader: FileSystemLoader,\n    PrecompiledLoader: PrecompiledLoader\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/loader.js":"'use strict';\n\nvar path = require('path');\nvar Obj = require('./object');\nvar lib = require('./lib');\n\nvar Loader = Obj.extend({\n    on: function(name, func) {\n        this.listeners = this.listeners || {};\n        this.listeners[name] = this.listeners[name] || [];\n        this.listeners[name].push(func);\n    },\n\n    emit: function(name /*, arg1, arg2, ...*/) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        if(this.listeners && this.listeners[name]) {\n            lib.each(this.listeners[name], function(listener) {\n                listener.apply(null, args);\n            });\n        }\n    },\n\n    resolve: function(from, to) {\n        return path.resolve(path.dirname(from), to);\n    },\n\n    isRelative: function(filename) {\n        return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);\n    }\n});\n\nmodule.exports = Loader;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/precompiled-loader.js":"'use strict';\n\nvar Loader = require('./loader');\n\nvar PrecompiledLoader = Loader.extend({\n    init: function(compiledTemplates) {\n        this.precompiled = compiledTemplates || {};\n    },\n\n    getSource: function(name) {\n        if (this.precompiled[name]) {\n            return {\n                src: { type: 'code',\n                       obj: this.precompiled[name] },\n                path: name\n            };\n        }\n        return null;\n    }\n});\n\nmodule.exports = PrecompiledLoader;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/globals.js":"'use strict';\n\nfunction cycler(items) {\n    var index = -1;\n\n    return {\n        current: null,\n        reset: function() {\n            index = -1;\n            this.current = null;\n        },\n\n        next: function() {\n            index++;\n            if(index >= items.length) {\n                index = 0;\n            }\n\n            this.current = items[index];\n            return this.current;\n        },\n    };\n\n}\n\nfunction joiner(sep) {\n    sep = sep || ',';\n    var first = true;\n\n    return function() {\n        var val = first ? '' : sep;\n        first = false;\n        return val;\n    };\n}\n\n// Making this a function instead so it returns a new object\n// each time it's called. That way, if something like an environment\n// uses it, they will each have their own copy.\nfunction globals() {\n    return {\n        range: function(start, stop, step) {\n            if(typeof stop === 'undefined') {\n                stop = start;\n                start = 0;\n                step = 1;\n            }\n            else if(!step) {\n                step = 1;\n            }\n\n            var arr = [];\n            var i;\n            if (step > 0) {\n                for (i=start; i<stop; i+=step) {\n                    arr.push(i);\n                }\n            } else {\n                for (i=start; i>stop; i+=step) {\n                    arr.push(i);\n                }\n            }\n            return arr;\n        },\n\n        // lipsum: function(n, html, min, max) {\n        // },\n\n        cycler: function() {\n            return cycler(Array.prototype.slice.call(arguments));\n        },\n\n        joiner: function(sep) {\n            return joiner(sep);\n        }\n    };\n}\n\nmodule.exports = globals;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/precompile.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar lib = require('./lib');\nvar compiler = require('./compiler');\nvar Environment = require('./environment').Environment;\nvar precompileGlobal = require('./precompile-global');\n\nfunction match(filename, patterns) {\n    if (!Array.isArray(patterns)) return false;\n    return patterns.some(function (pattern) {\n        return filename.match(pattern) !== null;\n    });\n}\n\nfunction precompileString(str, opts) {\n    opts = opts || {};\n    opts.isString = true;\n    return precompile(str, opts);\n}\n\nfunction precompile(input, opts) {\n    // The following options are available:\n    //\n    // * name: name of the template (auto-generated when compiling a directory)\n    // * isString: input is a string, not a file path\n    // * asFunction: generate a callable function\n    // * force: keep compiling on error\n    // * env: the Environment to use (gets extensions and async filters from it)\n    // * include: which file/folders to include (folders are auto-included, files are auto-excluded)\n    // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)\n    // * wrapper: function(templates, opts) {...}\n    //       Customize the output format to store the compiled template.\n    //       By default, templates are stored in a global variable used by the runtime.\n    //       A custom loader will be necessary to load your custom wrapper.\n\n    opts = opts || {};\n    var env = opts.env || new Environment([]);\n    var wrapper = opts.wrapper || precompileGlobal;\n\n    var pathStats = fs.existsSync(input) && fs.statSync(input);\n    var precompiled = [];\n    var templates = [];\n\n    function addTemplates(dir) {\n        var files = fs.readdirSync(dir);\n\n        for(var i=0; i<files.length; i++) {\n            var filepath = path.join(dir, files[i]);\n            var subpath = filepath.substr(path.join(input, '/').length);\n            var stat = fs.statSync(filepath);\n\n            if(stat && stat.isDirectory()) {\n                subpath += '/';\n                if (!match(subpath, opts.exclude)) {\n                    addTemplates(filepath);\n                }\n            }\n            else if(match(subpath, opts.include)) {\n                templates.push(filepath);\n            }\n        }\n    }\n\n    if(opts.isString) {\n        if(!opts.name) {\n            throw new Error('the \"name\" option is required when ' +\n                            'compiling a string');\n        }\n\n        precompiled.push( _precompile(\n            input,\n            opts.name,\n            env\n        ) );\n    }\n    else if(pathStats.isFile()) {\n        precompiled.push( _precompile(\n            fs.readFileSync(input, 'utf-8'),\n            opts.name || input,\n            env\n        ) );\n    }\n    else if(pathStats.isDirectory()) {\n        addTemplates(input);\n\n        for(var i=0; i<templates.length; i++) {\n            var name = templates[i].replace(path.join(input, '/'), '');\n\n            try {\n                precompiled.push( _precompile(\n                    fs.readFileSync(templates[i], 'utf-8'),\n                    name,\n                    env\n                ) );\n            } catch(e) {\n                if(opts.force) {\n                    // Don't stop generating the output if we're\n                    // forcing compilation.\n                    console.error(e);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    return wrapper(precompiled, opts);\n}\n\nfunction _precompile(str, name, env) {\n    env = env || new Environment([]);\n\n    var asyncFilters = env.asyncFilters;\n    var extensions = env.extensionsList;\n    var template;\n\n    name = name.replace(/\\\\/g, '/');\n\n    try {\n        template = compiler.compile(str,\n                                    asyncFilters,\n                                    extensions,\n                                    name,\n                                    env.opts);\n    }\n    catch(err) {\n        throw lib.prettifyError(name, false, err);\n    }\n\n    return { name: name, template: template };\n}\n\nmodule.exports = {\n    precompile: precompile,\n    precompileString: precompileString\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/precompile-global.js":"'use strict';\n\nfunction precompileGlobal(templates, opts) {\n    var out = '', name, template;\n    opts = opts || {};\n\n    for ( var i = 0; i < templates.length; i++ ) {\n        name = JSON.stringify(templates[i].name);\n        template = templates[i].template;\n\n        out += '(function() {' +\n            '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' +\n            '[' + name + '] = (function() {\\n' + template + '\\n})();\\n';\n\n        if(opts.asFunction) {\n            out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\\n';\n        }\n\n        out += '})();\\n';\n    }\n    return out;\n}\n\nmodule.exports = precompileGlobal;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/nunjucks/src/jinja-compat.js":"function installCompat() {\n  'use strict';\n\n  // This must be called like `nunjucks.installCompat` so that `this`\n  // references the nunjucks instance\n  var runtime = this.runtime; // jshint ignore:line\n  var lib = this.lib; // jshint ignore:line\n\n  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;\n  runtime.contextOrFrameLookup = function(context, frame, key) {\n    var val = orig_contextOrFrameLookup.apply(this, arguments);\n    if (val === undefined) {\n      switch (key) {\n      case 'True':\n        return true;\n      case 'False':\n        return false;\n      case 'None':\n        return null;\n      }\n    }\n\n    return val;\n  };\n\n  var orig_memberLookup = runtime.memberLookup;\n  var ARRAY_MEMBERS = {\n    pop: function(index) {\n      if (index === undefined) {\n        return this.pop();\n      }\n      if (index >= this.length || index < 0) {\n        throw new Error('KeyError');\n      }\n      return this.splice(index, 1);\n    },\n    append: function(element) {\n        return this.push(element);\n    },\n    remove: function(element) {\n      for (var i = 0; i < this.length; i++) {\n        if (this[i] === element) {\n          return this.splice(i, 1);\n        }\n      }\n      throw new Error('ValueError');\n    },\n    count: function(element) {\n      var count = 0;\n      for (var i = 0; i < this.length; i++) {\n        if (this[i] === element) {\n          count++;\n        }\n      }\n      return count;\n    },\n    index: function(element) {\n      var i;\n      if ((i = this.indexOf(element)) === -1) {\n        throw new Error('ValueError');\n      }\n      return i;\n    },\n    find: function(element) {\n      return this.indexOf(element);\n    },\n    insert: function(index, elem) {\n      return this.splice(index, 0, elem);\n    }\n  };\n  var OBJECT_MEMBERS = {\n    items: function() {\n      var ret = [];\n      for(var k in this) {\n        ret.push([k, this[k]]);\n      }\n      return ret;\n    },\n    values: function() {\n      var ret = [];\n      for(var k in this) {\n        ret.push(this[k]);\n      }\n      return ret;\n    },\n    keys: function() {\n      var ret = [];\n      for(var k in this) {\n        ret.push(k);\n      }\n      return ret;\n    },\n    get: function(key, def) {\n      var output = this[key];\n      if (output === undefined) {\n        output = def;\n      }\n      return output;\n    },\n    has_key: function(key) {\n      return this.hasOwnProperty(key);\n    },\n    pop: function(key, def) {\n      var output = this[key];\n      if (output === undefined && def !== undefined) {\n        output = def;\n      } else if (output === undefined) {\n        throw new Error('KeyError');\n      } else {\n        delete this[key];\n      }\n      return output;\n    },\n    popitem: function() {\n      for (var k in this) {\n        // Return the first object pair.\n        var val = this[k];\n        delete this[k];\n        return [k, val];\n      }\n      throw new Error('KeyError');\n    },\n    setdefault: function(key, def) {\n      if (key in this) {\n        return this[key];\n      }\n      if (def === undefined) {\n        def = null;\n      }\n      return this[key] = def;\n    },\n    update: function(kwargs) {\n      for (var k in kwargs) {\n        this[k] = kwargs[k];\n      }\n      return null;  // Always returns None\n    }\n  };\n  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;\n  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;\n  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;\n  runtime.memberLookup = function(obj, val, autoescape) { // jshint ignore:line\n    obj = obj || {};\n\n    // If the object is an object, return any of the methods that Python would\n    // otherwise provide.\n    if (lib.isArray(obj) && ARRAY_MEMBERS.hasOwnProperty(val)) {\n      return function() {return ARRAY_MEMBERS[val].apply(obj, arguments);};\n    }\n\n    if (lib.isObject(obj) && OBJECT_MEMBERS.hasOwnProperty(val)) {\n      return function() {return OBJECT_MEMBERS[val].apply(obj, arguments);};\n    }\n\n    return orig_memberLookup.apply(this, arguments);\n  };\n}\n\nmodule.exports = installCompat;\n"}