{"/home/travis/build/npmtest/node-npmtest-nunjucks/test.js":"/* istanbul instrument in package npmtest_nunjucks */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nunjucks/lib.npmtest_nunjucks.js":"/* istanbul instrument in package npmtest_nunjucks */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nunjucks = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nunjucks = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nunjucks/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nunjucks && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nunjucks */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nunjucks\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nunjucks.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nunjucks.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nunjucks.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nunjucks.__dirname + '/lib.npmtest_nunjucks.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/index.js":"'use strict';\n\nvar lib = require('./src/lib');\nvar env = require('./src/environment');\nvar Loader = require('./src/loader');\nvar loaders = require('./src/loaders');\nvar precompile = require('./src/precompile');\n\nmodule.exports = {};\nmodule.exports.Environment = env.Environment;\nmodule.exports.Template = env.Template;\n\nmodule.exports.Loader = Loader;\nmodule.exports.FileSystemLoader = loaders.FileSystemLoader;\nmodule.exports.PrecompiledLoader = loaders.PrecompiledLoader;\nmodule.exports.WebLoader = loaders.WebLoader;\n\nmodule.exports.compiler = require('./src/compiler');\nmodule.exports.parser = require('./src/parser');\nmodule.exports.lexer = require('./src/lexer');\nmodule.exports.runtime = require('./src/runtime');\nmodule.exports.lib = lib;\nmodule.exports.nodes = require('./src/nodes');\n\nmodule.exports.installJinjaCompat = require('./src/jinja-compat.js');\n\n// A single instance of an environment, since this is so commonly used\n\nvar e;\nmodule.exports.configure = function(templatesPath, opts) {\n    opts = opts || {};\n    if(lib.isObject(templatesPath)) {\n        opts = templatesPath;\n        templatesPath = null;\n    }\n\n    var TemplateLoader;\n    if(loaders.FileSystemLoader) {\n        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {\n            watch: opts.watch,\n            noCache: opts.noCache\n        });\n    }\n    else if(loaders.WebLoader) {\n        TemplateLoader = new loaders.WebLoader(templatesPath, {\n            useCache: opts.web && opts.web.useCache,\n            async: opts.web && opts.web.async\n        });\n    }\n\n    e = new env.Environment(TemplateLoader, opts);\n\n    if(opts && opts.express) {\n        e.express(opts.express);\n    }\n\n    return e;\n};\n\nmodule.exports.compile = function(src, env, path, eagerCompile) {\n    if(!e) {\n        module.exports.configure();\n    }\n    return new module.exports.Template(src, env, path, eagerCompile);\n};\n\nmodule.exports.render = function(name, ctx, cb) {\n    if(!e) {\n        module.exports.configure();\n    }\n\n    return e.render(name, ctx, cb);\n};\n\nmodule.exports.renderString = function(src, ctx, cb) {\n    if(!e) {\n        module.exports.configure();\n    }\n\n    return e.renderString(src, ctx, cb);\n};\n\nif(precompile) {\n    module.exports.precompile = precompile.precompile;\n    module.exports.precompileString = precompile.precompileString;\n}\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/lib.js":"'use strict';\n\nvar ArrayProto = Array.prototype;\nvar ObjProto = Object.prototype;\n\nvar escapeMap = {\n    '&': '&amp;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\n\nvar escapeRegex = /[&\"'<>]/g;\n\nvar lookupEscape = function(ch) {\n    return escapeMap[ch];\n};\n\nvar exports = module.exports = {};\n\nexports.prettifyError = function(path, withInternals, err) {\n    // jshint -W022\n    // http://jslinterrors.com/do-not-assign-to-the-exception-parameter\n    if (!err.Update) {\n        // not one of ours, cast it\n        err = new exports.TemplateError(err);\n    }\n    err.Update(path);\n\n    // Unless they marked the dev flag, show them a trace from here\n    if (!withInternals) {\n        var old = err;\n        err = new Error(old.message);\n        err.name = old.name;\n    }\n\n    return err;\n};\n\nexports.TemplateError = function(message, lineno, colno) {\n    var err = this;\n\n    if (message instanceof Error) { // for casting regular js errors\n        err = message;\n        message = message.name + ': ' + message.message;\n\n        try {\n            if(err.name = '') {}\n        }\n        catch(e) {\n            // If we can't set the name of the error object in this\n            // environment, don't use it\n            err = this;\n        }\n    } else {\n        if(Error.captureStackTrace) {\n            Error.captureStackTrace(err);\n        }\n    }\n\n    err.name = 'Template render error';\n    err.message = message;\n    err.lineno = lineno;\n    err.colno = colno;\n    err.firstUpdate = true;\n\n    err.Update = function(path) {\n        var message = '(' + (path || 'unknown path') + ')';\n\n        // only show lineno + colno next to path of template\n        // where error occurred\n        if (this.firstUpdate) {\n            if(this.lineno && this.colno) {\n                message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';\n            }\n            else if(this.lineno) {\n                message += ' [Line ' + this.lineno + ']';\n            }\n        }\n\n        message += '\\n ';\n        if (this.firstUpdate) {\n            message += ' ';\n        }\n\n        this.message = message + (this.message || '');\n        this.firstUpdate = false;\n        return this;\n    };\n\n    return err;\n};\n\nexports.TemplateError.prototype = Error.prototype;\n\nexports.escape = function(val) {\n  return val.replace(escapeRegex, lookupEscape);\n};\n\nexports.isFunction = function(obj) {\n    return ObjProto.toString.call(obj) === '[object Function]';\n};\n\nexports.isArray = Array.isArray || function(obj) {\n    return ObjProto.toString.call(obj) === '[object Array]';\n};\n\nexports.isString = function(obj) {\n    return ObjProto.toString.call(obj) === '[object String]';\n};\n\nexports.isObject = function(obj) {\n    return ObjProto.toString.call(obj) === '[object Object]';\n};\n\nexports.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };\n    for(var i=0; i<obj.length; i++) {\n        var value = obj[i];\n        var key = iterator(value, i);\n        (result[key] || (result[key] = [])).push(value);\n    }\n    return result;\n};\n\nexports.toArray = function(obj) {\n    return Array.prototype.slice.call(obj);\n};\n\nexports.without = function(array) {\n    var result = [];\n    if (!array) {\n        return result;\n    }\n    var index = -1,\n    length = array.length,\n    contains = exports.toArray(arguments).slice(1);\n\n    while(++index < length) {\n        if(exports.indexOf(contains, array[index]) === -1) {\n            result.push(array[index]);\n        }\n    }\n    return result;\n};\n\nexports.extend = function(obj, obj2) {\n    for(var k in obj2) {\n        obj[k] = obj2[k];\n    }\n    return obj;\n};\n\nexports.repeat = function(char_, n) {\n    var str = '';\n    for(var i=0; i<n; i++) {\n        str += char_;\n    }\n    return str;\n};\n\nexports.each = function(obj, func, context) {\n    if(obj == null) {\n        return;\n    }\n\n    if(ArrayProto.each && obj.each === ArrayProto.each) {\n        obj.forEach(func, context);\n    }\n    else if(obj.length === +obj.length) {\n        for(var i=0, l=obj.length; i<l; i++) {\n            func.call(context, obj[i], i, obj);\n        }\n    }\n};\n\nexports.map = function(obj, func) {\n    var results = [];\n    if(obj == null) {\n        return results;\n    }\n\n    if(ArrayProto.map && obj.map === ArrayProto.map) {\n        return obj.map(func);\n    }\n\n    for(var i=0; i<obj.length; i++) {\n        results[results.length] = func(obj[i], i);\n    }\n\n    if(obj.length === +obj.length) {\n        results.length = obj.length;\n    }\n\n    return results;\n};\n\nexports.asyncIter = function(arr, iter, cb) {\n    var i = -1;\n\n    function next() {\n        i++;\n\n        if(i < arr.length) {\n            iter(arr[i], i, next, cb);\n        }\n        else {\n            cb();\n        }\n    }\n\n    next();\n};\n\nexports.asyncFor = function(obj, iter, cb) {\n    var keys = exports.keys(obj);\n    var len = keys.length;\n    var i = -1;\n\n    function next() {\n        i++;\n        var k = keys[i];\n\n        if(i < len) {\n            iter(k, obj[k], i, len, next);\n        }\n        else {\n            cb();\n        }\n    }\n\n    next();\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill\nexports.indexOf = Array.prototype.indexOf ?\n    function (arr, searchElement, fromIndex) {\n        return Array.prototype.indexOf.call(arr, searchElement, fromIndex);\n    } :\n    function (arr, searchElement, fromIndex) {\n        var length = this.length >>> 0; // Hack to convert object.length to a UInt32\n\n        fromIndex = +fromIndex || 0;\n\n        if(Math.abs(fromIndex) === Infinity) {\n            fromIndex = 0;\n        }\n\n        if(fromIndex < 0) {\n            fromIndex += length;\n            if (fromIndex < 0) {\n                fromIndex = 0;\n            }\n        }\n\n        for(;fromIndex < length; fromIndex++) {\n            if (arr[fromIndex] === searchElement) {\n                return fromIndex;\n            }\n        }\n\n        return -1;\n    };\n\nif(!Array.prototype.map) {\n    Array.prototype.map = function() {\n        throw new Error('map is unimplemented for this js engine');\n    };\n}\n\nexports.keys = function(obj) {\n    if(Object.prototype.keys) {\n        return obj.keys();\n    }\n    else {\n        var keys = [];\n        for(var k in obj) {\n            if(obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    }\n};\n\nexports.inOperator = function (key, val) {\n    if (exports.isArray(val)) {\n        return exports.indexOf(val, key) !== -1;\n    } else if (exports.isObject(val)) {\n        return key in val;\n    } else if (exports.isString(val)) {\n        return val.indexOf(key) !== -1;\n    } else {\n        throw new Error('Cannot use \"in\" operator to search for \"'\n            + key + '\" in unexpected types.');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/environment.js":"'use strict';\n\nvar path = require('path');\nvar asap = require('asap');\nvar lib = require('./lib');\nvar Obj = require('./object');\nvar compiler = require('./compiler');\nvar builtin_filters = require('./filters');\nvar builtin_loaders = require('./loaders');\nvar runtime = require('./runtime');\nvar globals = require('./globals');\nvar waterfall = require('a-sync-waterfall');\nvar Frame = runtime.Frame;\nvar Template;\n\n// Unconditionally load in this loader, even if no other ones are\n// included (possible in the slim browser build)\nbuiltin_loaders.PrecompiledLoader = require('./precompiled-loader');\n\n// If the user is using the async API, *always* call it\n// asynchronously even if the template was synchronous.\nfunction callbackAsap(cb, err, res) {\n    asap(function() { cb(err, res); });\n}\n\nvar Environment = Obj.extend({\n    init: function(loaders, opts) {\n        // The dev flag determines the trace that'll be shown on errors.\n        // If set to true, returns the full trace from the error point,\n        // otherwise will return trace starting from Template.render\n        // (the full trace from within nunjucks may confuse developers using\n        //  the library)\n        // defaults to false\n        opts = this.opts = opts || {};\n        this.opts.dev = !!opts.dev;\n\n        // The autoescape flag sets global autoescaping. If true,\n        // every string variable will be escaped by default.\n        // If false, strings can be manually escaped using the `escape` filter.\n        // defaults to true\n        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;\n\n        // If true, this will make the system throw errors if trying\n        // to output a null or undefined value\n        this.opts.throwOnUndefined = !!opts.throwOnUndefined;\n        this.opts.trimBlocks = !!opts.trimBlocks;\n        this.opts.lstripBlocks = !!opts.lstripBlocks;\n\n        this.loaders = [];\n\n        if(!loaders) {\n            // The filesystem loader is only available server-side\n            if(builtin_loaders.FileSystemLoader) {\n                this.loaders = [new builtin_loaders.FileSystemLoader('views')];\n            }\n            else if(builtin_loaders.WebLoader) {\n                this.loaders = [new builtin_loaders.WebLoader('/views')];\n            }\n        }\n        else {\n            this.loaders = lib.isArray(loaders) ? loaders : [loaders];\n        }\n\n        // It's easy to use precompiled templates: just include them\n        // before you configure nunjucks and this will automatically\n        // pick it up and use it\n        if(process.env.IS_BROWSER && window.nunjucksPrecompiled) {\n            this.loaders.unshift(\n                new builtin_loaders.PrecompiledLoader(window.nunjucksPrecompiled)\n            );\n        }\n\n        this.initCache();\n\n        this.globals = globals();\n        this.filters = {};\n        this.asyncFilters = [];\n        this.extensions = {};\n        this.extensionsList = [];\n\n        for(var name in builtin_filters) {\n            this.addFilter(name, builtin_filters[name]);\n        }\n    },\n\n    initCache: function() {\n        // Caching and cache busting\n        lib.each(this.loaders, function(loader) {\n            loader.cache = {};\n\n            if(typeof loader.on === 'function') {\n                loader.on('update', function(template) {\n                    loader.cache[template] = null;\n                });\n            }\n        });\n    },\n\n    addExtension: function(name, extension) {\n        extension._name = name;\n        this.extensions[name] = extension;\n        this.extensionsList.push(extension);\n        return this;\n    },\n\n    removeExtension: function(name) {\n        var extension = this.getExtension(name);\n        if (!extension) return;\n\n        this.extensionsList = lib.without(this.extensionsList, extension);\n        delete this.extensions[name];\n    },\n\n    getExtension: function(name) {\n        return this.extensions[name];\n    },\n\n    hasExtension: function(name) {\n        return !!this.extensions[name];\n    },\n\n    addGlobal: function(name, value) {\n        this.globals[name] = value;\n        return this;\n    },\n\n    getGlobal: function(name) {\n        if(typeof this.globals[name] === 'undefined') {\n            throw new Error('global not found: ' + name);\n        }\n        return this.globals[name];\n    },\n\n    addFilter: function(name, func, async) {\n        var wrapped = func;\n\n        if(async) {\n            this.asyncFilters.push(name);\n        }\n        this.filters[name] = wrapped;\n        return this;\n    },\n\n    getFilter: function(name) {\n        if(!this.filters[name]) {\n            throw new Error('filter not found: ' + name);\n        }\n        return this.filters[name];\n    },\n\n    resolveTemplate: function(loader, parentName, filename) {\n        var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;\n        return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;\n    },\n\n    getTemplate: function(name, eagerCompile, parentName, ignoreMissing, cb) {\n        var that = this;\n        var tmpl = null;\n        if(name && name.raw) {\n            // this fixes autoescape for templates referenced in symbols\n            name = name.raw;\n        }\n\n        if(lib.isFunction(parentName)) {\n            cb = parentName;\n            parentName = null;\n            eagerCompile = eagerCompile || false;\n        }\n\n        if(lib.isFunction(eagerCompile)) {\n            cb = eagerCompile;\n            eagerCompile = false;\n        }\n\n        if (name instanceof Template) {\n             tmpl = name;\n        }\n        else if(typeof name !== 'string') {\n            throw new Error('template names must be a string: ' + name);\n        }\n        else {\n            for (var i = 0; i < this.loaders.length; i++) {\n                var _name = this.resolveTemplate(this.loaders[i], parentName, name);\n                tmpl = this.loaders[i].cache[_name];\n                if (tmpl) break;\n            }\n        }\n\n        if(tmpl) {\n            if(eagerCompile) {\n                tmpl.compile();\n            }\n\n            if(cb) {\n                cb(null, tmpl);\n            }\n            else {\n                return tmpl;\n            }\n        } else {\n            var syncResult;\n            var _this = this;\n\n            var createTemplate = function(err, info) {\n                if(!info && !err) {\n                    if(!ignoreMissing) {\n                        err = new Error('template not found: ' + name);\n                    }\n                }\n\n                if (err) {\n                    if(cb) {\n                        cb(err);\n                    }\n                    else {\n                        throw err;\n                    }\n                }\n                else {\n                    var tmpl;\n                    if(info) {\n                        tmpl = new Template(info.src, _this,\n                                            info.path, eagerCompile);\n\n                        if(!info.noCache) {\n                            info.loader.cache[name] = tmpl;\n                        }\n                    }\n                    else {\n                        tmpl = new Template('', _this,\n                                            '', eagerCompile);\n                    }\n\n                    if(cb) {\n                        cb(null, tmpl);\n                    }\n                    else {\n                        syncResult = tmpl;\n                    }\n                }\n            };\n\n            lib.asyncIter(this.loaders, function(loader, i, next, done) {\n                function handle(err, src) {\n                    if(err) {\n                        done(err);\n                    }\n                    else if(src) {\n                        src.loader = loader;\n                        done(null, src);\n                    }\n                    else {\n                        next();\n                    }\n                }\n\n                // Resolve name relative to parentName\n                name = that.resolveTemplate(loader, parentName, name);\n\n                if(loader.async) {\n                    loader.getSource(name, handle);\n                }\n                else {\n                    handle(null, loader.getSource(name));\n                }\n            }, createTemplate);\n\n            return syncResult;\n        }\n    },\n\n    express: function(app) {\n        var env = this;\n\n        function NunjucksView(name, opts) {\n            this.name          = name;\n            this.path          = name;\n            this.defaultEngine = opts.defaultEngine;\n            this.ext           = path.extname(name);\n            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');\n            if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);\n        }\n\n        NunjucksView.prototype.render = function(opts, cb) {\n          env.render(this.name, opts, cb);\n        };\n\n        app.set('view', NunjucksView);\n        app.set('nunjucksEnv', this);\n        return this;\n    },\n\n    render: function(name, ctx, cb) {\n        if(lib.isFunction(ctx)) {\n            cb = ctx;\n            ctx = null;\n        }\n\n        // We support a synchronous API to make it easier to migrate\n        // existing code to async. This works because if you don't do\n        // anything async work, the whole thing is actually run\n        // synchronously.\n        var syncResult = null;\n\n        this.getTemplate(name, function(err, tmpl) {\n            if(err && cb) {\n                callbackAsap(cb, err);\n            }\n            else if(err) {\n                throw err;\n            }\n            else {\n                syncResult = tmpl.render(ctx, cb);\n            }\n        });\n\n        return syncResult;\n    },\n\n    renderString: function(src, ctx, opts, cb) {\n        if(lib.isFunction(opts)) {\n            cb = opts;\n            opts = {};\n        }\n        opts = opts || {};\n\n        var tmpl = new Template(src, this, opts.path);\n        return tmpl.render(ctx, cb);\n    },\n\n    waterfall: waterfall\n});\n\nvar Context = Obj.extend({\n    init: function(ctx, blocks, env) {\n        // Has to be tied to an environment so we can tap into its globals.\n        this.env = env || new Environment();\n\n        // Make a duplicate of ctx\n        this.ctx = {};\n        for(var k in ctx) {\n            if(ctx.hasOwnProperty(k)) {\n                this.ctx[k] = ctx[k];\n            }\n        }\n\n        this.blocks = {};\n        this.exported = [];\n\n        for(var name in blocks) {\n            this.addBlock(name, blocks[name]);\n        }\n    },\n\n    lookup: function(name) {\n        // This is one of the most called functions, so optimize for\n        // the typical case where the name isn't in the globals\n        if(name in this.env.globals && !(name in this.ctx)) {\n            return this.env.globals[name];\n        }\n        else {\n            return this.ctx[name];\n        }\n    },\n\n    setVariable: function(name, val) {\n        this.ctx[name] = val;\n    },\n\n    getVariables: function() {\n        return this.ctx;\n    },\n\n    addBlock: function(name, block) {\n        this.blocks[name] = this.blocks[name] || [];\n        this.blocks[name].push(block);\n        return this;\n    },\n\n    getBlock: function(name) {\n        if(!this.blocks[name]) {\n            throw new Error('unknown block \"' + name + '\"');\n        }\n\n        return this.blocks[name][0];\n    },\n\n    getSuper: function(env, name, block, frame, runtime, cb) {\n        var idx = lib.indexOf(this.blocks[name] || [], block);\n        var blk = this.blocks[name][idx + 1];\n        var context = this;\n\n        if(idx === -1 || !blk) {\n            throw new Error('no super block available for \"' + name + '\"');\n        }\n\n        blk(env, context, frame, runtime, cb);\n    },\n\n    addExport: function(name) {\n        this.exported.push(name);\n    },\n\n    getExported: function() {\n        var exported = {};\n        for(var i=0; i<this.exported.length; i++) {\n            var name = this.exported[i];\n            exported[name] = this.ctx[name];\n        }\n        return exported;\n    }\n});\n\nTemplate = Obj.extend({\n    init: function (src, env, path, eagerCompile) {\n        this.env = env || new Environment();\n\n        if(lib.isObject(src)) {\n            switch(src.type) {\n            case 'code': this.tmplProps = src.obj; break;\n            case 'string': this.tmplStr = src.obj; break;\n            }\n        }\n        else if(lib.isString(src)) {\n            this.tmplStr = src;\n        }\n        else {\n            throw new Error('src must be a string or an object describing ' +\n                            'the source');\n        }\n\n        this.path = path;\n\n        if(eagerCompile) {\n            var _this = this;\n            try {\n                _this._compile();\n            }\n            catch(err) {\n                throw lib.prettifyError(this.path, this.env.opts.dev, err);\n            }\n        }\n        else {\n            this.compiled = false;\n        }\n    },\n\n    render: function(ctx, parentFrame, cb) {\n        if (typeof ctx === 'function') {\n            cb = ctx;\n            ctx = {};\n        }\n        else if (typeof parentFrame === 'function') {\n            cb = parentFrame;\n            parentFrame = null;\n        }\n\n        var forceAsync = true;\n        if(parentFrame) {\n            // If there is a frame, we are being called from internal\n            // code of another template, and the internal system\n            // depends on the sync/async nature of the parent template\n            // to be inherited, so force an async callback\n            forceAsync = false;\n        }\n\n        var _this = this;\n        // Catch compile errors for async rendering\n        try {\n            _this.compile();\n        } catch (_err) {\n            var err = lib.prettifyError(this.path, this.env.opts.dev, _err);\n            if (cb) return callbackAsap(cb, err);\n            else throw err;\n        }\n\n        var context = new Context(ctx || {}, _this.blocks, _this.env);\n        var frame = parentFrame ? parentFrame.push(true) : new Frame();\n        frame.topLevel = true;\n        var syncResult = null;\n\n        _this.rootRenderFunc(\n            _this.env,\n            context,\n            frame || new Frame(),\n            runtime,\n            function(err, res) {\n                if(err) {\n                    err = lib.prettifyError(_this.path, _this.env.opts.dev, err);\n                }\n\n                if(cb) {\n                    if(forceAsync) {\n                        callbackAsap(cb, err, res);\n                    }\n                    else {\n                        cb(err, res);\n                    }\n                }\n                else {\n                    if(err) { throw err; }\n                    syncResult = res;\n                }\n            }\n        );\n\n        return syncResult;\n    },\n\n\n    getExported: function(ctx, parentFrame, cb) {\n        if (typeof ctx === 'function') {\n            cb = ctx;\n            ctx = {};\n        }\n\n        if (typeof parentFrame === 'function') {\n            cb = parentFrame;\n            parentFrame = null;\n        }\n\n        // Catch compile errors for async rendering\n        try {\n            this.compile();\n        } catch (e) {\n            if (cb) return cb(e);\n            else throw e;\n        }\n\n        var frame = parentFrame ? parentFrame.push() : new Frame();\n        frame.topLevel = true;\n\n        // Run the rootRenderFunc to populate the context with exported vars\n        var context = new Context(ctx || {}, this.blocks, this.env);\n        this.rootRenderFunc(this.env,\n                            context,\n                            frame,\n                            runtime,\n                            function(err) {\n        \t\t        if ( err ) {\n        \t\t\t    cb(err, null);\n        \t\t        } else {\n        \t\t\t    cb(null, context.getExported());\n        \t\t        }\n                            });\n    },\n\n    compile: function() {\n        if(!this.compiled) {\n            this._compile();\n        }\n    },\n\n    _compile: function() {\n        var props;\n\n        if(this.tmplProps) {\n            props = this.tmplProps;\n        }\n        else {\n            var source = compiler.compile(this.tmplStr,\n                                          this.env.asyncFilters,\n                                          this.env.extensionsList,\n                                          this.path,\n                                          this.env.opts);\n\n            /* jslint evil: true */\n            var func = new Function(source);\n            props = func();\n        }\n\n        this.blocks = this._getBlocks(props);\n        this.rootRenderFunc = props.root;\n        this.compiled = true;\n    },\n\n    _getBlocks: function(props) {\n        var blocks = {};\n\n        for(var k in props) {\n            if(k.slice(0, 2) === 'b_') {\n                blocks[k.slice(2)] = props[k];\n            }\n        }\n\n        return blocks;\n    }\n});\n\nmodule.exports = {\n    Environment: Environment,\n    Template: Template\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/object.js":"'use strict';\n\n// A simple class system, more documentation to come\n\nfunction extend(cls, name, props) {\n    // This does that same thing as Object.create, but with support for IE8\n    var F = function() {};\n    F.prototype = cls.prototype;\n    var prototype = new F();\n\n    // jshint undef: false\n    var fnTest = /xyz/.test(function(){ xyz; }) ? /\\bparent\\b/ : /.*/;\n    props = props || {};\n\n    for(var k in props) {\n        var src = props[k];\n        var parent = prototype[k];\n\n        if(typeof parent === 'function' &&\n           typeof src === 'function' &&\n           fnTest.test(src)) {\n            /*jshint -W083 */\n            prototype[k] = (function (src, parent) {\n                return function() {\n                    // Save the current parent method\n                    var tmp = this.parent;\n\n                    // Set parent to the previous method, call, and restore\n                    this.parent = parent;\n                    var res = src.apply(this, arguments);\n                    this.parent = tmp;\n\n                    return res;\n                };\n            })(src, parent);\n        }\n        else {\n            prototype[k] = src;\n        }\n    }\n\n    prototype.typename = name;\n\n    var new_cls = function() {\n        if(prototype.init) {\n            prototype.init.apply(this, arguments);\n        }\n    };\n\n    new_cls.prototype = prototype;\n    new_cls.prototype.constructor = new_cls;\n\n    new_cls.extend = function(name, props) {\n        if(typeof name === 'object') {\n            props = name;\n            name = 'anonymous';\n        }\n        return extend(new_cls, name, props);\n    };\n\n    return new_cls;\n}\n\nmodule.exports = extend(Object, 'Object', {});\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/compiler.js":"'use strict';\n\nvar lib = require('./lib');\nvar parser = require('./parser');\nvar transformer = require('./transformer');\nvar nodes = require('./nodes');\n// jshint -W079\nvar Object = require('./object');\nvar Frame = require('./runtime').Frame;\n\n// These are all the same for now, but shouldn't be passed straight\n// through\nvar compareOps = {\n    '==': '==',\n    '===': '===',\n    '!=': '!=',\n    '!==': '!==',\n    '<': '<',\n    '>': '>',\n    '<=': '<=',\n    '>=': '>='\n};\n\n// A common pattern is to emit binary operators\nfunction binOpEmitter(str) {\n    return function(node, frame) {\n        this.compile(node.left, frame);\n        this.emit(str);\n        this.compile(node.right, frame);\n    };\n}\n\nvar Compiler = Object.extend({\n    init: function(templateName, throwOnUndefined) {\n        this.templateName = templateName;\n        this.codebuf = [];\n        this.lastId = 0;\n        this.buffer = null;\n        this.bufferStack = [];\n        this.scopeClosers = '';\n        this.inBlock = false;\n        this.throwOnUndefined = throwOnUndefined;\n    },\n\n    fail: function (msg, lineno, colno) {\n        if (lineno !== undefined) lineno += 1;\n        if (colno !== undefined) colno += 1;\n\n        throw new lib.TemplateError(msg, lineno, colno);\n    },\n\n    pushBufferId: function(id) {\n        this.bufferStack.push(this.buffer);\n        this.buffer = id;\n        this.emit('var ' + this.buffer + ' = \"\";');\n    },\n\n    popBufferId: function() {\n        this.buffer = this.bufferStack.pop();\n    },\n\n    emit: function(code) {\n        this.codebuf.push(code);\n    },\n\n    emitLine: function(code) {\n        this.emit(code + '\\n');\n    },\n\n    emitLines: function() {\n        lib.each(lib.toArray(arguments), function(line) {\n            this.emitLine(line);\n        }, this);\n    },\n\n    emitFuncBegin: function(name) {\n        this.buffer = 'output';\n        this.scopeClosers = '';\n        this.emitLine('function ' + name + '(env, context, frame, runtime, cb) {');\n        this.emitLine('var lineno = null;');\n        this.emitLine('var colno = null;');\n        this.emitLine('var ' + this.buffer + ' = \"\";');\n        this.emitLine('try {');\n    },\n\n    emitFuncEnd: function(noReturn) {\n        if(!noReturn) {\n            this.emitLine('cb(null, ' + this.buffer +');');\n        }\n\n        this.closeScopeLevels();\n        this.emitLine('} catch (e) {');\n        this.emitLine('  cb(runtime.handleError(e, lineno, colno));');\n        this.emitLine('}');\n        this.emitLine('}');\n        this.buffer = null;\n    },\n\n    addScopeLevel: function() {\n        this.scopeClosers += '})';\n    },\n\n    closeScopeLevels: function() {\n        this.emitLine(this.scopeClosers + ';');\n        this.scopeClosers = '';\n    },\n\n    withScopedSyntax: function(func) {\n        var scopeClosers = this.scopeClosers;\n        this.scopeClosers = '';\n\n        func.call(this);\n\n        this.closeScopeLevels();\n        this.scopeClosers = scopeClosers;\n    },\n\n    makeCallback: function(res) {\n        var err = this.tmpid();\n\n        return 'function(' + err + (res ? ',' + res : '') + ') {\\n' +\n            'if(' + err + ') { cb(' + err + '); return; }';\n    },\n\n    tmpid: function() {\n        this.lastId++;\n        return 't_' + this.lastId;\n    },\n\n    _templateName: function() {\n        return this.templateName == null? 'undefined' : JSON.stringify(this.templateName);\n    },\n\n    _compileChildren: function(node, frame) {\n        var children = node.children;\n        for(var i=0, l=children.length; i<l; i++) {\n            this.compile(children[i], frame);\n        }\n    },\n\n    _compileAggregate: function(node, frame, startChar, endChar) {\n        if(startChar) {\n            this.emit(startChar);\n        }\n\n        for(var i=0; i<node.children.length; i++) {\n            if(i > 0) {\n                this.emit(',');\n            }\n\n            this.compile(node.children[i], frame);\n        }\n\n        if(endChar) {\n            this.emit(endChar);\n        }\n    },\n\n    _compileExpression: function(node, frame) {\n        // TODO: I'm not really sure if this type check is worth it or\n        // not.\n        this.assertType(\n            node,\n            nodes.Literal,\n            nodes.Symbol,\n            nodes.Group,\n            nodes.Array,\n            nodes.Dict,\n            nodes.FunCall,\n            nodes.Caller,\n            nodes.Filter,\n            nodes.LookupVal,\n            nodes.Compare,\n            nodes.InlineIf,\n            nodes.In,\n            nodes.And,\n            nodes.Or,\n            nodes.Not,\n            nodes.Add,\n            nodes.Concat,\n            nodes.Sub,\n            nodes.Mul,\n            nodes.Div,\n            nodes.FloorDiv,\n            nodes.Mod,\n            nodes.Pow,\n            nodes.Neg,\n            nodes.Pos,\n            nodes.Compare,\n            nodes.NodeList\n        );\n        this.compile(node, frame);\n    },\n\n    assertType: function(node /*, types */) {\n        var types = lib.toArray(arguments).slice(1);\n        var success = false;\n\n        for(var i=0; i<types.length; i++) {\n            if(node instanceof types[i]) {\n                success = true;\n            }\n        }\n\n        if(!success) {\n            this.fail('assertType: invalid type: ' + node.typename,\n                      node.lineno,\n                      node.colno);\n        }\n    },\n\n    compileCallExtension: function(node, frame, async) {\n        var args = node.args;\n        var contentArgs = node.contentArgs;\n        var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;\n\n        if(!async) {\n            this.emit(this.buffer + ' += runtime.suppressValue(');\n        }\n\n        this.emit('env.getExtension(\"' + node.extName + '\")[\"' + node.prop + '\"](');\n        this.emit('context');\n\n        if(args || contentArgs) {\n            this.emit(',');\n        }\n\n        if(args) {\n            if(!(args instanceof nodes.NodeList)) {\n                this.fail('compileCallExtension: arguments must be a NodeList, ' +\n                          'use `parser.parseSignature`');\n            }\n\n            lib.each(args.children, function(arg, i) {\n                // Tag arguments are passed normally to the call. Note\n                // that keyword arguments are turned into a single js\n                // object as the last argument, if they exist.\n                this._compileExpression(arg, frame);\n\n                if(i !== args.children.length - 1 || contentArgs.length) {\n                    this.emit(',');\n                }\n            }, this);\n        }\n\n        if(contentArgs.length) {\n            lib.each(contentArgs, function(arg, i) {\n                if(i > 0) {\n                    this.emit(',');\n                }\n\n                if(arg) {\n                    var id = this.tmpid();\n\n                    this.emitLine('function(cb) {');\n                    this.emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');\n                    this.pushBufferId(id);\n\n                    this.withScopedSyntax(function() {\n                        this.compile(arg, frame);\n                        this.emitLine('cb(null, ' + id + ');');\n                    });\n\n                    this.popBufferId();\n                    this.emitLine('return ' + id + ';');\n                    this.emitLine('}');\n                }\n                else {\n                    this.emit('null');\n                }\n            }, this);\n        }\n\n        if(async) {\n            var res = this.tmpid();\n            this.emitLine(', ' + this.makeCallback(res));\n            this.emitLine(this.buffer + ' += runtime.suppressValue(' + res + ', ' + autoescape + ' && env.opts.autoescape);');\n            this.addScopeLevel();\n        }\n        else {\n            this.emit(')');\n            this.emit(', ' + autoescape + ' && env.opts.autoescape);\\n');\n        }\n    },\n\n    compileCallExtensionAsync: function(node, frame) {\n        this.compileCallExtension(node, frame, true);\n    },\n\n    compileNodeList: function(node, frame) {\n        this._compileChildren(node, frame);\n    },\n\n    compileLiteral: function(node) {\n        if(typeof node.value === 'string') {\n            var val = node.value.replace(/\\\\/g, '\\\\\\\\');\n            val = val.replace(/\"/g, '\\\\\"');\n            val = val.replace(/\\n/g, '\\\\n');\n            val = val.replace(/\\r/g, '\\\\r');\n            val = val.replace(/\\t/g, '\\\\t');\n            this.emit('\"' + val  + '\"');\n        }\n        else if (node.value === null) {\n            this.emit('null');\n        }\n        else {\n            this.emit(node.value.toString());\n        }\n    },\n\n    compileSymbol: function(node, frame) {\n        var name = node.value;\n        var v;\n\n        if((v = frame.lookup(name))) {\n            this.emit(v);\n        }\n        else {\n            this.emit('runtime.contextOrFrameLookup(' +\n                      'context, frame, \"' + name + '\")');\n        }\n    },\n\n    compileGroup: function(node, frame) {\n        this._compileAggregate(node, frame, '(', ')');\n    },\n\n    compileArray: function(node, frame) {\n        this._compileAggregate(node, frame, '[', ']');\n    },\n\n    compileDict: function(node, frame) {\n        this._compileAggregate(node, frame, '{', '}');\n    },\n\n    compilePair: function(node, frame) {\n        var key = node.key;\n        var val = node.value;\n\n        if(key instanceof nodes.Symbol) {\n            key = new nodes.Literal(key.lineno, key.colno, key.value);\n        }\n        else if(!(key instanceof nodes.Literal &&\n                  typeof key.value === 'string')) {\n            this.fail('compilePair: Dict keys must be strings or names',\n                      key.lineno,\n                      key.colno);\n        }\n\n        this.compile(key, frame);\n        this.emit(': ');\n        this._compileExpression(val, frame);\n    },\n\n    compileInlineIf: function(node, frame) {\n        this.emit('(');\n        this.compile(node.cond, frame);\n        this.emit('?');\n        this.compile(node.body, frame);\n        this.emit(':');\n        if(node.else_ !== null)\n            this.compile(node.else_, frame);\n        else\n            this.emit('\"\"');\n        this.emit(')');\n    },\n\n    compileIn: function(node, frame) {\n      this.emit('runtime.inOperator(');\n      this.compile(node.left, frame);\n      this.emit(',');\n      this.compile(node.right, frame);\n      this.emit(')');\n    },\n\n    compileOr: binOpEmitter(' || '),\n    compileAnd: binOpEmitter(' && '),\n    compileAdd: binOpEmitter(' + '),\n    // ensure concatenation instead of addition\n    // by adding empty string in between\n    compileConcat: binOpEmitter(' + \"\" + '),\n    compileSub: binOpEmitter(' - '),\n    compileMul: binOpEmitter(' * '),\n    compileDiv: binOpEmitter(' / '),\n    compileMod: binOpEmitter(' % '),\n\n    compileNot: function(node, frame) {\n        this.emit('!');\n        this.compile(node.target, frame);\n    },\n\n    compileFloorDiv: function(node, frame) {\n        this.emit('Math.floor(');\n        this.compile(node.left, frame);\n        this.emit(' / ');\n        this.compile(node.right, frame);\n        this.emit(')');\n    },\n\n    compilePow: function(node, frame) {\n        this.emit('Math.pow(');\n        this.compile(node.left, frame);\n        this.emit(', ');\n        this.compile(node.right, frame);\n        this.emit(')');\n    },\n\n    compileNeg: function(node, frame) {\n        this.emit('-');\n        this.compile(node.target, frame);\n    },\n\n    compilePos: function(node, frame) {\n        this.emit('+');\n        this.compile(node.target, frame);\n    },\n\n    compileCompare: function(node, frame) {\n        this.compile(node.expr, frame);\n\n        for(var i=0; i<node.ops.length; i++) {\n            var n = node.ops[i];\n            this.emit(' ' + compareOps[n.type] + ' ');\n            this.compile(n.expr, frame);\n        }\n    },\n\n    compileLookupVal: function(node, frame) {\n        this.emit('runtime.memberLookup((');\n        this._compileExpression(node.target, frame);\n        this.emit('),');\n        this._compileExpression(node.val, frame);\n        this.emit(')');\n    },\n\n    _getNodeName: function(node) {\n        switch (node.typename) {\n            case 'Symbol':\n                return node.value;\n            case 'FunCall':\n                return 'the return value of (' + this._getNodeName(node.name) + ')';\n            case 'LookupVal':\n                return this._getNodeName(node.target) + '[\"' +\n                       this._getNodeName(node.val) + '\"]';\n            case 'Literal':\n                return node.value.toString();\n            default:\n                return '--expression--';\n        }\n    },\n\n    compileFunCall: function(node, frame) {\n        // Keep track of line/col info at runtime by settings\n        // variables within an expression. An expression in javascript\n        // like (x, y, z) returns the last value, and x and y can be\n        // anything\n        this.emit('(lineno = ' + node.lineno +\n                  ', colno = ' + node.colno + ', ');\n\n        this.emit('runtime.callWrap(');\n        // Compile it as normal.\n        this._compileExpression(node.name, frame);\n\n        // Output the name of what we're calling so we can get friendly errors\n        // if the lookup fails.\n        this.emit(', \"' + this._getNodeName(node.name).replace(/\"/g, '\\\\\"') + '\", context, ');\n\n        this._compileAggregate(node.args, frame, '[', '])');\n\n        this.emit(')');\n    },\n\n    compileFilter: function(node, frame) {\n        var name = node.name;\n        this.assertType(name, nodes.Symbol);\n        this.emit('env.getFilter(\"' + name.value + '\").call(context, ');\n        this._compileAggregate(node.args, frame);\n        this.emit(')');\n    },\n\n    compileFilterAsync: function(node, frame) {\n        var name = node.name;\n        this.assertType(name, nodes.Symbol);\n\n        var symbol = node.symbol.value;\n        frame.set(symbol, symbol);\n\n        this.emit('env.getFilter(\"' + name.value + '\").call(context, ');\n        this._compileAggregate(node.args, frame);\n        this.emitLine(', ' + this.makeCallback(symbol));\n\n        this.addScopeLevel();\n    },\n\n    compileKeywordArgs: function(node, frame) {\n        var names = [];\n\n        lib.each(node.children, function(pair) {\n            names.push(pair.key.value);\n        });\n\n        this.emit('runtime.makeKeywordArgs(');\n        this.compileDict(node, frame);\n        this.emit(')');\n    },\n\n    compileSet: function(node, frame) {\n        var ids = [];\n\n        // Lookup the variable names for each identifier and create\n        // new ones if necessary\n        lib.each(node.targets, function(target) {\n            var name = target.value;\n            var id = frame.lookup(name);\n\n            if (id === null || id === undefined) {\n                id = this.tmpid();\n\n                // Note: This relies on js allowing scope across\n                // blocks, in case this is created inside an `if`\n                this.emitLine('var ' + id + ';');\n            }\n\n            ids.push(id);\n        }, this);\n\n        if (node.value) {\n          this.emit(ids.join(' = ') + ' = ');\n          this._compileExpression(node.value, frame);\n          this.emitLine(';');\n        }\n        else {\n          this.emit(ids.join(' = ') + ' = ');\n          this.compile(node.body, frame);\n          this.emitLine(';');\n        }\n\n        lib.each(node.targets, function(target, i) {\n            var id = ids[i];\n            var name = target.value;\n\n            // We are running this for every var, but it's very\n            // uncommon to assign to multiple vars anyway\n            this.emitLine('frame.set(\"' + name + '\", ' + id + ', true);');\n\n            this.emitLine('if(frame.topLevel) {');\n            this.emitLine('context.setVariable(\"' + name + '\", ' + id + ');');\n            this.emitLine('}');\n\n            if(name.charAt(0) !== '_') {\n                this.emitLine('if(frame.topLevel) {');\n                this.emitLine('context.addExport(\"' + name + '\", ' + id + ');');\n                this.emitLine('}');\n            }\n        }, this);\n    },\n\n    compileIf: function(node, frame, async) {\n        this.emit('if(');\n        this._compileExpression(node.cond, frame);\n        this.emitLine(') {');\n\n        this.withScopedSyntax(function() {\n            this.compile(node.body, frame);\n\n            if(async) {\n                this.emit('cb()');\n            }\n        });\n\n        if(node.else_) {\n            this.emitLine('}\\nelse {');\n\n            this.withScopedSyntax(function() {\n                this.compile(node.else_, frame);\n\n                if(async) {\n                    this.emit('cb()');\n                }\n            });\n        } else if(async) {\n            this.emitLine('}\\nelse {');\n            this.emit('cb()');\n        }\n\n        this.emitLine('}');\n    },\n\n    compileIfAsync: function(node, frame) {\n        this.emit('(function(cb) {');\n        this.compileIf(node, frame, true);\n        this.emit('})(' + this.makeCallback());\n        this.addScopeLevel();\n    },\n\n    emitLoopBindings: function(node, arr, i, len) {\n        var bindings = {\n            index: i + ' + 1',\n            index0: i,\n            revindex: len + ' - ' + i,\n            revindex0: len + ' - ' + i + ' - 1',\n            first: i + ' === 0',\n            last: i + ' === ' + len + ' - 1',\n            length: len\n        };\n\n        for (var name in bindings) {\n            this.emitLine('frame.set(\"loop.' + name + '\", ' + bindings[name] + ');');\n        }\n    },\n\n    compileFor: function(node, frame) {\n        // Some of this code is ugly, but it keeps the generated code\n        // as fast as possible. ForAsync also shares some of this, but\n        // not much.\n\n        var v;\n        var i = this.tmpid();\n        var len = this.tmpid();\n        var arr = this.tmpid();\n        frame = frame.push();\n\n        this.emitLine('frame = frame.push();');\n\n        this.emit('var ' + arr + ' = ');\n        this._compileExpression(node.arr, frame);\n        this.emitLine(';');\n\n        this.emit('if(' + arr + ') {');\n\n        // If multiple names are passed, we need to bind them\n        // appropriately\n        if(node.name instanceof nodes.Array) {\n            this.emitLine('var ' + i + ';');\n\n            // The object could be an arroy or object. Note that the\n            // body of the loop is duplicated for each condition, but\n            // we are optimizing for speed over size.\n            this.emitLine('if(runtime.isArray(' + arr + ')) {'); {\n                this.emitLine('var ' + len + ' = ' + arr + '.length;');\n                this.emitLine('for(' + i + '=0; ' + i + ' < ' + arr + '.length; '\n                              + i + '++) {');\n\n                // Bind each declared var\n                for (var u=0; u < node.name.children.length; u++) {\n                    var tid = this.tmpid();\n                    this.emitLine('var ' + tid + ' = ' + arr + '[' + i + '][' + u + ']');\n                    this.emitLine('frame.set(\"' + node.name.children[u].value\n                                  + '\", ' + arr + '[' + i + '][' + u + ']' + ');');\n                    frame.set(node.name.children[u].value, tid);\n                }\n\n                this.emitLoopBindings(node, arr, i, len);\n                this.withScopedSyntax(function() {\n                    this.compile(node.body, frame);\n                });\n                this.emitLine('}');\n            }\n\n            this.emitLine('} else {'); {\n                // Iterate over the key/values of an object\n                var key = node.name.children[0];\n                var val = node.name.children[1];\n                var k = this.tmpid();\n                v = this.tmpid();\n                frame.set(key.value, k);\n                frame.set(val.value, v);\n\n                this.emitLine(i + ' = -1;');\n                this.emitLine('var ' + len + ' = runtime.keys(' + arr + ').length;');\n                this.emitLine('for(var ' + k + ' in ' + arr + ') {');\n                this.emitLine(i + '++;');\n                this.emitLine('var ' + v + ' = ' + arr + '[' + k + '];');\n                this.emitLine('frame.set(\"' + key.value + '\", ' + k + ');');\n                this.emitLine('frame.set(\"' + val.value + '\", ' + v + ');');\n\n                this.emitLoopBindings(node, arr, i, len);\n                this.withScopedSyntax(function() {\n                    this.compile(node.body, frame);\n                });\n                this.emitLine('}');\n            }\n\n            this.emitLine('}');\n        }\n        else {\n            // Generate a typical array iteration\n            v = this.tmpid();\n            frame.set(node.name.value, v);\n\n            this.emitLine('var ' + len + ' = ' + arr + '.length;');\n            this.emitLine('for(var ' + i + '=0; ' + i + ' < ' + arr + '.length; ' +\n                          i + '++) {');\n            this.emitLine('var ' + v + ' = ' + arr + '[' + i + '];');\n            this.emitLine('frame.set(\"' + node.name.value + '\", ' + v + ');');\n\n            this.emitLoopBindings(node, arr, i, len);\n\n            this.withScopedSyntax(function() {\n                this.compile(node.body, frame);\n            });\n\n            this.emitLine('}');\n        }\n\n        this.emitLine('}');\n        if (node.else_) {\n          this.emitLine('if (!' + len + ') {');\n          this.compile(node.else_, frame);\n          this.emitLine('}');\n        }\n\n        this.emitLine('frame = frame.pop();');\n    },\n\n    _compileAsyncLoop: function(node, frame, parallel) {\n        // This shares some code with the For tag, but not enough to\n        // worry about. This iterates across an object asynchronously,\n        // but not in parallel.\n\n        var i = this.tmpid();\n        var len = this.tmpid();\n        var arr = this.tmpid();\n        var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';\n        frame = frame.push();\n\n        this.emitLine('frame = frame.push();');\n\n        this.emit('var ' + arr + ' = ');\n        this._compileExpression(node.arr, frame);\n        this.emitLine(';');\n\n        if(node.name instanceof nodes.Array) {\n            this.emit('runtime.' + asyncMethod + '(' + arr + ', ' +\n                      node.name.children.length + ', function(');\n\n            lib.each(node.name.children, function(name) {\n                this.emit(name.value + ',');\n            }, this);\n\n            this.emit(i + ',' + len + ',next) {');\n\n            lib.each(node.name.children, function(name) {\n                var id = name.value;\n                frame.set(id, id);\n                this.emitLine('frame.set(\"' + id + '\", ' + id + ');');\n            }, this);\n        }\n        else {\n            var id = node.name.value;\n            this.emitLine('runtime.' + asyncMethod + '(' + arr + ', 1, function(' + id + ', ' + i + ', ' + len + ',next) {');\n            this.emitLine('frame.set(\"' + id + '\", ' + id + ');');\n            frame.set(id, id);\n        }\n\n        this.emitLoopBindings(node, arr, i, len);\n\n        this.withScopedSyntax(function() {\n            var buf;\n            if(parallel) {\n                buf = this.tmpid();\n                this.pushBufferId(buf);\n            }\n\n            this.compile(node.body, frame);\n            this.emitLine('next(' + i + (buf ? ',' + buf : '') + ');');\n\n            if(parallel) {\n                this.popBufferId();\n            }\n        });\n\n        var output = this.tmpid();\n        this.emitLine('}, ' + this.makeCallback(output));\n        this.addScopeLevel();\n\n        if(parallel) {\n            this.emitLine(this.buffer + ' += ' + output + ';');\n        }\n\n        if (node.else_) {\n          this.emitLine('if (!' + arr + '.length) {');\n          this.compile(node.else_, frame);\n          this.emitLine('}');\n        }\n\n        this.emitLine('frame = frame.pop();');\n    },\n\n    compileAsyncEach: function(node, frame) {\n        this._compileAsyncLoop(node, frame);\n    },\n\n    compileAsyncAll: function(node, frame) {\n        this._compileAsyncLoop(node, frame, true);\n    },\n\n    _compileMacro: function(node) {\n        var args = [];\n        var kwargs = null;\n        var funcId = 'macro_' + this.tmpid();\n\n        // Type check the definition of the args\n        lib.each(node.args.children, function(arg, i) {\n            if(i === node.args.children.length - 1 &&\n               arg instanceof nodes.Dict) {\n                kwargs = arg;\n            }\n            else {\n                this.assertType(arg, nodes.Symbol);\n                args.push(arg);\n            }\n        }, this);\n\n        var realNames = lib.map(args, function(n) { return 'l_' + n.value; });\n        realNames.push('kwargs');\n\n        // Quoted argument names\n        var argNames = lib.map(args, function(n) { return '\"' + n.value + '\"'; });\n        var kwargNames = lib.map((kwargs && kwargs.children) || [],\n                                 function(n) { return '\"' + n.key.value + '\"'; });\n\n        // We pass a function to makeMacro which destructures the\n        // arguments so support setting positional args with keywords\n        // args and passing keyword args as positional args\n        // (essentially default values). See runtime.js.\n        var frame = new Frame();\n        this.emitLines(\n            'var ' + funcId + ' = runtime.makeMacro(',\n            '[' + argNames.join(', ') + '], ',\n            '[' + kwargNames.join(', ') + '], ',\n            'function (' + realNames.join(', ') + ') {',\n            'var callerFrame = frame;',\n            'frame = new runtime.Frame();',\n            'kwargs = kwargs || {};',\n            'if (kwargs.hasOwnProperty(\"caller\")) {',\n            'frame.set(\"caller\", kwargs.caller); }'\n        );\n\n        // Expose the arguments to the template. Don't need to use\n        // random names because the function\n        // will create a new run-time scope for us\n        lib.each(args, function(arg) {\n            this.emitLine('frame.set(\"' + arg.value + '\", ' +\n                          'l_' + arg.value + ');');\n            frame.set(arg.value, 'l_' + arg.value);\n        }, this);\n\n        // Expose the keyword arguments\n        if(kwargs) {\n            lib.each(kwargs.children, function(pair) {\n                var name = pair.key.value;\n                this.emit('frame.set(\"' + name + '\", ' +\n                          'kwargs.hasOwnProperty(\"' + name + '\") ? ' +\n                          'kwargs[\"' + name + '\"] : ');\n                this._compileExpression(pair.value, frame);\n                this.emitLine(');');\n            }, this);\n        }\n\n        var bufferId = this.tmpid();\n        this.pushBufferId(bufferId);\n\n        this.withScopedSyntax(function () {\n          this.compile(node.body, frame);\n        });\n\n        this.emitLine('frame = callerFrame;');\n        this.emitLine('return new runtime.SafeString(' + bufferId + ');');\n        this.emitLine('});');\n        this.popBufferId();\n\n        return funcId;\n    },\n\n    compileMacro: function(node, frame) {\n        var funcId = this._compileMacro(node, frame);\n\n        // Expose the macro to the templates\n        var name = node.name.value;\n        frame.set(name, funcId);\n\n        if(frame.parent) {\n            this.emitLine('frame.set(\"' + name + '\", ' + funcId + ');');\n        }\n        else {\n            if(node.name.value.charAt(0) !== '_') {\n                this.emitLine('context.addExport(\"' + name + '\");');\n            }\n            this.emitLine('context.setVariable(\"' + name + '\", ' + funcId + ');');\n        }\n    },\n\n    compileCaller: function(node, frame) {\n        // basically an anonymous \"macro expression\"\n        this.emit('(function (){');\n        var funcId = this._compileMacro(node, frame);\n        this.emit('return ' + funcId + ';})()');\n    },\n\n    compileImport: function(node, frame) {\n        var id = this.tmpid();\n        var target = node.target.value;\n\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(id));\n        this.addScopeLevel();\n\n        this.emitLine(id + '.getExported(' +\n            (node.withContext ? 'context.getVariables(), frame, ' : '') +\n            this.makeCallback(id));\n        this.addScopeLevel();\n\n        frame.set(target, id);\n\n        if(frame.parent) {\n            this.emitLine('frame.set(\"' + target + '\", ' + id + ');');\n        }\n        else {\n            this.emitLine('context.setVariable(\"' + target + '\", ' + id + ');');\n        }\n    },\n\n    compileFromImport: function(node, frame) {\n        var importedId = this.tmpid();\n\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(importedId));\n        this.addScopeLevel();\n\n        this.emitLine(importedId + '.getExported(' +\n            (node.withContext ? 'context.getVariables(), frame, ' : '') +\n            this.makeCallback(importedId));\n        this.addScopeLevel();\n\n        lib.each(node.names.children, function(nameNode) {\n            var name;\n            var alias;\n            var id = this.tmpid();\n\n            if(nameNode instanceof nodes.Pair) {\n                name = nameNode.key.value;\n                alias = nameNode.value.value;\n            }\n            else {\n                name = nameNode.value;\n                alias = name;\n            }\n\n            this.emitLine('if(' + importedId + '.hasOwnProperty(\"' + name + '\")) {');\n            this.emitLine('var ' + id + ' = ' + importedId + '.' + name + ';');\n            this.emitLine('} else {');\n            this.emitLine('cb(new Error(\"cannot import \\'' + name + '\\'\")); return;');\n            this.emitLine('}');\n\n            frame.set(alias, id);\n\n            if(frame.parent) {\n                this.emitLine('frame.set(\"' + alias + '\", ' + id + ');');\n            }\n            else {\n                this.emitLine('context.setVariable(\"' + alias + '\", ' + id + ');');\n            }\n        }, this);\n    },\n\n    compileBlock: function(node) {\n        var id = this.tmpid();\n\n        // If we are executing outside a block (creating a top-level\n        // block), we really don't want to execute its code because it\n        // will execute twice: once when the child template runs and\n        // again when the parent template runs. Note that blocks\n        // within blocks will *always* execute immediately *and*\n        // wherever else they are invoked (like used in a parent\n        // template). This may have behavioral differences from jinja\n        // because blocks can have side effects, but it seems like a\n        // waste of performance to always execute huge top-level\n        // blocks twice\n        if(!this.inBlock) {\n            this.emit('(parentTemplate ? function(e, c, f, r, cb) { cb(\"\"); } : ');\n        }\n        this.emit('context.getBlock(\"' + node.name.value + '\")');\n        if(!this.inBlock) {\n            this.emit(')');\n        }\n        this.emitLine('(env, context, frame, runtime, ' + this.makeCallback(id));\n        this.emitLine(this.buffer + ' += ' + id + ';');\n        this.addScopeLevel();\n    },\n\n    compileSuper: function(node, frame) {\n        var name = node.blockName.value;\n        var id = node.symbol.value;\n\n        this.emitLine('context.getSuper(env, ' +\n                      '\"' + name + '\", ' +\n                      'b_' + name + ', ' +\n                      'frame, runtime, '+\n                      this.makeCallback(id));\n        this.emitLine(id + ' = runtime.markSafe(' + id + ');');\n        this.addScopeLevel();\n        frame.set(id, id);\n    },\n\n    compileExtends: function(node, frame) {\n        var k = this.tmpid();\n\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', true, '+this._templateName()+', false, ' + this.makeCallback('_parentTemplate'));\n\n        // extends is a dynamic tag and can occur within a block like\n        // `if`, so if this happens we need to capture the parent\n        // template in the top-level scope\n        this.emitLine('parentTemplate = _parentTemplate');\n\n        this.emitLine('for(var ' + k + ' in parentTemplate.blocks) {');\n        this.emitLine('context.addBlock(' + k +\n                      ', parentTemplate.blocks[' + k + ']);');\n        this.emitLine('}');\n\n        this.addScopeLevel();\n    },\n\n    compileInclude: function(node, frame) {\n        var id = this.tmpid();\n        var id2 = this.tmpid();\n\n        this.emitLine('var tasks = [];');\n        this.emitLine('tasks.push(');\n        this.emitLine('function(callback) {');\n        this.emit('env.getTemplate(');\n        this._compileExpression(node.template, frame);\n        this.emitLine(', false, '+this._templateName()+', ' + node.ignoreMissing + ', ' + this.makeCallback(id));\n        this.emitLine('callback(null,' + id + ');});');\n        this.emitLine('});');\n\n        this.emitLine('tasks.push(');\n        this.emitLine('function(template, callback){');\n        this.emitLine('template.render(' +\n            'context.getVariables(), frame, ' + this.makeCallback(id2));\n        this.emitLine('callback(null,' + id2 + ');});');\n        this.emitLine('});');\n\n        this.emitLine('tasks.push(');\n        this.emitLine('function(result, callback){');\n        this.emitLine(this.buffer + ' += result;');\n        this.emitLine('callback(null);');\n        this.emitLine('});');\n        this.emitLine('env.waterfall(tasks, function(){');\n        this.addScopeLevel();\n    },\n\n    compileTemplateData: function(node, frame) {\n        this.compileLiteral(node, frame);\n    },\n\n    compileCapture: function(node, frame) {\n        this.emitLine('(function() {');\n        this.emitLine('var output = \"\";');\n        this.withScopedSyntax(function () {\n            this.compile(node.body, frame);\n        });\n        this.emitLine('return output;');\n        this.emitLine('})()');\n    },\n\n    compileOutput: function(node, frame) {\n        var children = node.children;\n        for(var i=0, l=children.length; i<l; i++) {\n            // TemplateData is a special case because it is never\n            // autoescaped, so simply output it for optimization\n            if(children[i] instanceof nodes.TemplateData) {\n                if(children[i].value) {\n                    this.emit(this.buffer + ' += ');\n                    this.compileLiteral(children[i], frame);\n                    this.emitLine(';');\n                }\n            }\n            else {\n                this.emit(this.buffer + ' += runtime.suppressValue(');\n                if(this.throwOnUndefined) {\n                    this.emit('runtime.ensureDefined(');\n                }\n                this.compile(children[i], frame);\n                if(this.throwOnUndefined) {\n                    this.emit(',' + node.lineno + ',' + node.colno + ')');\n                }\n                this.emit(', env.opts.autoescape);\\n');\n            }\n        }\n    },\n\n    compileRoot: function(node, frame) {\n        if(frame) {\n            this.fail('compileRoot: root node can\\'t have frame');\n        }\n\n        frame = new Frame();\n\n        this.emitFuncBegin('root');\n        this.emitLine('var parentTemplate = null;');\n        this._compileChildren(node, frame);\n        this.emitLine('if(parentTemplate) {');\n        this.emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');\n        this.emitLine('} else {');\n        this.emitLine('cb(null, ' + this.buffer +');');\n        this.emitLine('}');\n        this.emitFuncEnd(true);\n\n        this.inBlock = true;\n\n        var blockNames = [];\n\n        var i, name, block, blocks = node.findAll(nodes.Block);\n        for (i = 0; i < blocks.length; i++) {\n            block = blocks[i];\n            name = block.name.value;\n\n            if (blockNames.indexOf(name) !== -1) {\n                throw new Error('Block \"' + name + '\" defined more than once.');\n            }\n            blockNames.push(name);\n\n            this.emitFuncBegin('b_' + name);\n\n            var tmpFrame = new Frame();\n            this.emitLine('var frame = frame.push(true);');\n            this.compile(block.body, tmpFrame);\n            this.emitFuncEnd();\n        }\n\n        this.emitLine('return {');\n        for (i = 0; i < blocks.length; i++) {\n            block = blocks[i];\n            name = 'b_' + block.name.value;\n            this.emitLine(name + ': ' + name + ',');\n        }\n        this.emitLine('root: root\\n};');\n    },\n\n    compile: function (node, frame) {\n        var _compile = this['compile' + node.typename];\n        if(_compile) {\n            _compile.call(this, node, frame);\n        }\n        else {\n            this.fail('compile: Cannot compile node: ' + node.typename,\n                      node.lineno,\n                      node.colno);\n        }\n    },\n\n    getCode: function() {\n        return this.codebuf.join('');\n    }\n});\n\n// var c = new Compiler();\n// var src = 'hello {% filter title %}' +\n//     'Hello madam how are you' +\n//     '{% endfilter %}'\n// var ast = transformer.transform(parser.parse(src));\n// nodes.printNodes(ast);\n// c.compile(ast);\n// var tmpl = c.getCode();\n// console.log(tmpl);\n\nmodule.exports = {\n    compile: function(src, asyncFilters, extensions, name, opts) {\n        var c = new Compiler(name, opts.throwOnUndefined);\n\n        // Run the extension preprocessors against the source.\n        if(extensions && extensions.length) {\n            for(var i=0; i<extensions.length; i++) {\n                if('preprocess' in extensions[i]) {\n                    src = extensions[i].preprocess(src, name);\n                }\n            }\n        }\n\n        c.compile(transformer.transform(\n            parser.parse(src,\n                         extensions,\n                         opts),\n            asyncFilters,\n            name\n        ));\n        return c.getCode();\n    },\n\n    Compiler: Compiler\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/parser.js":"'use strict';\n\nvar lexer = require('./lexer');\nvar nodes = require('./nodes');\n// jshint -W079\nvar Object = require('./object');\nvar lib = require('./lib');\n\nvar Parser = Object.extend({\n    init: function (tokens) {\n        this.tokens = tokens;\n        this.peeked = null;\n        this.breakOnBlocks = null;\n        this.dropLeadingWhitespace = false;\n\n        this.extensions = [];\n    },\n\n    nextToken: function (withWhitespace) {\n        var tok;\n\n        if(this.peeked) {\n            if(!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {\n                this.peeked = null;\n            }\n            else {\n                tok = this.peeked;\n                this.peeked = null;\n                return tok;\n            }\n        }\n\n        tok = this.tokens.nextToken();\n\n        if(!withWhitespace) {\n            while(tok && tok.type === lexer.TOKEN_WHITESPACE) {\n                tok = this.tokens.nextToken();\n            }\n        }\n\n        return tok;\n    },\n\n    peekToken: function () {\n        this.peeked = this.peeked || this.nextToken();\n        return this.peeked;\n    },\n\n    pushToken: function(tok) {\n        if(this.peeked) {\n            throw new Error('pushToken: can only push one token on between reads');\n        }\n        this.peeked = tok;\n    },\n\n    fail: function (msg, lineno, colno) {\n        if((lineno === undefined || colno === undefined) && this.peekToken()) {\n            var tok = this.peekToken();\n            lineno = tok.lineno;\n            colno = tok.colno;\n        }\n        if (lineno !== undefined) lineno += 1;\n        if (colno !== undefined) colno += 1;\n\n        throw new lib.TemplateError(msg, lineno, colno);\n    },\n\n    skip: function(type) {\n        var tok = this.nextToken();\n        if(!tok || tok.type !== type) {\n            this.pushToken(tok);\n            return false;\n        }\n        return true;\n    },\n\n    expect: function(type) {\n        var tok = this.nextToken();\n        if(tok.type !== type) {\n            this.fail('expected ' + type + ', got ' + tok.type,\n                      tok.lineno,\n                      tok.colno);\n        }\n        return tok;\n    },\n\n    skipValue: function(type, val) {\n        var tok = this.nextToken();\n        if(!tok || tok.type !== type || tok.value !== val) {\n            this.pushToken(tok);\n            return false;\n        }\n        return true;\n    },\n\n    skipSymbol: function(val) {\n        return this.skipValue(lexer.TOKEN_SYMBOL, val);\n    },\n\n    advanceAfterBlockEnd: function(name) {\n        var tok;\n        if(!name) {\n            tok = this.peekToken();\n\n            if(!tok) {\n                this.fail('unexpected end of file');\n            }\n\n            if(tok.type !== lexer.TOKEN_SYMBOL) {\n                this.fail('advanceAfterBlockEnd: expected symbol token or ' +\n                          'explicit name to be passed');\n            }\n\n            name = this.nextToken().value;\n        }\n\n        tok = this.nextToken();\n\n        if(tok && tok.type === lexer.TOKEN_BLOCK_END) {\n            if(tok.value.charAt(0) === '-') {\n                this.dropLeadingWhitespace = true;\n            }\n        }\n        else {\n            this.fail('expected block end in ' + name + ' statement');\n        }\n\n        return tok;\n    },\n\n    advanceAfterVariableEnd: function() {\n        var tok = this.nextToken();\n\n        if(tok && tok.type === lexer.TOKEN_VARIABLE_END) {\n            this.dropLeadingWhitespace = tok.value.charAt(\n                tok.value.length - this.tokens.tags.VARIABLE_END.length - 1\n            ) === '-';\n        } else {\n            this.pushToken(tok);\n            this.fail('expected variable end');\n        }\n    },\n\n    parseFor: function() {\n        var forTok = this.peekToken();\n        var node;\n        var endBlock;\n\n        if(this.skipSymbol('for')) {\n            node = new nodes.For(forTok.lineno, forTok.colno);\n            endBlock = 'endfor';\n        }\n        else if(this.skipSymbol('asyncEach')) {\n            node = new nodes.AsyncEach(forTok.lineno, forTok.colno);\n            endBlock = 'endeach';\n        }\n        else if(this.skipSymbol('asyncAll')) {\n            node = new nodes.AsyncAll(forTok.lineno, forTok.colno);\n            endBlock = 'endall';\n        }\n        else {\n            this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);\n        }\n\n        node.name = this.parsePrimary();\n\n        if(!(node.name instanceof nodes.Symbol)) {\n            this.fail('parseFor: variable name expected for loop');\n        }\n\n        var type = this.peekToken().type;\n        if(type === lexer.TOKEN_COMMA) {\n            // key/value iteration\n            var key = node.name;\n            node.name = new nodes.Array(key.lineno, key.colno);\n            node.name.addChild(key);\n\n            while(this.skip(lexer.TOKEN_COMMA)) {\n                var prim = this.parsePrimary();\n                node.name.addChild(prim);\n            }\n        }\n\n        if(!this.skipSymbol('in')) {\n            this.fail('parseFor: expected \"in\" keyword for loop',\n                      forTok.lineno,\n                      forTok.colno);\n        }\n\n        node.arr = this.parseExpression();\n        this.advanceAfterBlockEnd(forTok.value);\n\n        node.body = this.parseUntilBlocks(endBlock, 'else');\n\n        if(this.skipSymbol('else')) {\n            this.advanceAfterBlockEnd('else');\n            node.else_ = this.parseUntilBlocks(endBlock);\n        }\n\n        this.advanceAfterBlockEnd();\n\n        return node;\n    },\n\n    parseMacro: function() {\n        var macroTok = this.peekToken();\n        if(!this.skipSymbol('macro')) {\n            this.fail('expected macro');\n        }\n\n        var name = this.parsePrimary(true);\n        var args = this.parseSignature();\n        var node = new nodes.Macro(macroTok.lineno,\n                                   macroTok.colno,\n                                   name,\n                                   args);\n\n        this.advanceAfterBlockEnd(macroTok.value);\n        node.body = this.parseUntilBlocks('endmacro');\n        this.advanceAfterBlockEnd();\n\n        return node;\n    },\n\n    parseCall: function() {\n        // a call block is parsed as a normal FunCall, but with an added\n        // 'caller' kwarg which is a Caller node.\n        var callTok = this.peekToken();\n        if(!this.skipSymbol('call')) {\n            this.fail('expected call');\n        }\n\n        var callerArgs = this.parseSignature(true) || new nodes.NodeList();\n        var macroCall = this.parsePrimary();\n\n        this.advanceAfterBlockEnd(callTok.value);\n        var body = this.parseUntilBlocks('endcall');\n        this.advanceAfterBlockEnd();\n\n        var callerName = new nodes.Symbol(callTok.lineno,\n                                          callTok.colno,\n                                          'caller');\n        var callerNode = new nodes.Caller(callTok.lineno,\n                                          callTok.colno,\n                                          callerName,\n                                          callerArgs,\n                                          body);\n\n        // add the additional caller kwarg, adding kwargs if necessary\n        var args = macroCall.args.children;\n        if (!(args[args.length-1] instanceof nodes.KeywordArgs)) {\n          args.push(new nodes.KeywordArgs());\n        }\n        var kwargs = args[args.length - 1];\n        kwargs.addChild(new nodes.Pair(callTok.lineno,\n                                       callTok.colno,\n                                       callerName,\n                                       callerNode));\n\n        return new nodes.Output(callTok.lineno,\n                                callTok.colno,\n                                [macroCall]);\n    },\n\n    parseWithContext: function() {\n        var tok = this.peekToken();\n\n        var withContext = null;\n\n        if(this.skipSymbol('with')) {\n            withContext = true;\n        }\n        else if(this.skipSymbol('without')) {\n            withContext = false;\n        }\n\n        if(withContext !== null) {\n            if(!this.skipSymbol('context')) {\n                this.fail('parseFrom: expected context after with/without',\n                            tok.lineno,\n                            tok.colno);\n            }\n        }\n\n        return withContext;\n    },\n\n    parseImport: function() {\n        var importTok = this.peekToken();\n        if(!this.skipSymbol('import')) {\n            this.fail('parseImport: expected import',\n                      importTok.lineno,\n                      importTok.colno);\n        }\n\n        var template = this.parseExpression();\n\n        if(!this.skipSymbol('as')) {\n            this.fail('parseImport: expected \"as\" keyword',\n                            importTok.lineno,\n                            importTok.colno);\n        }\n\n        var target = this.parseExpression();\n\n        var withContext = this.parseWithContext();\n\n        var node = new nodes.Import(importTok.lineno,\n                                    importTok.colno,\n                                    template,\n                                    target,\n                                    withContext);\n\n        this.advanceAfterBlockEnd(importTok.value);\n\n        return node;\n    },\n\n    parseFrom: function() {\n        var fromTok = this.peekToken();\n        if(!this.skipSymbol('from')) {\n            this.fail('parseFrom: expected from');\n        }\n\n        var template = this.parseExpression();\n\n        if(!this.skipSymbol('import')) {\n            this.fail('parseFrom: expected import',\n                            fromTok.lineno,\n                            fromTok.colno);\n        }\n\n        var names = new nodes.NodeList(),\n            withContext;\n\n        while(1) {\n            var nextTok = this.peekToken();\n            if(nextTok.type === lexer.TOKEN_BLOCK_END) {\n                if(!names.children.length) {\n                    this.fail('parseFrom: Expected at least one import name',\n                              fromTok.lineno,\n                              fromTok.colno);\n                }\n\n                // Since we are manually advancing past the block end,\n                // need to keep track of whitespace control (normally\n                // this is done in `advanceAfterBlockEnd`\n                if(nextTok.value.charAt(0) === '-') {\n                    this.dropLeadingWhitespace = true;\n                }\n\n                this.nextToken();\n                break;\n            }\n\n            if(names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {\n                this.fail('parseFrom: expected comma',\n                                fromTok.lineno,\n                                fromTok.colno);\n            }\n\n            var name = this.parsePrimary();\n            if(name.value.charAt(0) === '_') {\n                this.fail('parseFrom: names starting with an underscore ' +\n                          'cannot be imported',\n                          name.lineno,\n                          name.colno);\n            }\n\n            if(this.skipSymbol('as')) {\n                var alias = this.parsePrimary();\n                names.addChild(new nodes.Pair(name.lineno,\n                                              name.colno,\n                                              name,\n                                              alias));\n            }\n            else {\n                names.addChild(name);\n            }\n\n            withContext = this.parseWithContext();\n        }\n\n        return new nodes.FromImport(fromTok.lineno,\n                                    fromTok.colno,\n                                    template,\n                                    names,\n                                    withContext);\n    },\n\n    parseBlock: function() {\n        var tag = this.peekToken();\n        if(!this.skipSymbol('block')) {\n            this.fail('parseBlock: expected block', tag.lineno, tag.colno);\n        }\n\n        var node = new nodes.Block(tag.lineno, tag.colno);\n\n        node.name = this.parsePrimary();\n        if(!(node.name instanceof nodes.Symbol)) {\n            this.fail('parseBlock: variable name expected',\n                      tag.lineno,\n                      tag.colno);\n        }\n\n        this.advanceAfterBlockEnd(tag.value);\n\n        node.body = this.parseUntilBlocks('endblock');\n        this.skipSymbol('endblock');\n        this.skipSymbol(node.name.value);\n\n        var tok = this.peekToken();\n        if(!tok) {\n            this.fail('parseBlock: expected endblock, got end of file');\n        }\n\n        this.advanceAfterBlockEnd(tok.value);\n\n        return node;\n    },\n\n    parseExtends: function() {\n        var tagName = 'extends';\n        var tag = this.peekToken();\n        if(!this.skipSymbol(tagName)) {\n            this.fail('parseTemplateRef: expected '+ tagName);\n        }\n\n        var node = new nodes.Extends(tag.lineno, tag.colno);\n        node.template = this.parseExpression();\n\n        this.advanceAfterBlockEnd(tag.value);\n        return node;\n    },\n\n    parseInclude: function() {\n        var tagName = 'include';\n        var tag = this.peekToken();\n        if(!this.skipSymbol(tagName)) {\n            this.fail('parseInclude: expected '+ tagName);\n        }\n\n        var node = new nodes.Include(tag.lineno, tag.colno);\n        node.template = this.parseExpression();\n\n        if(this.skipSymbol('ignore') && this.skipSymbol('missing')) {\n            node.ignoreMissing = true;\n        }\n\n        this.advanceAfterBlockEnd(tag.value);\n        return node;\n    },\n\n    parseIf: function() {\n        var tag = this.peekToken();\n        var node;\n\n        if(this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {\n            node = new nodes.If(tag.lineno, tag.colno);\n        }\n        else if(this.skipSymbol('ifAsync')) {\n            node = new nodes.IfAsync(tag.lineno, tag.colno);\n        }\n        else {\n            this.fail('parseIf: expected if, elif, or elseif',\n                      tag.lineno,\n                      tag.colno);\n        }\n\n        node.cond = this.parseExpression();\n        this.advanceAfterBlockEnd(tag.value);\n\n        node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');\n        var tok = this.peekToken();\n\n        switch(tok && tok.value) {\n        case 'elseif':\n        case 'elif':\n            node.else_ = this.parseIf();\n            break;\n        case 'else':\n            this.advanceAfterBlockEnd();\n            node.else_ = this.parseUntilBlocks('endif');\n            this.advanceAfterBlockEnd();\n            break;\n        case 'endif':\n            node.else_ = null;\n            this.advanceAfterBlockEnd();\n            break;\n        default:\n            this.fail('parseIf: expected elif, else, or endif, ' +\n                      'got end of file');\n        }\n\n        return node;\n    },\n\n    parseSet: function() {\n        var tag = this.peekToken();\n        if(!this.skipSymbol('set')) {\n            this.fail('parseSet: expected set', tag.lineno, tag.colno);\n        }\n\n        var node = new nodes.Set(tag.lineno, tag.colno, []);\n\n        var target;\n        while((target = this.parsePrimary())) {\n            node.targets.push(target);\n\n            if(!this.skip(lexer.TOKEN_COMMA)) {\n                break;\n            }\n        }\n\n        if(!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {\n            if (!this.skip(lexer.TOKEN_BLOCK_END)) {\n                this.fail('parseSet: expected = or block end in set tag',\n                          tag.lineno,\n                          tag.colno);\n            }\n            else {\n                node.body = new nodes.Capture(\n                    tag.lineno,\n                    tag.colno,\n                    this.parseUntilBlocks('endset')\n                );\n                node.value = null;\n                this.advanceAfterBlockEnd();\n            }\n        }\n        else {\n            node.value = this.parseExpression();\n            this.advanceAfterBlockEnd(tag.value);\n        }\n\n        return node;\n    },\n\n    parseStatement: function () {\n        var tok = this.peekToken();\n        var node;\n\n        if(tok.type !== lexer.TOKEN_SYMBOL) {\n            this.fail('tag name expected', tok.lineno, tok.colno);\n        }\n\n        if(this.breakOnBlocks &&\n           lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {\n            return null;\n        }\n\n        switch(tok.value) {\n        case 'raw': return this.parseRaw();\n        case 'verbatim': return this.parseRaw('verbatim');\n        case 'if':\n        case 'ifAsync':\n            return this.parseIf();\n        case 'for':\n        case 'asyncEach':\n        case 'asyncAll':\n            return this.parseFor();\n        case 'block': return this.parseBlock();\n        case 'extends': return this.parseExtends();\n        case 'include': return this.parseInclude();\n        case 'set': return this.parseSet();\n        case 'macro': return this.parseMacro();\n        case 'call': return this.parseCall();\n        case 'import': return this.parseImport();\n        case 'from': return this.parseFrom();\n        case 'filter': return this.parseFilterStatement();\n        default:\n            if (this.extensions.length) {\n                for (var i = 0; i < this.extensions.length; i++) {\n                    var ext = this.extensions[i];\n                    if (lib.indexOf(ext.tags || [], tok.value) !== -1) {\n                        return ext.parse(this, nodes, lexer);\n                    }\n                }\n            }\n            this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);\n        }\n\n        return node;\n    },\n\n    parseRaw: function(tagName) {\n        tagName = tagName || 'raw';\n        var endTagName = 'end' + tagName;\n        // Look for upcoming raw blocks (ignore all other kinds of blocks)\n        var rawBlockRegex = new RegExp('([\\\\s\\\\S]*?){%\\\\s*(' + tagName + '|' + endTagName + ')\\\\s*(?=%})%}');\n        var rawLevel = 1;\n        var str = '';\n        var matches = null;\n\n        // Skip opening raw token\n        // Keep this token to track line and column numbers\n        var begun = this.advanceAfterBlockEnd();\n\n        // Exit when there's nothing to match\n        // or when we've found the matching \"endraw\" block\n        while((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {\n            var all = matches[0];\n            var pre = matches[1];\n            var blockName = matches[2];\n\n            // Adjust rawlevel\n            if(blockName === tagName) {\n                rawLevel += 1;\n            } else if(blockName === endTagName) {\n                rawLevel -= 1;\n            }\n\n            // Add to str\n            if(rawLevel === 0) {\n                // We want to exclude the last \"endraw\"\n                str += pre;\n                // Move tokenizer to beginning of endraw block\n                this.tokens.backN(all.length - pre.length);\n            } else {\n                str += all;\n            }\n        }\n\n        return new nodes.Output(\n            begun.lineno,\n            begun.colno,\n            [new nodes.TemplateData(begun.lineno, begun.colno, str)]\n        );\n    },\n\n    parsePostfix: function(node) {\n        var lookup, tok = this.peekToken();\n\n        while(tok) {\n            if(tok.type === lexer.TOKEN_LEFT_PAREN) {\n                // Function call\n                node = new nodes.FunCall(tok.lineno,\n                                         tok.colno,\n                                         node,\n                                         this.parseSignature());\n            }\n            else if(tok.type === lexer.TOKEN_LEFT_BRACKET) {\n                // Reference\n                lookup = this.parseAggregate();\n                if(lookup.children.length > 1) {\n                    this.fail('invalid index');\n                }\n\n                node =  new nodes.LookupVal(tok.lineno,\n                                            tok.colno,\n                                            node,\n                                            lookup.children[0]);\n            }\n            else if(tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {\n                // Reference\n                this.nextToken();\n                var val = this.nextToken();\n\n                if(val.type !== lexer.TOKEN_SYMBOL) {\n                    this.fail('expected name as lookup value, got ' + val.value,\n                              val.lineno,\n                              val.colno);\n                }\n\n                // Make a literal string because it's not a variable\n                // reference\n                lookup = new nodes.Literal(val.lineno,\n                                               val.colno,\n                                               val.value);\n\n                node =  new nodes.LookupVal(tok.lineno,\n                                            tok.colno,\n                                            node,\n                                            lookup);\n            }\n            else {\n                break;\n            }\n\n            tok = this.peekToken();\n        }\n\n        return node;\n    },\n\n    parseExpression: function() {\n        var node = this.parseInlineIf();\n        return node;\n    },\n\n    parseInlineIf: function() {\n        var node = this.parseOr();\n        if(this.skipSymbol('if')) {\n            var cond_node = this.parseOr();\n            var body_node = node;\n            node = new nodes.InlineIf(node.lineno, node.colno);\n            node.body = body_node;\n            node.cond = cond_node;\n            if(this.skipSymbol('else')) {\n                node.else_ = this.parseOr();\n            } else {\n                node.else_ = null;\n            }\n        }\n\n        return node;\n    },\n\n    parseOr: function() {\n        var node = this.parseAnd();\n        while(this.skipSymbol('or')) {\n            var node2 = this.parseAnd();\n            node = new nodes.Or(node.lineno,\n                                node.colno,\n                                node,\n                                node2);\n        }\n        return node;\n    },\n\n    parseAnd: function() {\n        var node = this.parseNot();\n        while(this.skipSymbol('and')) {\n            var node2 = this.parseNot();\n            node = new nodes.And(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseNot: function() {\n        var tok = this.peekToken();\n        if(this.skipSymbol('not')) {\n            return new nodes.Not(tok.lineno,\n                                 tok.colno,\n                                 this.parseNot());\n        }\n        return this.parseIn();\n    },\n\n    parseIn: function() {\n      var node = this.parseCompare();\n      while(1) {\n        // check if the next token is 'not'\n        var tok = this.nextToken();\n        if (!tok) { break; }\n        var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not';\n        // if it wasn't 'not', put it back\n        if (!invert) { this.pushToken(tok); }\n        if (this.skipSymbol('in')) {\n          var node2 = this.parseCompare();\n          node = new nodes.In(node.lineno,\n                              node.colno,\n                              node,\n                              node2);\n          if (invert) {\n            node = new nodes.Not(node.lineno,\n                                 node.colno,\n                                 node);\n          }\n        }\n        else {\n          // if we'd found a 'not' but this wasn't an 'in', put back the 'not'\n          if (invert) { this.pushToken(tok); }\n          break;\n        }\n      }\n      return node;\n    },\n\n    parseCompare: function() {\n        var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];\n        var expr = this.parseConcat();\n        var ops = [];\n\n        while(1) {\n            var tok = this.nextToken();\n\n            if(!tok) {\n                break;\n            }\n            else if(lib.indexOf(compareOps, tok.value) !== -1) {\n                ops.push(new nodes.CompareOperand(tok.lineno,\n                                                  tok.colno,\n                                                  this.parseConcat(),\n                                                  tok.value));\n            }\n            else {\n                this.pushToken(tok);\n                break;\n            }\n        }\n\n        if(ops.length) {\n            return new nodes.Compare(ops[0].lineno,\n                                     ops[0].colno,\n                                     expr,\n                                     ops);\n        }\n        else {\n            return expr;\n        }\n    },\n\n    // finds the '~' for string concatenation\n    parseConcat: function(){\n        var node = this.parseAdd();\n        while(this.skipValue(lexer.TOKEN_TILDE, '~')) {\n            var node2 = this.parseAdd();\n            node = new nodes.Concat(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseAdd: function() {\n        var node = this.parseSub();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {\n            var node2 = this.parseSub();\n            node = new nodes.Add(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseSub: function() {\n        var node = this.parseMul();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {\n            var node2 = this.parseMul();\n            node = new nodes.Sub(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseMul: function() {\n        var node = this.parseDiv();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '*')) {\n            var node2 = this.parseDiv();\n            node = new nodes.Mul(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseDiv: function() {\n        var node = this.parseFloorDiv();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '/')) {\n            var node2 = this.parseFloorDiv();\n            node = new nodes.Div(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseFloorDiv: function() {\n        var node = this.parseMod();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '//')) {\n            var node2 = this.parseMod();\n            node = new nodes.FloorDiv(node.lineno,\n                                      node.colno,\n                                      node,\n                                      node2);\n        }\n        return node;\n    },\n\n    parseMod: function() {\n        var node = this.parsePow();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '%')) {\n            var node2 = this.parsePow();\n            node = new nodes.Mod(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parsePow: function() {\n        var node = this.parseUnary();\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '**')) {\n            var node2 = this.parseUnary();\n            node = new nodes.Pow(node.lineno,\n                                 node.colno,\n                                 node,\n                                 node2);\n        }\n        return node;\n    },\n\n    parseUnary: function(noFilters) {\n        var tok = this.peekToken();\n        var node;\n\n        if(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {\n            node = new nodes.Neg(tok.lineno,\n                                 tok.colno,\n                                 this.parseUnary(true));\n        }\n        else if(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {\n            node = new nodes.Pos(tok.lineno,\n                                 tok.colno,\n                                 this.parseUnary(true));\n        }\n        else {\n            node = this.parsePrimary();\n        }\n\n        if(!noFilters) {\n            node = this.parseFilter(node);\n        }\n\n        return node;\n    },\n\n    parsePrimary: function (noPostfix) {\n        var tok = this.nextToken();\n        var val;\n        var node = null;\n\n        if(!tok) {\n            this.fail('expected expression, got end of file');\n        }\n        else if(tok.type === lexer.TOKEN_STRING) {\n            val = tok.value;\n        }\n        else if(tok.type === lexer.TOKEN_INT) {\n            val = parseInt(tok.value, 10);\n        }\n        else if(tok.type === lexer.TOKEN_FLOAT) {\n            val = parseFloat(tok.value);\n        }\n        else if(tok.type === lexer.TOKEN_BOOLEAN) {\n            if(tok.value === 'true') {\n                val = true;\n            }\n            else if(tok.value === 'false') {\n                val = false;\n            }\n            else {\n                this.fail('invalid boolean: ' + tok.value,\n                          tok.lineno,\n                          tok.colno);\n            }\n        }\n        else if(tok.type === lexer.TOKEN_NONE) {\n            val = null;\n        }\n        else if (tok.type === lexer.TOKEN_REGEX) {\n            val = new RegExp(tok.value.body, tok.value.flags);\n        }\n\n        if(val !== undefined) {\n            node = new nodes.Literal(tok.lineno, tok.colno, val);\n        }\n        else if(tok.type === lexer.TOKEN_SYMBOL) {\n            node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);\n\n            if(!noPostfix) {\n                node = this.parsePostfix(node);\n            }\n        }\n        else {\n            // See if it's an aggregate type, we need to push the\n            // current delimiter token back on\n            this.pushToken(tok);\n            node = this.parseAggregate();\n        }\n\n        if(node) {\n            return node;\n        }\n        else {\n            this.fail('unexpected token: ' + tok.value,\n                      tok.lineno,\n                      tok.colno);\n        }\n    },\n\n    parseFilterName: function() {\n        var tok = this.expect(lexer.TOKEN_SYMBOL);\n        var name = tok.value;\n\n        while(this.skipValue(lexer.TOKEN_OPERATOR, '.')) {\n            name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;\n        }\n\n        return new nodes.Symbol(tok.lineno, tok.colno, name);\n    },\n\n    parseFilterArgs: function(node) {\n        if(this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {\n            // Get a FunCall node and add the parameters to the\n            // filter\n            var call = this.parsePostfix(node);\n            return call.args.children;\n        }\n        return [];\n    },\n\n    parseFilter: function(node) {\n        while(this.skip(lexer.TOKEN_PIPE)) {\n            var name = this.parseFilterName();\n\n            node = new nodes.Filter(\n                name.lineno,\n                name.colno,\n                name,\n                new nodes.NodeList(\n                    name.lineno,\n                    name.colno,\n                    [node].concat(this.parseFilterArgs(node))\n                )\n            );\n        }\n\n        return node;\n    },\n\n    parseFilterStatement: function() {\n        var filterTok = this.peekToken();\n        if(!this.skipSymbol('filter')) {\n            this.fail('parseFilterStatement: expected filter');\n        }\n\n        var name = this.parseFilterName();\n        var args = this.parseFilterArgs(name);\n\n        this.advanceAfterBlockEnd(filterTok.value);\n        var body = new nodes.Capture(\n            name.lineno,\n            name.colno,\n            this.parseUntilBlocks('endfilter')\n        );\n        this.advanceAfterBlockEnd();\n\n        var node = new nodes.Filter(\n            name.lineno,\n            name.colno,\n            name,\n            new nodes.NodeList(\n                name.lineno,\n                name.colno,\n                [body].concat(args)\n            )\n        );\n\n        return new nodes.Output(\n            name.lineno,\n            name.colno,\n            [node]\n        );\n    },\n\n    parseAggregate: function() {\n        var tok = this.nextToken();\n        var node;\n\n        switch(tok.type) {\n        case lexer.TOKEN_LEFT_PAREN:\n            node = new nodes.Group(tok.lineno, tok.colno); break;\n        case lexer.TOKEN_LEFT_BRACKET:\n            node = new nodes.Array(tok.lineno, tok.colno); break;\n        case lexer.TOKEN_LEFT_CURLY:\n            node = new nodes.Dict(tok.lineno, tok.colno); break;\n        default:\n            return null;\n        }\n\n        while(1) {\n            var type = this.peekToken().type;\n            if(type === lexer.TOKEN_RIGHT_PAREN ||\n               type === lexer.TOKEN_RIGHT_BRACKET ||\n               type === lexer.TOKEN_RIGHT_CURLY) {\n                this.nextToken();\n                break;\n            }\n\n            if(node.children.length > 0) {\n                if(!this.skip(lexer.TOKEN_COMMA)) {\n                    this.fail('parseAggregate: expected comma after expression',\n                              tok.lineno,\n                              tok.colno);\n                }\n            }\n\n            if(node instanceof nodes.Dict) {\n                // TODO: check for errors\n                var key = this.parsePrimary();\n\n                // We expect a key/value pair for dicts, separated by a\n                // colon\n                if(!this.skip(lexer.TOKEN_COLON)) {\n                    this.fail('parseAggregate: expected colon after dict key',\n                        tok.lineno,\n                        tok.colno);\n                }\n\n                // TODO: check for errors\n                var value = this.parseExpression();\n                node.addChild(new nodes.Pair(key.lineno,\n                                             key.colno,\n                                             key,\n                                             value));\n            }\n            else {\n                // TODO: check for errors\n                var expr = this.parseExpression();\n                node.addChild(expr);\n            }\n        }\n\n        return node;\n    },\n\n    parseSignature: function(tolerant, noParens) {\n        var tok = this.peekToken();\n        if(!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {\n            if(tolerant) {\n                return null;\n            }\n            else {\n                this.fail('expected arguments', tok.lineno, tok.colno);\n            }\n        }\n\n        if(tok.type === lexer.TOKEN_LEFT_PAREN) {\n            tok = this.nextToken();\n        }\n\n        var args = new nodes.NodeList(tok.lineno, tok.colno);\n        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);\n        var checkComma = false;\n\n        while(1) {\n            tok = this.peekToken();\n            if(!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {\n                this.nextToken();\n                break;\n            }\n            else if(noParens && tok.type === lexer.TOKEN_BLOCK_END) {\n                break;\n            }\n\n            if(checkComma && !this.skip(lexer.TOKEN_COMMA)) {\n                this.fail('parseSignature: expected comma after expression',\n                          tok.lineno,\n                          tok.colno);\n            }\n            else {\n                var arg = this.parseExpression();\n\n                if(this.skipValue(lexer.TOKEN_OPERATOR, '=')) {\n                    kwargs.addChild(\n                        new nodes.Pair(arg.lineno,\n                                       arg.colno,\n                                       arg,\n                                       this.parseExpression())\n                    );\n                }\n                else {\n                    args.addChild(arg);\n                }\n            }\n\n            checkComma = true;\n        }\n\n        if(kwargs.children.length) {\n            args.addChild(kwargs);\n        }\n\n        return args;\n    },\n\n    parseUntilBlocks: function(/* blockNames */) {\n        var prev = this.breakOnBlocks;\n        this.breakOnBlocks = lib.toArray(arguments);\n\n        var ret = this.parse();\n\n        this.breakOnBlocks = prev;\n        return ret;\n    },\n\n    parseNodes: function () {\n        var tok;\n        var buf = [];\n\n        while((tok = this.nextToken())) {\n            if(tok.type === lexer.TOKEN_DATA) {\n                var data = tok.value;\n                var nextToken = this.peekToken();\n                var nextVal = nextToken && nextToken.value;\n\n                // If the last token has \"-\" we need to trim the\n                // leading whitespace of the data. This is marked with\n                // the `dropLeadingWhitespace` variable.\n                if(this.dropLeadingWhitespace) {\n                    // TODO: this could be optimized (don't use regex)\n                    data = data.replace(/^\\s*/, '');\n                    this.dropLeadingWhitespace = false;\n                }\n\n                // Same for the succeeding block start token\n                if(nextToken &&\n                    ((nextToken.type === lexer.TOKEN_BLOCK_START &&\n                      nextVal.charAt(nextVal.length - 1) === '-') ||\n                    (nextToken.type === lexer.TOKEN_VARIABLE_START &&\n                      nextVal.charAt(this.tokens.tags.VARIABLE_START.length)\n                        === '-') ||\n                    (nextToken.type === lexer.TOKEN_COMMENT &&\n                      nextVal.charAt(this.tokens.tags.COMMENT_START.length)\n                        === '-'))) {\n                    // TODO: this could be optimized (don't use regex)\n                    data = data.replace(/\\s*$/, '');\n                }\n\n                buf.push(new nodes.Output(tok.lineno,\n                                          tok.colno,\n                                          [new nodes.TemplateData(tok.lineno,\n                                                                  tok.colno,\n                                                                  data)]));\n            }\n            else if(tok.type === lexer.TOKEN_BLOCK_START) {\n                this.dropLeadingWhitespace = false;\n                var n = this.parseStatement();\n                if(!n) {\n                    break;\n                }\n                buf.push(n);\n            }\n            else if(tok.type === lexer.TOKEN_VARIABLE_START) {\n                var e = this.parseExpression();\n                this.dropLeadingWhitespace = false;\n                this.advanceAfterVariableEnd();\n                buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));\n            }\n            else if(tok.type === lexer.TOKEN_COMMENT) {\n                this.dropLeadingWhitespace = tok.value.charAt(\n                    tok.value.length - this.tokens.tags.COMMENT_END.length - 1\n                ) === '-';\n            } else {\n                // Ignore comments, otherwise this should be an error\n                this.fail('Unexpected token at top-level: ' +\n                                tok.type, tok.lineno, tok.colno);\n\n            }\n        }\n\n        return buf;\n    },\n\n    parse: function() {\n        return new nodes.NodeList(0, 0, this.parseNodes());\n    },\n\n    parseAsRoot: function() {\n        return new nodes.Root(0, 0, this.parseNodes());\n    }\n});\n\n// var util = require('util');\n\n// var l = lexer.lex('{%- if x -%}\\n hello {% endif %}');\n// var t;\n// while((t = l.nextToken())) {\n//     console.log(util.inspect(t));\n// }\n\n// var p = new Parser(lexer.lex('hello {% filter title %}' +\n//                              'Hello madam how are you' +\n//                              '{% endfilter %}'));\n// var n = p.parseAsRoot();\n// nodes.printNodes(n);\n\nmodule.exports = {\n    parse: function(src, extensions, opts) {\n        var p = new Parser(lexer.lex(src, opts));\n        if (extensions !== undefined) {\n            p.extensions = extensions;\n        }\n        return p.parseAsRoot();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/lexer.js":"'use strict';\n\nvar lib = require('./lib');\n\nvar whitespaceChars = ' \\n\\t\\r\\u00A0';\nvar delimChars = '()[]{}%*-+~/#,:|.<>=!';\nvar intChars = '0123456789';\n\nvar BLOCK_START = '{%';\nvar BLOCK_END = '%}';\nvar VARIABLE_START = '{{';\nvar VARIABLE_END = '}}';\nvar COMMENT_START = '{#';\nvar COMMENT_END = '#}';\n\nvar TOKEN_STRING = 'string';\nvar TOKEN_WHITESPACE = 'whitespace';\nvar TOKEN_DATA = 'data';\nvar TOKEN_BLOCK_START = 'block-start';\nvar TOKEN_BLOCK_END = 'block-end';\nvar TOKEN_VARIABLE_START = 'variable-start';\nvar TOKEN_VARIABLE_END = 'variable-end';\nvar TOKEN_COMMENT = 'comment';\nvar TOKEN_LEFT_PAREN = 'left-paren';\nvar TOKEN_RIGHT_PAREN = 'right-paren';\nvar TOKEN_LEFT_BRACKET = 'left-bracket';\nvar TOKEN_RIGHT_BRACKET = 'right-bracket';\nvar TOKEN_LEFT_CURLY = 'left-curly';\nvar TOKEN_RIGHT_CURLY = 'right-curly';\nvar TOKEN_OPERATOR = 'operator';\nvar TOKEN_COMMA = 'comma';\nvar TOKEN_COLON = 'colon';\nvar TOKEN_TILDE = 'tilde';\nvar TOKEN_PIPE = 'pipe';\nvar TOKEN_INT = 'int';\nvar TOKEN_FLOAT = 'float';\nvar TOKEN_BOOLEAN = 'boolean';\nvar TOKEN_NONE = 'none';\nvar TOKEN_SYMBOL = 'symbol';\nvar TOKEN_SPECIAL = 'special';\nvar TOKEN_REGEX = 'regex';\n\nfunction token(type, value, lineno, colno) {\n    return {\n        type: type,\n        value: value,\n        lineno: lineno,\n        colno: colno\n    };\n}\n\nfunction Tokenizer(str, opts) {\n    this.str = str;\n    this.index = 0;\n    this.len = str.length;\n    this.lineno = 0;\n    this.colno = 0;\n\n    this.in_code = false;\n\n    opts = opts || {};\n\n    var tags = opts.tags || {};\n    this.tags = {\n        BLOCK_START: tags.blockStart || BLOCK_START,\n        BLOCK_END: tags.blockEnd || BLOCK_END,\n        VARIABLE_START: tags.variableStart || VARIABLE_START,\n        VARIABLE_END: tags.variableEnd || VARIABLE_END,\n        COMMENT_START: tags.commentStart || COMMENT_START,\n        COMMENT_END: tags.commentEnd || COMMENT_END\n    };\n\n    this.trimBlocks = !!opts.trimBlocks;\n    this.lstripBlocks = !!opts.lstripBlocks;\n}\n\nTokenizer.prototype.nextToken = function() {\n    var lineno = this.lineno;\n    var colno = this.colno;\n    var tok;\n\n    if(this.in_code) {\n        // Otherwise, if we are in a block parse it as code\n        var cur = this.current();\n\n        if(this.is_finished()) {\n            // We have nothing else to parse\n            return null;\n        }\n        else if(cur === '\"' || cur === '\\'') {\n            // We've hit a string\n            return token(TOKEN_STRING, this.parseString(cur), lineno, colno);\n        }\n        else if((tok = this._extract(whitespaceChars))) {\n            // We hit some whitespace\n            return token(TOKEN_WHITESPACE, tok, lineno, colno);\n        }\n        else if((tok = this._extractString(this.tags.BLOCK_END)) ||\n                (tok = this._extractString('-' + this.tags.BLOCK_END))) {\n            // Special check for the block end tag\n            //\n            // It is a requirement that start and end tags are composed of\n            // delimiter characters (%{}[] etc), and our code always\n            // breaks on delimiters so we can assume the token parsing\n            // doesn't consume these elsewhere\n            this.in_code = false;\n            if(this.trimBlocks) {\n                cur = this.current();\n                if(cur === '\\n') {\n                    // Skip newline\n                    this.forward();\n                }else if(cur === '\\r'){\n                    // Skip CRLF newline\n                    this.forward();\n                    cur = this.current();\n                    if(cur === '\\n'){\n                        this.forward();\n                    }else{\n                        // Was not a CRLF, so go back\n                        this.back();\n                    }\n                }\n            }\n            return token(TOKEN_BLOCK_END, tok, lineno, colno);\n        }\n        else if((tok = this._extractString(this.tags.VARIABLE_END)) ||\n                (tok = this._extractString('-' + this.tags.VARIABLE_END))) {\n            // Special check for variable end tag (see above)\n            this.in_code = false;\n            return token(TOKEN_VARIABLE_END, tok, lineno, colno);\n        }\n        else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {\n            // Skip past 'r/'.\n            this.forwardN(2);\n\n            // Extract until the end of the regex -- / ends it, \\/ does not.\n            var regexBody = '';\n            while (!this.is_finished()) {\n                if (this.current() === '/' && this.previous() !== '\\\\') {\n                    this.forward();\n                    break;\n                } else {\n                    regexBody += this.current();\n                    this.forward();\n                }\n            }\n\n            // Check for flags.\n            // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n            var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];\n            var regexFlags = '';\n            while (!this.is_finished()) {\n                var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;\n                if (isCurrentAFlag) {\n                    regexFlags += this.current();\n                    this.forward();\n                } else {\n                    break;\n                }\n            }\n\n            return token(TOKEN_REGEX, {body: regexBody, flags: regexFlags}, lineno, colno);\n        }\n        else if(delimChars.indexOf(cur) !== -1) {\n            // We've hit a delimiter (a special char like a bracket)\n            this.forward();\n            var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];\n            var curComplex = cur + this.current();\n            var type;\n\n            if(lib.indexOf(complexOps, curComplex) !== -1) {\n                this.forward();\n                cur = curComplex;\n\n                // See if this is a strict equality/inequality comparator\n                if(lib.indexOf(complexOps, curComplex + this.current()) !== -1) {\n                    cur = curComplex + this.current();\n                    this.forward();\n                }\n            }\n\n            switch(cur) {\n            case '(': type = TOKEN_LEFT_PAREN; break;\n            case ')': type = TOKEN_RIGHT_PAREN; break;\n            case '[': type = TOKEN_LEFT_BRACKET; break;\n            case ']': type = TOKEN_RIGHT_BRACKET; break;\n            case '{': type = TOKEN_LEFT_CURLY; break;\n            case '}': type = TOKEN_RIGHT_CURLY; break;\n            case ',': type = TOKEN_COMMA; break;\n            case ':': type = TOKEN_COLON; break;\n            case '~': type = TOKEN_TILDE; break;\n            case '|': type = TOKEN_PIPE; break;\n            default: type = TOKEN_OPERATOR;\n            }\n\n            return token(type, cur, lineno, colno);\n        }\n        else {\n            // We are not at whitespace or a delimiter, so extract the\n            // text and parse it\n            tok = this._extractUntil(whitespaceChars + delimChars);\n\n            if(tok.match(/^[-+]?[0-9]+$/)) {\n                if(this.current() === '.') {\n                    this.forward();\n                    var dec = this._extract(intChars);\n                    return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);\n                }\n                else {\n                    return token(TOKEN_INT, tok, lineno, colno);\n                }\n            }\n            else if(tok.match(/^(true|false)$/)) {\n                return token(TOKEN_BOOLEAN, tok, lineno, colno);\n            }\n            else if(tok === 'none') {\n                return token(TOKEN_NONE, tok, lineno, colno);\n            }\n            else if(tok) {\n                return token(TOKEN_SYMBOL, tok, lineno, colno);\n            }\n            else {\n                throw new Error('Unexpected value while parsing: ' + tok);\n            }\n        }\n    }\n    else {\n        // Parse out the template text, breaking on tag\n        // delimiters because we need to look for block/variable start\n        // tags (don't use the full delimChars for optimization)\n        var beginChars = (this.tags.BLOCK_START.charAt(0) +\n                          this.tags.VARIABLE_START.charAt(0) +\n                          this.tags.COMMENT_START.charAt(0) +\n                          this.tags.COMMENT_END.charAt(0));\n\n        if(this.is_finished()) {\n            return null;\n        }\n        else if((tok = this._extractString(this.tags.BLOCK_START + '-')) ||\n                (tok = this._extractString(this.tags.BLOCK_START))) {\n            this.in_code = true;\n            return token(TOKEN_BLOCK_START, tok, lineno, colno);\n        }\n        else if((tok = this._extractString(this.tags.VARIABLE_START + '-')) ||\n                (tok = this._extractString(this.tags.VARIABLE_START))) {\n            this.in_code = true;\n            return token(TOKEN_VARIABLE_START, tok, lineno, colno);\n        }\n        else {\n            tok = '';\n            var data;\n            var in_comment = false;\n\n            if(this._matches(this.tags.COMMENT_START)) {\n                in_comment = true;\n                tok = this._extractString(this.tags.COMMENT_START);\n            }\n\n            // Continually consume text, breaking on the tag delimiter\n            // characters and checking to see if it's a start tag.\n            //\n            // We could hit the end of the template in the middle of\n            // our looping, so check for the null return value from\n            // _extractUntil\n            while((data = this._extractUntil(beginChars)) !== null) {\n                tok += data;\n\n                if((this._matches(this.tags.BLOCK_START) ||\n                    this._matches(this.tags.VARIABLE_START) ||\n                    this._matches(this.tags.COMMENT_START)) &&\n                  !in_comment) {\n                    if(this.lstripBlocks &&\n                        this._matches(this.tags.BLOCK_START) &&\n                        this.colno > 0 &&\n                        this.colno <= tok.length) {\n                        var lastLine = tok.slice(-this.colno);\n                        if(/^\\s+$/.test(lastLine)) {\n                            // Remove block leading whitespace from beginning of the string\n                            tok = tok.slice(0, -this.colno);\n                            if(!tok.length) {\n                                // All data removed, collapse to avoid unnecessary nodes\n                                // by returning next token (block start)\n                                return this.nextToken();\n                            }\n                        }\n                    }\n                    // If it is a start tag, stop looping\n                    break;\n                }\n                else if(this._matches(this.tags.COMMENT_END)) {\n                    if(!in_comment) {\n                        throw new Error('unexpected end of comment');\n                    }\n                    tok += this._extractString(this.tags.COMMENT_END);\n                    break;\n                }\n                else {\n                    // It does not match any tag, so add the character and\n                    // carry on\n                    tok += this.current();\n                    this.forward();\n                }\n            }\n\n            if(data === null && in_comment) {\n                throw new Error('expected end of comment, got end of file');\n            }\n\n            return token(in_comment ? TOKEN_COMMENT : TOKEN_DATA,\n                         tok,\n                         lineno,\n                         colno);\n        }\n    }\n\n    throw new Error('Could not parse text');\n};\n\nTokenizer.prototype.parseString = function(delimiter) {\n    this.forward();\n\n    var str = '';\n\n    while(!this.is_finished() && this.current() !== delimiter) {\n        var cur = this.current();\n\n        if(cur === '\\\\') {\n            this.forward();\n            switch(this.current()) {\n            case 'n': str += '\\n'; break;\n            case 't': str += '\\t'; break;\n            case 'r': str += '\\r'; break;\n            default:\n                str += this.current();\n            }\n            this.forward();\n        }\n        else {\n            str += cur;\n            this.forward();\n        }\n    }\n\n    this.forward();\n    return str;\n};\n\nTokenizer.prototype._matches = function(str) {\n    if(this.index + str.length > this.len) {\n        return null;\n    }\n\n    var m = this.str.slice(this.index, this.index + str.length);\n    return m === str;\n};\n\nTokenizer.prototype._extractString = function(str) {\n    if(this._matches(str)) {\n        this.index += str.length;\n        return str;\n    }\n    return null;\n};\n\nTokenizer.prototype._extractUntil = function(charString) {\n    // Extract all non-matching chars, with the default matching set\n    // to everything\n    return this._extractMatching(true, charString || '');\n};\n\nTokenizer.prototype._extract = function(charString) {\n    // Extract all matching chars (no default, so charString must be\n    // explicit)\n    return this._extractMatching(false, charString);\n};\n\nTokenizer.prototype._extractMatching = function (breakOnMatch, charString) {\n    // Pull out characters until a breaking char is hit.\n    // If breakOnMatch is false, a non-matching char stops it.\n    // If breakOnMatch is true, a matching char stops it.\n\n    if(this.is_finished()) {\n        return null;\n    }\n\n    var first = charString.indexOf(this.current());\n\n    // Only proceed if the first character doesn't meet our condition\n    if((breakOnMatch && first === -1) ||\n       (!breakOnMatch && first !== -1)) {\n        var t = this.current();\n        this.forward();\n\n        // And pull out all the chars one at a time until we hit a\n        // breaking char\n        var idx = charString.indexOf(this.current());\n\n        while(((breakOnMatch && idx === -1) ||\n               (!breakOnMatch && idx !== -1)) && !this.is_finished()) {\n            t += this.current();\n            this.forward();\n\n            idx = charString.indexOf(this.current());\n        }\n\n        return t;\n    }\n\n    return '';\n};\n\nTokenizer.prototype._extractRegex = function(regex) {\n    var matches = this.currentStr().match(regex);\n    if(!matches) {\n        return null;\n    }\n\n    // Move forward whatever was matched\n    this.forwardN(matches[0].length);\n\n    return matches;\n};\n\nTokenizer.prototype.is_finished = function() {\n    return this.index >= this.len;\n};\n\nTokenizer.prototype.forwardN = function(n) {\n    for(var i=0; i<n; i++) {\n        this.forward();\n    }\n};\n\nTokenizer.prototype.forward = function() {\n    this.index++;\n\n    if(this.previous() === '\\n') {\n        this.lineno++;\n        this.colno = 0;\n    }\n    else {\n        this.colno++;\n    }\n};\n\nTokenizer.prototype.backN = function(n) {\n    for(var i=0; i<n; i++) {\n        this.back();\n    }\n};\n\nTokenizer.prototype.back = function() {\n    this.index--;\n\n    if(this.current() === '\\n') {\n        this.lineno--;\n\n        var idx = this.src.lastIndexOf('\\n', this.index-1);\n        if(idx === -1) {\n            this.colno = this.index;\n        }\n        else {\n            this.colno = this.index - idx;\n        }\n    }\n    else {\n        this.colno--;\n    }\n};\n\n// current returns current character\nTokenizer.prototype.current = function() {\n    if(!this.is_finished()) {\n        return this.str.charAt(this.index);\n    }\n    return '';\n};\n\n// currentStr returns what's left of the unparsed string\nTokenizer.prototype.currentStr = function() {\n    if(!this.is_finished()) {\n        return this.str.substr(this.index);\n    }\n    return '';\n};\n\nTokenizer.prototype.previous = function() {\n    return this.str.charAt(this.index-1);\n};\n\nmodule.exports = {\n    lex: function(src, opts) {\n        return new Tokenizer(src, opts);\n    },\n\n    TOKEN_STRING: TOKEN_STRING,\n    TOKEN_WHITESPACE: TOKEN_WHITESPACE,\n    TOKEN_DATA: TOKEN_DATA,\n    TOKEN_BLOCK_START: TOKEN_BLOCK_START,\n    TOKEN_BLOCK_END: TOKEN_BLOCK_END,\n    TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,\n    TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,\n    TOKEN_COMMENT: TOKEN_COMMENT,\n    TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,\n    TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,\n    TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,\n    TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,\n    TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,\n    TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,\n    TOKEN_OPERATOR: TOKEN_OPERATOR,\n    TOKEN_COMMA: TOKEN_COMMA,\n    TOKEN_COLON: TOKEN_COLON,\n    TOKEN_TILDE: TOKEN_TILDE,\n    TOKEN_PIPE: TOKEN_PIPE,\n    TOKEN_INT: TOKEN_INT,\n    TOKEN_FLOAT: TOKEN_FLOAT,\n    TOKEN_BOOLEAN: TOKEN_BOOLEAN,\n    TOKEN_NONE: TOKEN_NONE,\n    TOKEN_SYMBOL: TOKEN_SYMBOL,\n    TOKEN_SPECIAL: TOKEN_SPECIAL,\n    TOKEN_REGEX: TOKEN_REGEX\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/nodes.js":"'use strict';\n\nvar lib = require('./lib');\n// jshint -W079\nvar Object = require('./object');\n\nfunction traverseAndCheck(obj, type, results) {\n    if(obj instanceof type) {\n        results.push(obj);\n    }\n\n    if(obj instanceof Node) {\n        obj.findAll(type, results);\n    }\n}\n\nvar Node = Object.extend('Node', {\n    init: function(lineno, colno) {\n        this.lineno = lineno;\n        this.colno = colno;\n\n        var fields = this.fields;\n        for(var i = 0, l = fields.length; i < l; i++) {\n            var field = fields[i];\n\n            // The first two args are line/col numbers, so offset by 2\n            var val = arguments[i + 2];\n\n            // Fields should never be undefined, but null. It makes\n            // testing easier to normalize values.\n            if(val === undefined) {\n                val = null;\n            }\n\n            this[field] = val;\n        }\n    },\n\n    findAll: function(type, results) {\n        results = results || [];\n\n        var i, l;\n        if(this instanceof NodeList) {\n            var children = this.children;\n\n            for(i = 0, l = children.length; i < l; i++) {\n                traverseAndCheck(children[i], type, results);\n            }\n        }\n        else {\n            var fields = this.fields;\n\n            for(i = 0, l = fields.length; i < l; i++) {\n                traverseAndCheck(this[fields[i]], type, results);\n            }\n        }\n\n        return results;\n    },\n\n    iterFields: function(func) {\n        lib.each(this.fields, function(field) {\n            func(this[field], field);\n        }, this);\n    }\n});\n\n// Abstract nodes\nvar Value = Node.extend('Value', { fields: ['value'] });\n\n// Concrete nodes\nvar NodeList = Node.extend('NodeList', {\n    fields: ['children'],\n\n    init: function(lineno, colno, nodes) {\n        this.parent(lineno, colno, nodes || []);\n    },\n\n    addChild: function(node) {\n        this.children.push(node);\n    }\n});\n\nvar Root = NodeList.extend('Root');\nvar Literal = Value.extend('Literal');\nvar Symbol = Value.extend('Symbol');\nvar Group = NodeList.extend('Group');\nvar Array = NodeList.extend('Array');\nvar Pair = Node.extend('Pair', { fields: ['key', 'value'] });\nvar Dict = NodeList.extend('Dict');\nvar LookupVal = Node.extend('LookupVal', { fields: ['target', 'val'] });\nvar If = Node.extend('If', { fields: ['cond', 'body', 'else_'] });\nvar IfAsync = If.extend('IfAsync');\nvar InlineIf = Node.extend('InlineIf', { fields: ['cond', 'body', 'else_'] });\nvar For = Node.extend('For', { fields: ['arr', 'name', 'body', 'else_'] });\nvar AsyncEach = For.extend('AsyncEach');\nvar AsyncAll = For.extend('AsyncAll');\nvar Macro = Node.extend('Macro', { fields: ['name', 'args', 'body'] });\nvar Caller = Macro.extend('Caller');\nvar Import = Node.extend('Import', { fields: ['template', 'target', 'withContext'] });\nvar FromImport = Node.extend('FromImport', {\n    fields: ['template', 'names', 'withContext'],\n\n    init: function(lineno, colno, template, names, withContext) {\n        this.parent(lineno, colno,\n                    template,\n                    names || new NodeList(), withContext);\n    }\n});\nvar FunCall = Node.extend('FunCall', { fields: ['name', 'args'] });\nvar Filter = FunCall.extend('Filter');\nvar FilterAsync = Filter.extend('FilterAsync', {\n    fields: ['name', 'args', 'symbol']\n});\nvar KeywordArgs = Dict.extend('KeywordArgs');\nvar Block = Node.extend('Block', { fields: ['name', 'body'] });\nvar Super = Node.extend('Super', { fields: ['blockName', 'symbol'] });\nvar TemplateRef = Node.extend('TemplateRef', { fields: ['template'] });\nvar Extends = TemplateRef.extend('Extends');\nvar Include = Node.extend('Include', { fields: ['template', 'ignoreMissing'] });\nvar Set = Node.extend('Set', { fields: ['targets', 'value'] });\nvar Output = NodeList.extend('Output');\nvar Capture = Node.extend('Capture', { fields: ['body'] });\nvar TemplateData = Literal.extend('TemplateData');\nvar UnaryOp = Node.extend('UnaryOp', { fields: ['target'] });\nvar BinOp = Node.extend('BinOp', { fields: ['left', 'right'] });\nvar In = BinOp.extend('In');\nvar Or = BinOp.extend('Or');\nvar And = BinOp.extend('And');\nvar Not = UnaryOp.extend('Not');\nvar Add = BinOp.extend('Add');\nvar Concat = BinOp.extend('Concat');\nvar Sub = BinOp.extend('Sub');\nvar Mul = BinOp.extend('Mul');\nvar Div = BinOp.extend('Div');\nvar FloorDiv = BinOp.extend('FloorDiv');\nvar Mod = BinOp.extend('Mod');\nvar Pow = BinOp.extend('Pow');\nvar Neg = UnaryOp.extend('Neg');\nvar Pos = UnaryOp.extend('Pos');\nvar Compare = Node.extend('Compare', { fields: ['expr', 'ops'] });\nvar CompareOperand = Node.extend('CompareOperand', {\n    fields: ['expr', 'type']\n});\n\nvar CallExtension = Node.extend('CallExtension', {\n    fields: ['extName', 'prop', 'args', 'contentArgs'],\n\n    init: function(ext, prop, args, contentArgs) {\n        this.extName = ext._name || ext;\n        this.prop = prop;\n        this.args = args || new NodeList();\n        this.contentArgs = contentArgs || [];\n        this.autoescape = ext.autoescape;\n    }\n});\n\nvar CallExtensionAsync = CallExtension.extend('CallExtensionAsync');\n\n// Print the AST in a nicely formatted tree format for debuggin\nfunction printNodes(node, indent) {\n    indent = indent || 0;\n\n    // This is hacky, but this is just a debugging function anyway\n    function print(str, indent, inline) {\n        var lines = str.split('\\n');\n\n        for(var i=0; i<lines.length; i++) {\n            if(lines[i]) {\n                if((inline && i > 0) || !inline) {\n                    for(var j=0; j<indent; j++) {\n                        process.stdout.write(' ');\n                    }\n                }\n            }\n\n            if(i === lines.length-1) {\n                process.stdout.write(lines[i]);\n            }\n            else {\n                process.stdout.write(lines[i] + '\\n');\n            }\n        }\n    }\n\n    print(node.typename + ': ', indent);\n\n    if(node instanceof NodeList) {\n        print('\\n');\n        lib.each(node.children, function(n) {\n            printNodes(n, indent + 2);\n        });\n    }\n    else if(node instanceof CallExtension) {\n        print(node.extName + '.' + node.prop);\n        print('\\n');\n\n        if(node.args) {\n            printNodes(node.args, indent + 2);\n        }\n\n        if(node.contentArgs) {\n            lib.each(node.contentArgs, function(n) {\n                printNodes(n, indent + 2);\n            });\n        }\n    }\n    else {\n        var nodes = null;\n        var props = null;\n\n        node.iterFields(function(val, field) {\n            if(val instanceof Node) {\n                nodes = nodes || {};\n                nodes[field] = val;\n            }\n            else {\n                props = props || {};\n                props[field] = val;\n            }\n        });\n\n        if(props) {\n            print(JSON.stringify(props, null, 2) + '\\n', null, true);\n        }\n        else {\n            print('\\n');\n        }\n\n        if(nodes) {\n            for(var k in nodes) {\n                printNodes(nodes[k], indent + 2);\n            }\n        }\n\n    }\n}\n\n// var t = new NodeList(0, 0,\n//                      [new Value(0, 0, 3),\n//                       new Value(0, 0, 10),\n//                       new Pair(0, 0,\n//                                new Value(0, 0, 'key'),\n//                                new Value(0, 0, 'value'))]);\n// printNodes(t);\n\nmodule.exports = {\n    Node: Node,\n    Root: Root,\n    NodeList: NodeList,\n    Value: Value,\n    Literal: Literal,\n    Symbol: Symbol,\n    Group: Group,\n    Array: Array,\n    Pair: Pair,\n    Dict: Dict,\n    Output: Output,\n    Capture: Capture,\n    TemplateData: TemplateData,\n    If: If,\n    IfAsync: IfAsync,\n    InlineIf: InlineIf,\n    For: For,\n    AsyncEach: AsyncEach,\n    AsyncAll: AsyncAll,\n    Macro: Macro,\n    Caller: Caller,\n    Import: Import,\n    FromImport: FromImport,\n    FunCall: FunCall,\n    Filter: Filter,\n    FilterAsync: FilterAsync,\n    KeywordArgs: KeywordArgs,\n    Block: Block,\n    Super: Super,\n    Extends: Extends,\n    Include: Include,\n    Set: Set,\n    LookupVal: LookupVal,\n    BinOp: BinOp,\n    In: In,\n    Or: Or,\n    And: And,\n    Not: Not,\n    Add: Add,\n    Concat: Concat,\n    Sub: Sub,\n    Mul: Mul,\n    Div: Div,\n    FloorDiv: FloorDiv,\n    Mod: Mod,\n    Pow: Pow,\n    Neg: Neg,\n    Pos: Pos,\n    Compare: Compare,\n    CompareOperand: CompareOperand,\n\n    CallExtension: CallExtension,\n    CallExtensionAsync: CallExtensionAsync,\n\n    printNodes: printNodes\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/transformer.js":"'use strict';\n\nvar nodes = require('./nodes');\nvar lib = require('./lib');\n\nvar sym = 0;\nfunction gensym() {\n    return 'hole_' + sym++;\n}\n\n// copy-on-write version of map\nfunction mapCOW(arr, func) {\n    var res = null;\n\n    for(var i=0; i<arr.length; i++) {\n        var item = func(arr[i]);\n\n        if(item !== arr[i]) {\n            if(!res) {\n                res = arr.slice();\n            }\n\n            res[i] = item;\n        }\n    }\n\n    return res || arr;\n}\n\nfunction walk(ast, func, depthFirst) {\n    if(!(ast instanceof nodes.Node)) {\n        return ast;\n    }\n\n    if(!depthFirst) {\n        var astT = func(ast);\n\n        if(astT && astT !== ast) {\n            return astT;\n        }\n    }\n\n    if(ast instanceof nodes.NodeList) {\n        var children = mapCOW(ast.children, function(node) {\n            return walk(node, func, depthFirst);\n        });\n\n        if(children !== ast.children) {\n            ast = new nodes[ast.typename](ast.lineno, ast.colno, children);\n        }\n    }\n    else if(ast instanceof nodes.CallExtension) {\n        var args = walk(ast.args, func, depthFirst);\n\n        var contentArgs = mapCOW(ast.contentArgs, function(node) {\n            return walk(node, func, depthFirst);\n        });\n\n        if(args !== ast.args || contentArgs !== ast.contentArgs) {\n            ast = new nodes[ast.typename](ast.extName,\n                                          ast.prop,\n                                          args,\n                                          contentArgs);\n        }\n    }\n    else {\n        var props = ast.fields.map(function(field) {\n            return ast[field];\n        });\n\n        var propsT = mapCOW(props, function(prop) {\n            return walk(prop, func, depthFirst);\n        });\n\n        if(propsT !== props) {\n            ast = new nodes[ast.typename](ast.lineno, ast.colno);\n\n            propsT.forEach(function(prop, i) {\n                ast[ast.fields[i]] = prop;\n            });\n        }\n    }\n\n    return depthFirst ? (func(ast) || ast) : ast;\n}\n\nfunction depthWalk(ast, func) {\n    return walk(ast, func, true);\n}\n\nfunction _liftFilters(node, asyncFilters, prop) {\n    var children = [];\n\n    var walked = depthWalk(prop ? node[prop] : node, function(node) {\n        if(node instanceof nodes.Block) {\n            return node;\n        }\n        else if((node instanceof nodes.Filter &&\n                 lib.indexOf(asyncFilters, node.name.value) !== -1) ||\n                node instanceof nodes.CallExtensionAsync) {\n            var symbol = new nodes.Symbol(node.lineno,\n                                          node.colno,\n                                          gensym());\n\n            children.push(new nodes.FilterAsync(node.lineno,\n                                                node.colno,\n                                                node.name,\n                                                node.args,\n                                                symbol));\n            return symbol;\n        }\n    });\n\n    if(prop) {\n        node[prop] = walked;\n    }\n    else {\n        node = walked;\n    }\n\n    if(children.length) {\n        children.push(node);\n\n        return new nodes.NodeList(\n            node.lineno,\n            node.colno,\n            children\n        );\n    }\n    else {\n        return node;\n    }\n}\n\nfunction liftFilters(ast, asyncFilters) {\n    return depthWalk(ast, function(node) {\n        if(node instanceof nodes.Output) {\n            return _liftFilters(node, asyncFilters);\n        }\n        else if(node instanceof nodes.Set) {\n            return _liftFilters(node, asyncFilters, 'value');\n        }\n        else if(node instanceof nodes.For) {\n            return _liftFilters(node, asyncFilters, 'arr');\n        }\n        else if(node instanceof nodes.If) {\n            return _liftFilters(node, asyncFilters, 'cond');\n        }\n        else if(node instanceof nodes.CallExtension) {\n            return _liftFilters(node, asyncFilters, 'args');\n        }\n    });\n}\n\nfunction liftSuper(ast) {\n    return walk(ast, function(blockNode) {\n        if(!(blockNode instanceof nodes.Block)) {\n            return;\n        }\n\n        var hasSuper = false;\n        var symbol = gensym();\n\n        blockNode.body = walk(blockNode.body, function(node) {\n            if(node instanceof nodes.FunCall &&\n               node.name.value === 'super') {\n                hasSuper = true;\n                return new nodes.Symbol(node.lineno, node.colno, symbol);\n            }\n        });\n\n        if(hasSuper) {\n            blockNode.body.children.unshift(new nodes.Super(\n                0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)\n            ));\n        }\n    });\n}\n\nfunction convertStatements(ast) {\n    return depthWalk(ast, function(node) {\n        if(!(node instanceof nodes.If) &&\n           !(node instanceof nodes.For)) {\n            return;\n        }\n\n        var async = false;\n        walk(node, function(node) {\n            if(node instanceof nodes.FilterAsync ||\n               node instanceof nodes.IfAsync ||\n               node instanceof nodes.AsyncEach ||\n               node instanceof nodes.AsyncAll ||\n               node instanceof nodes.CallExtensionAsync) {\n                async = true;\n                // Stop iterating by returning the node\n                return node;\n            }\n        });\n\n        if(async) {\n\t        if(node instanceof nodes.If) {\n                return new nodes.IfAsync(\n                    node.lineno,\n                    node.colno,\n                    node.cond,\n                    node.body,\n                    node.else_\n                );\n            }\n            else if(node instanceof nodes.For) {\n                return new nodes.AsyncEach(\n                    node.lineno,\n                    node.colno,\n                    node.arr,\n                    node.name,\n                    node.body,\n                    node.else_\n                );\n            }\n        }\n    });\n}\n\nfunction cps(ast, asyncFilters) {\n    return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));\n}\n\nfunction transform(ast, asyncFilters) {\n    return cps(ast, asyncFilters || []);\n}\n\n// var parser = require('./parser');\n// var src = 'hello {% foo %}{% endfoo %} end';\n// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);\n// nodes.printNodes(ast);\n\nmodule.exports = {\n    transform: transform\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/runtime.js":"'use strict';\n\nvar lib = require('./lib');\nvar Obj = require('./object');\n\n// Frames keep track of scoping both at compile-time and run-time so\n// we know how to access variables. Block tags can introduce special\n// variables, for example.\nvar Frame = Obj.extend({\n    init: function(parent, isolateWrites) {\n        this.variables = {};\n        this.parent = parent;\n        this.topLevel = false;\n        // if this is true, writes (set) should never propagate upwards past\n        // this frame to its parent (though reads may).\n        this.isolateWrites = isolateWrites;\n    },\n\n    set: function(name, val, resolveUp) {\n        // Allow variables with dots by automatically creating the\n        // nested structure\n        var parts = name.split('.');\n        var obj = this.variables;\n        var frame = this;\n\n        if(resolveUp) {\n            if((frame = this.resolve(parts[0], true))) {\n                frame.set(name, val);\n                return;\n            }\n        }\n\n        for(var i=0; i<parts.length - 1; i++) {\n            var id = parts[i];\n\n            if(!obj[id]) {\n                obj[id] = {};\n            }\n            obj = obj[id];\n        }\n\n        obj[parts[parts.length - 1]] = val;\n    },\n\n    get: function(name) {\n        var val = this.variables[name];\n        if(val !== undefined) {\n            return val;\n        }\n        return null;\n    },\n\n    lookup: function(name) {\n        var p = this.parent;\n        var val = this.variables[name];\n        if(val !== undefined) {\n            return val;\n        }\n        return p && p.lookup(name);\n    },\n\n    resolve: function(name, forWrite) {\n        var p = (forWrite && this.isolateWrites) ? undefined : this.parent;\n        var val = this.variables[name];\n        if(val !== undefined) {\n            return this;\n        }\n        return p && p.resolve(name);\n    },\n\n    push: function(isolateWrites) {\n        return new Frame(this, isolateWrites);\n    },\n\n    pop: function() {\n        return this.parent;\n    }\n});\n\nfunction makeMacro(argNames, kwargNames, func) {\n    return function() {\n        var argCount = numArgs(arguments);\n        var args;\n        var kwargs = getKeywordArgs(arguments);\n        var i;\n\n        if(argCount > argNames.length) {\n            args = Array.prototype.slice.call(arguments, 0, argNames.length);\n\n            // Positional arguments that should be passed in as\n            // keyword arguments (essentially default values)\n            var vals = Array.prototype.slice.call(arguments, args.length, argCount);\n            for(i = 0; i < vals.length; i++) {\n                if(i < kwargNames.length) {\n                    kwargs[kwargNames[i]] = vals[i];\n                }\n            }\n\n            args.push(kwargs);\n        }\n        else if(argCount < argNames.length) {\n            args = Array.prototype.slice.call(arguments, 0, argCount);\n\n            for(i = argCount; i < argNames.length; i++) {\n                var arg = argNames[i];\n\n                // Keyword arguments that should be passed as\n                // positional arguments, i.e. the caller explicitly\n                // used the name of a positional arg\n                args.push(kwargs[arg]);\n                delete kwargs[arg];\n            }\n\n            args.push(kwargs);\n        }\n        else {\n            args = arguments;\n        }\n\n        return func.apply(this, args);\n    };\n}\n\nfunction makeKeywordArgs(obj) {\n    obj.__keywords = true;\n    return obj;\n}\n\nfunction getKeywordArgs(args) {\n    var len = args.length;\n    if(len) {\n        var lastArg = args[len - 1];\n        if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n            return lastArg;\n        }\n    }\n    return {};\n}\n\nfunction numArgs(args) {\n    var len = args.length;\n    if(len === 0) {\n        return 0;\n    }\n\n    var lastArg = args[len - 1];\n    if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n        return len - 1;\n    }\n    else {\n        return len;\n    }\n}\n\n// A SafeString object indicates that the string should not be\n// autoescaped. This happens magically because autoescaping only\n// occurs on primitive string objects.\nfunction SafeString(val) {\n    if(typeof val !== 'string') {\n        return val;\n    }\n\n    this.val = val;\n    this.length = val.length;\n}\n\nSafeString.prototype = Object.create(String.prototype, {\n    length: { writable: true, configurable: true, value: 0 }\n});\nSafeString.prototype.valueOf = function() {\n    return this.val;\n};\nSafeString.prototype.toString = function() {\n    return this.val;\n};\n\nfunction copySafeness(dest, target) {\n    if(dest instanceof SafeString) {\n        return new SafeString(target);\n    }\n    return target.toString();\n}\n\nfunction markSafe(val) {\n    var type = typeof val;\n\n    if(type === 'string') {\n        return new SafeString(val);\n    }\n    else if(type !== 'function') {\n        return val;\n    }\n    else {\n        return function() {\n            var ret = val.apply(this, arguments);\n\n            if(typeof ret === 'string') {\n                return new SafeString(ret);\n            }\n\n            return ret;\n        };\n    }\n}\n\nfunction suppressValue(val, autoescape) {\n    val = (val !== undefined && val !== null) ? val : '';\n\n    if(autoescape && !(val instanceof SafeString)) {\n        val = lib.escape(val.toString());\n    }\n\n    return val;\n}\n\nfunction ensureDefined(val, lineno, colno) {\n    if(val === null || val === undefined) {\n        throw new lib.TemplateError(\n            'attempted to output null or undefined value',\n            lineno + 1,\n            colno + 1\n        );\n    }\n    return val;\n}\n\nfunction memberLookup(obj, val) {\n    obj = obj || {};\n\n    if(typeof obj[val] === 'function') {\n        return function() {\n            return obj[val].apply(obj, arguments);\n        };\n    }\n\n    return obj[val];\n}\n\nfunction callWrap(obj, name, context, args) {\n    if(!obj) {\n        throw new Error('Unable to call `' + name + '`, which is undefined or falsey');\n    }\n    else if(typeof obj !== 'function') {\n        throw new Error('Unable to call `' + name + '`, which is not a function');\n    }\n\n    // jshint validthis: true\n    return obj.apply(context, args);\n}\n\nfunction contextOrFrameLookup(context, frame, name) {\n    var val = frame.lookup(name);\n    return (val !== undefined) ?\n        val :\n        context.lookup(name);\n}\n\nfunction handleError(error, lineno, colno) {\n    if(error.lineno) {\n        return error;\n    }\n    else {\n        return new lib.TemplateError(error, lineno, colno);\n    }\n}\n\nfunction asyncEach(arr, dimen, iter, cb) {\n    if(lib.isArray(arr)) {\n        var len = arr.length;\n\n        lib.asyncIter(arr, function(item, i, next) {\n            switch(dimen) {\n            case 1: iter(item, i, len, next); break;\n            case 2: iter(item[0], item[1], i, len, next); break;\n            case 3: iter(item[0], item[1], item[2], i, len, next); break;\n            default:\n                item.push(i, next);\n                iter.apply(this, item);\n            }\n        }, cb);\n    }\n    else {\n        lib.asyncFor(arr, function(key, val, i, len, next) {\n            iter(key, val, i, len, next);\n        }, cb);\n    }\n}\n\nfunction asyncAll(arr, dimen, func, cb) {\n    var finished = 0;\n    var len, i;\n    var outputArr;\n\n    function done(i, output) {\n        finished++;\n        outputArr[i] = output;\n\n        if(finished === len) {\n            cb(null, outputArr.join(''));\n        }\n    }\n\n    if(lib.isArray(arr)) {\n        len = arr.length;\n        outputArr = new Array(len);\n\n        if(len === 0) {\n            cb(null, '');\n        }\n        else {\n            for(i = 0; i < arr.length; i++) {\n                var item = arr[i];\n\n                switch(dimen) {\n                case 1: func(item, i, len, done); break;\n                case 2: func(item[0], item[1], i, len, done); break;\n                case 3: func(item[0], item[1], item[2], i, len, done); break;\n                default:\n                    item.push(i, done);\n                    // jshint validthis: true\n                    func.apply(this, item);\n                }\n            }\n        }\n    }\n    else {\n        var keys = lib.keys(arr);\n        len = keys.length;\n        outputArr = new Array(len);\n\n        if(len === 0) {\n            cb(null, '');\n        }\n        else {\n            for(i = 0; i < keys.length; i++) {\n                var k = keys[i];\n                func(k, arr[k], i, len, done);\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    Frame: Frame,\n    makeMacro: makeMacro,\n    makeKeywordArgs: makeKeywordArgs,\n    numArgs: numArgs,\n    suppressValue: suppressValue,\n    ensureDefined: ensureDefined,\n    memberLookup: memberLookup,\n    contextOrFrameLookup: contextOrFrameLookup,\n    callWrap: callWrap,\n    handleError: handleError,\n    isArray: lib.isArray,\n    keys: lib.keys,\n    SafeString: SafeString,\n    copySafeness: copySafeness,\n    markSafe: markSafe,\n    asyncEach: asyncEach,\n    asyncAll: asyncAll,\n    inOperator: lib.inOperator\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/filters.js":"'use strict';\n\nvar lib = require('./lib');\nvar r = require('./runtime');\n\nfunction normalize(value, defaultValue) {\n    if(value === null || value === undefined || value === false) {\n        return defaultValue;\n    }\n    return value;\n}\n\nvar filters = {\n    abs: function(n) {\n        return Math.abs(n);\n    },\n\n    batch: function(arr, linecount, fill_with) {\n        var i;\n        var res = [];\n        var tmp = [];\n\n        for(i = 0; i < arr.length; i++) {\n            if(i % linecount === 0 && tmp.length) {\n                res.push(tmp);\n                tmp = [];\n            }\n\n            tmp.push(arr[i]);\n        }\n\n        if(tmp.length) {\n            if(fill_with) {\n                for(i = tmp.length; i < linecount; i++) {\n                    tmp.push(fill_with);\n                }\n            }\n\n            res.push(tmp);\n        }\n\n        return res;\n    },\n\n    capitalize: function(str) {\n        str = normalize(str, '');\n        var ret = str.toLowerCase();\n        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));\n    },\n\n    center: function(str, width) {\n        str = normalize(str, '');\n        width = width || 80;\n\n        if(str.length >= width) {\n            return str;\n        }\n\n        var spaces = width - str.length;\n        var pre = lib.repeat(' ', spaces/2 - spaces % 2);\n        var post = lib.repeat(' ', spaces/2);\n        return r.copySafeness(str, pre + str + post);\n    },\n\n    'default': function(val, def, bool) {\n        if(bool) {\n            return val ? val : def;\n        }\n        else {\n            return (val !== undefined) ? val : def;\n        }\n    },\n\n    dictsort: function(val, case_sensitive, by) {\n        if (!lib.isObject(val)) {\n            throw new lib.TemplateError('dictsort filter: val must be an object');\n        }\n\n        var array = [];\n        for (var k in val) {\n            // deliberately include properties from the object's prototype\n            array.push([k,val[k]]);\n        }\n\n        var si;\n        if (by === undefined || by === 'key') {\n            si = 0;\n        } else if (by === 'value') {\n            si = 1;\n        } else {\n            throw new lib.TemplateError(\n                'dictsort filter: You can only sort by either key or value');\n        }\n\n        array.sort(function(t1, t2) {\n            var a = t1[si];\n            var b = t2[si];\n\n            if (!case_sensitive) {\n                if (lib.isString(a)) {\n                    a = a.toUpperCase();\n                }\n                if (lib.isString(b)) {\n                    b = b.toUpperCase();\n                }\n            }\n\n            return a > b ? 1 : (a === b ? 0 : -1);\n        });\n\n        return array;\n    },\n\n    dump: function(obj, spaces) {\n        return JSON.stringify(obj, null, spaces);\n    },\n\n    escape: function(str) {\n        if(str instanceof r.SafeString) {\n            return str;\n        }\n        str = (str === null || str === undefined) ? '' : str;\n        return r.markSafe(lib.escape(str.toString()));\n    },\n\n    safe: function(str) {\n        if (str instanceof r.SafeString) {\n            return str;\n        }\n        str = (str === null || str === undefined) ? '' : str;\n        return r.markSafe(str.toString());\n    },\n\n    first: function(arr) {\n        return arr[0];\n    },\n\n    groupby: function(arr, attr) {\n        return lib.groupBy(arr, attr);\n    },\n\n    indent: function(str, width, indentfirst) {\n        str = normalize(str, '');\n\n        if (str === '') return '';\n\n        width = width || 4;\n        var res = '';\n        var lines = str.split('\\n');\n        var sp = lib.repeat(' ', width);\n\n        for(var i=0; i<lines.length; i++) {\n            if(i === 0 && !indentfirst) {\n                res += lines[i] + '\\n';\n            }\n            else {\n                res += sp + lines[i] + '\\n';\n            }\n        }\n\n        return r.copySafeness(str, res);\n    },\n\n    join: function(arr, del, attr) {\n        del = del || '';\n\n        if(attr) {\n            arr = lib.map(arr, function(v) {\n                return v[attr];\n            });\n        }\n\n        return arr.join(del);\n    },\n\n    last: function(arr) {\n        return arr[arr.length-1];\n    },\n\n    length: function(val) {\n        var value = normalize(val, '');\n\n        if(value !== undefined) {\n            if(\n                (typeof Map === 'function' && value instanceof Map) ||\n                (typeof Set === 'function' && value instanceof Set)\n            ) {\n                // ECMAScript 2015 Maps and Sets\n                return value.size;\n            }\n            if(lib.isObject(value) && !(value instanceof r.SafeString)) {\n                // Objects (besides SafeStrings), non-primative Arrays\n                return Object.keys(value).length;\n            }\n            return value.length;\n        }\n        return 0;\n    },\n\n    list: function(val) {\n        if(lib.isString(val)) {\n            return val.split('');\n        }\n        else if(lib.isObject(val)) {\n            var keys = [];\n\n            if(Object.keys) {\n                keys = Object.keys(val);\n            }\n            else {\n                for(var k in val) {\n                    keys.push(k);\n                }\n            }\n\n            return lib.map(keys, function(k) {\n                return { key: k,\n                         value: val[k] };\n            });\n        }\n        else if(lib.isArray(val)) {\n          return val;\n        }\n        else {\n            throw new lib.TemplateError('list filter: type not iterable');\n        }\n    },\n\n    lower: function(str) {\n        str = normalize(str, '');\n        return str.toLowerCase();\n    },\n\n    nl2br: function(str) {\n        if (str === null || str === undefined) {\n            return '';\n        }\n        return r.copySafeness(str, str.replace(/\\r\\n|\\n/g, '<br />\\n'));\n    },\n\n    random: function(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    },\n\n    rejectattr: function(arr, attr) {\n      return arr.filter(function (item) {\n        return !item[attr];\n      });\n    },\n\n    selectattr: function(arr, attr) {\n      return arr.filter(function (item) {\n        return !!item[attr];\n      });\n    },\n\n    replace: function(str, old, new_, maxCount) {\n        var originalStr = str;\n\n        if (old instanceof RegExp) {\n            return str.replace(old, new_);\n        }\n\n        if(typeof maxCount === 'undefined'){\n            maxCount = -1;\n        }\n\n        var res = '';  // Output\n\n        // Cast Numbers in the search term to string\n        if(typeof old === 'number'){\n            old = old + '';\n        }\n        else if(typeof old !== 'string') {\n            // If it is something other than number or string,\n            // return the original string\n            return str;\n        }\n\n        // Cast numbers in the replacement to string\n        if(typeof str === 'number'){\n            str = str + '';\n        }\n\n        // If by now, we don't have a string, throw it back\n        if(typeof str !== 'string' && !(str instanceof r.SafeString)){\n            return str;\n        }\n\n        // ShortCircuits\n        if(old === ''){\n            // Mimic the python behaviour: empty string is replaced\n            // by replacement e.g. \"abc\"|replace(\"\", \".\") -> .a.b.c.\n            res = new_ + str.split('').join(new_) + new_;\n            return r.copySafeness(str, res);\n        }\n\n        var nextIndex = str.indexOf(old);\n        // if # of replacements to perform is 0, or the string to does\n        // not contain the old value, return the string\n        if(maxCount === 0 || nextIndex === -1){\n            return str;\n        }\n\n        var pos = 0;\n        var count = 0; // # of replacements made\n\n        while(nextIndex  > -1 && (maxCount === -1 || count < maxCount)){\n            // Grab the next chunk of src string and add it with the\n            // replacement, to the result\n            res += str.substring(pos, nextIndex) + new_;\n            // Increment our pointer in the src string\n            pos = nextIndex + old.length;\n            count++;\n            // See if there are any more replacements to be made\n            nextIndex = str.indexOf(old, pos);\n        }\n\n        // We've either reached the end, or done the max # of\n        // replacements, tack on any remaining string\n        if(pos < str.length) {\n            res += str.substring(pos);\n        }\n\n        return r.copySafeness(originalStr, res);\n    },\n\n    reverse: function(val) {\n        var arr;\n        if(lib.isString(val)) {\n            arr = filters.list(val);\n        }\n        else {\n            // Copy it\n            arr = lib.map(val, function(v) { return v; });\n        }\n\n        arr.reverse();\n\n        if(lib.isString(val)) {\n            return r.copySafeness(val, arr.join(''));\n        }\n        return arr;\n    },\n\n    round: function(val, precision, method) {\n        precision = precision || 0;\n        var factor = Math.pow(10, precision);\n        var rounder;\n\n        if(method === 'ceil') {\n            rounder = Math.ceil;\n        }\n        else if(method === 'floor') {\n            rounder = Math.floor;\n        }\n        else {\n            rounder = Math.round;\n        }\n\n        return rounder(val * factor) / factor;\n    },\n\n    slice: function(arr, slices, fillWith) {\n        var sliceLength = Math.floor(arr.length / slices);\n        var extra = arr.length % slices;\n        var offset = 0;\n        var res = [];\n\n        for(var i=0; i<slices; i++) {\n            var start = offset + i * sliceLength;\n            if(i < extra) {\n                offset++;\n            }\n            var end = offset + (i + 1) * sliceLength;\n\n            var slice = arr.slice(start, end);\n            if(fillWith && i >= extra) {\n                slice.push(fillWith);\n            }\n            res.push(slice);\n        }\n\n        return res;\n    },\n\n    sum: function(arr, attr, start) {\n        var sum = 0;\n\n        if(typeof start === 'number'){\n            sum += start;\n        }\n\n        if(attr) {\n            arr = lib.map(arr, function(v) {\n                return v[attr];\n            });\n        }\n\n        for(var i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n\n        return sum;\n    },\n\n    sort: r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function(arr, reverse, caseSens, attr) {\n         // Copy it\n        arr = lib.map(arr, function(v) { return v; });\n\n        arr.sort(function(a, b) {\n            var x, y;\n\n            if(attr) {\n                x = a[attr];\n                y = b[attr];\n            }\n            else {\n                x = a;\n                y = b;\n            }\n\n            if(!caseSens && lib.isString(x) && lib.isString(y)) {\n                x = x.toLowerCase();\n                y = y.toLowerCase();\n            }\n\n            if(x < y) {\n                return reverse ? 1 : -1;\n            }\n            else if(x > y) {\n                return reverse ? -1: 1;\n            }\n            else {\n                return 0;\n            }\n        });\n\n        return arr;\n    }),\n\n    string: function(obj) {\n        return r.copySafeness(obj, obj);\n    },\n\n    striptags: function(input, preserve_linebreaks) {\n        input = normalize(input, '');\n        preserve_linebreaks = preserve_linebreaks || false;\n        var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>|<!--[\\s\\S]*?-->/gi;\n        var trimmedInput = filters.trim(input.replace(tags, ''));\n        var res = '';\n        if (preserve_linebreaks) {\n            res = trimmedInput\n                .replace(/^ +| +$/gm, '')     // remove leading and trailing spaces\n                .replace(/ +/g, ' ')          // squash adjacent spaces\n                .replace(/(\\r\\n)/g, '\\n')     // normalize linebreaks (CRLF -> LF)\n                .replace(/\\n\\n\\n+/g, '\\n\\n'); // squash abnormal adjacent linebreaks\n        } else {\n            res = trimmedInput.replace(/\\s+/gi, ' ');\n        }\n        return r.copySafeness(input, res);\n    },\n\n    title: function(str) {\n        str = normalize(str, '');\n        var words = str.split(' ');\n        for(var i = 0; i < words.length; i++) {\n            words[i] = filters.capitalize(words[i]);\n        }\n        return r.copySafeness(str, words.join(' '));\n    },\n\n    trim: function(str) {\n        return r.copySafeness(str, str.replace(/^\\s*|\\s*$/g, ''));\n    },\n\n    truncate: function(input, length, killwords, end) {\n        var orig = input;\n        input = normalize(input, '');\n        length = length || 255;\n\n        if (input.length <= length)\n            return input;\n\n        if (killwords) {\n            input = input.substring(0, length);\n        } else {\n            var idx = input.lastIndexOf(' ', length);\n            if(idx === -1) {\n                idx = length;\n            }\n\n            input = input.substring(0, idx);\n        }\n\n        input += (end !== undefined && end !== null) ? end : '...';\n        return r.copySafeness(orig, input);\n    },\n\n    upper: function(str) {\n        str = normalize(str, '');\n        return str.toUpperCase();\n    },\n\n    urlencode: function(obj) {\n        var enc = encodeURIComponent;\n        if (lib.isString(obj)) {\n            return enc(obj);\n        } else {\n            var parts;\n            if (lib.isArray(obj)) {\n                parts = obj.map(function(item) {\n                    return enc(item[0]) + '=' + enc(item[1]);\n                });\n            } else {\n                parts = [];\n                for (var k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        parts.push(enc(k) + '=' + enc(obj[k]));\n                    }\n                }\n            }\n            return parts.join('&');\n        }\n    },\n\n    urlize: function(str, length, nofollow) {\n        if (isNaN(length)) length = Infinity;\n\n        var noFollowAttr = (nofollow === true ? ' rel=\"nofollow\"' : '');\n\n        // For the jinja regexp, see\n        // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23\n        var puncRE = /^(?:\\(|<|&lt;)?(.*?)(?:\\.|,|\\)|\\n|&gt;)?$/;\n        // from http://blog.gerv.net/2011/05/html5_email_address_regexp/\n        var emailRE = /^[\\w.!#$%&'*+\\-\\/=?\\^`{|}~]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)+$/i;\n        var httpHttpsRE = /^https?:\\/\\/.*$/;\n        var wwwRE = /^www\\./;\n        var tldRE = /\\.(?:org|net|com)(?:\\:|\\/|$)/;\n\n        var words = str.split(/(\\s+)/).filter(function(word) {\n          // If the word has no length, bail. This can happen for str with\n          // trailing whitespace.\n          return word && word.length;\n        }).map(function(word) {\n          var matches = word.match(puncRE);\n          var possibleUrl = matches && matches[1] || word;\n\n          // url that starts with http or https\n          if (httpHttpsRE.test(possibleUrl))\n            return '<a href=\"' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n          // url that starts with www.\n          if (wwwRE.test(possibleUrl))\n            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n          // an email address of the form username@domain.tld\n          if (emailRE.test(possibleUrl))\n            return '<a href=\"mailto:' + possibleUrl + '\">' + possibleUrl + '</a>';\n\n          // url that ends in .com, .org or .net that is not an email address\n          if (tldRE.test(possibleUrl))\n            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n          return word;\n\n        });\n\n        return words.join('');\n    },\n\n    wordcount: function(str) {\n        str = normalize(str, '');\n        var words = (str) ? str.match(/\\w+/g) : null;\n        return (words) ? words.length : null;\n    },\n\n    'float': function(val, def) {\n        var res = parseFloat(val);\n        return isNaN(res) ? def : res;\n    },\n\n    'int': function(val, def) {\n        var res = parseInt(val, 10);\n        return isNaN(res) ? def : res;\n    }\n};\n\n// Aliases\nfilters.d = filters['default'];\nfilters.e = filters.escape;\n\nmodule.exports = filters;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/loaders.js":"// This file will automatically be rewired to web-loader.js when\n// building for the browser\nmodule.exports = require('./node-loaders');\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/node-loaders.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar lib = require('./lib');\nvar Loader = require('./loader');\nvar PrecompiledLoader = require('./precompiled-loader.js');\n\n// Node <0.7.1 compatibility\nvar existsSync = fs.existsSync || path.existsSync;\n\nvar FileSystemLoader = Loader.extend({\n    init: function(searchPaths, opts) {\n        if(typeof opts === 'boolean') {\n            console.log(\n                '[nunjucks] Warning: you passed a boolean as the second ' +\n                'argument to FileSystemLoader, but it now takes an options ' +\n                'object. See http://mozilla.github.io/nunjucks/api.html#filesystemloader'\n            );\n        }\n\n        opts = opts || {};\n        this.pathsToNames = {};\n        this.noCache = !!opts.noCache;\n\n        if(searchPaths) {\n            searchPaths = lib.isArray(searchPaths) ? searchPaths : [searchPaths];\n            // For windows, convert to forward slashes\n            this.searchPaths = searchPaths.map(path.normalize);\n        }\n        else {\n            this.searchPaths = ['.'];\n        }\n\n        if(opts.watch) {\n            // Watch all the templates in the paths and fire an event when\n            // they change\n            var chokidar = require('chokidar');\n            var paths = this.searchPaths.filter(function(p) { return existsSync(p); });\n            var watcher = chokidar.watch(paths);\n            var _this = this;\n            watcher.on('all', function(event, fullname) {\n                fullname = path.resolve(fullname);\n                if(event === 'change' && fullname in _this.pathsToNames) {\n                    _this.emit('update', _this.pathsToNames[fullname]);\n                }\n            });\n            watcher.on('error', function(error) {\n                console.log('Watcher error: ' + error);\n            });\n        }\n    },\n\n    getSource: function(name) {\n        var fullpath = null;\n        var paths = this.searchPaths;\n\n        for(var i=0; i<paths.length; i++) {\n            var basePath = path.resolve(paths[i]);\n            var p = path.resolve(paths[i], name);\n\n            // Only allow the current directory and anything\n            // underneath it to be searched\n            if(p.indexOf(basePath) === 0 && existsSync(p)) {\n                fullpath = p;\n                break;\n            }\n        }\n\n        if(!fullpath) {\n            return null;\n        }\n\n        this.pathsToNames[fullpath] = name;\n\n        return { src: fs.readFileSync(fullpath, 'utf-8'),\n                 path: fullpath,\n                 noCache: this.noCache };\n    }\n});\n\nmodule.exports = {\n    FileSystemLoader: FileSystemLoader,\n    PrecompiledLoader: PrecompiledLoader\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/loader.js":"'use strict';\n\nvar path = require('path');\nvar Obj = require('./object');\nvar lib = require('./lib');\n\nvar Loader = Obj.extend({\n    on: function(name, func) {\n        this.listeners = this.listeners || {};\n        this.listeners[name] = this.listeners[name] || [];\n        this.listeners[name].push(func);\n    },\n\n    emit: function(name /*, arg1, arg2, ...*/) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        if(this.listeners && this.listeners[name]) {\n            lib.each(this.listeners[name], function(listener) {\n                listener.apply(null, args);\n            });\n        }\n    },\n\n    resolve: function(from, to) {\n        return path.resolve(path.dirname(from), to);\n    },\n\n    isRelative: function(filename) {\n        return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);\n    }\n});\n\nmodule.exports = Loader;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/precompiled-loader.js":"'use strict';\n\nvar Loader = require('./loader');\n\nvar PrecompiledLoader = Loader.extend({\n    init: function(compiledTemplates) {\n        this.precompiled = compiledTemplates || {};\n    },\n\n    getSource: function(name) {\n        if (this.precompiled[name]) {\n            return {\n                src: { type: 'code',\n                       obj: this.precompiled[name] },\n                path: name\n            };\n        }\n        return null;\n    }\n});\n\nmodule.exports = PrecompiledLoader;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/globals.js":"'use strict';\n\nfunction cycler(items) {\n    var index = -1;\n\n    return {\n        current: null,\n        reset: function() {\n            index = -1;\n            this.current = null;\n        },\n\n        next: function() {\n            index++;\n            if(index >= items.length) {\n                index = 0;\n            }\n\n            this.current = items[index];\n            return this.current;\n        },\n    };\n\n}\n\nfunction joiner(sep) {\n    sep = sep || ',';\n    var first = true;\n\n    return function() {\n        var val = first ? '' : sep;\n        first = false;\n        return val;\n    };\n}\n\n// Making this a function instead so it returns a new object\n// each time it's called. That way, if something like an environment\n// uses it, they will each have their own copy.\nfunction globals() {\n    return {\n        range: function(start, stop, step) {\n            if(typeof stop === 'undefined') {\n                stop = start;\n                start = 0;\n                step = 1;\n            }\n            else if(!step) {\n                step = 1;\n            }\n\n            var arr = [];\n            var i;\n            if (step > 0) {\n                for (i=start; i<stop; i+=step) {\n                    arr.push(i);\n                }\n            } else {\n                for (i=start; i>stop; i+=step) {\n                    arr.push(i);\n                }\n            }\n            return arr;\n        },\n\n        // lipsum: function(n, html, min, max) {\n        // },\n\n        cycler: function() {\n            return cycler(Array.prototype.slice.call(arguments));\n        },\n\n        joiner: function(sep) {\n            return joiner(sep);\n        }\n    };\n}\n\nmodule.exports = globals;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/precompile.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar lib = require('./lib');\nvar compiler = require('./compiler');\nvar Environment = require('./environment').Environment;\nvar precompileGlobal = require('./precompile-global');\n\nfunction match(filename, patterns) {\n    if (!Array.isArray(patterns)) return false;\n    return patterns.some(function (pattern) {\n        return filename.match(pattern) !== null;\n    });\n}\n\nfunction precompileString(str, opts) {\n    opts = opts || {};\n    opts.isString = true;\n    return precompile(str, opts);\n}\n\nfunction precompile(input, opts) {\n    // The following options are available:\n    //\n    // * name: name of the template (auto-generated when compiling a directory)\n    // * isString: input is a string, not a file path\n    // * asFunction: generate a callable function\n    // * force: keep compiling on error\n    // * env: the Environment to use (gets extensions and async filters from it)\n    // * include: which file/folders to include (folders are auto-included, files are auto-excluded)\n    // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)\n    // * wrapper: function(templates, opts) {...}\n    //       Customize the output format to store the compiled template.\n    //       By default, templates are stored in a global variable used by the runtime.\n    //       A custom loader will be necessary to load your custom wrapper.\n\n    opts = opts || {};\n    var env = opts.env || new Environment([]);\n    var wrapper = opts.wrapper || precompileGlobal;\n\n    var pathStats = fs.existsSync(input) && fs.statSync(input);\n    var precompiled = [];\n    var templates = [];\n\n    function addTemplates(dir) {\n        var files = fs.readdirSync(dir);\n\n        for(var i=0; i<files.length; i++) {\n            var filepath = path.join(dir, files[i]);\n            var subpath = filepath.substr(path.join(input, '/').length);\n            var stat = fs.statSync(filepath);\n\n            if(stat && stat.isDirectory()) {\n                subpath += '/';\n                if (!match(subpath, opts.exclude)) {\n                    addTemplates(filepath);\n                }\n            }\n            else if(match(subpath, opts.include)) {\n                templates.push(filepath);\n            }\n        }\n    }\n\n    if(opts.isString) {\n        if(!opts.name) {\n            throw new Error('the \"name\" option is required when ' +\n                            'compiling a string');\n        }\n\n        precompiled.push( _precompile(\n            input,\n            opts.name,\n            env\n        ) );\n    }\n    else if(pathStats.isFile()) {\n        precompiled.push( _precompile(\n            fs.readFileSync(input, 'utf-8'),\n            opts.name || input,\n            env\n        ) );\n    }\n    else if(pathStats.isDirectory()) {\n        addTemplates(input);\n\n        for(var i=0; i<templates.length; i++) {\n            var name = templates[i].replace(path.join(input, '/'), '');\n\n            try {\n                precompiled.push( _precompile(\n                    fs.readFileSync(templates[i], 'utf-8'),\n                    name,\n                    env\n                ) );\n            } catch(e) {\n                if(opts.force) {\n                    // Don't stop generating the output if we're\n                    // forcing compilation.\n                    console.error(e);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    return wrapper(precompiled, opts);\n}\n\nfunction _precompile(str, name, env) {\n    env = env || new Environment([]);\n\n    var asyncFilters = env.asyncFilters;\n    var extensions = env.extensionsList;\n    var template;\n\n    name = name.replace(/\\\\/g, '/');\n\n    try {\n        template = compiler.compile(str,\n                                    asyncFilters,\n                                    extensions,\n                                    name,\n                                    env.opts);\n    }\n    catch(err) {\n        throw lib.prettifyError(name, false, err);\n    }\n\n    return { name: name, template: template };\n}\n\nmodule.exports = {\n    precompile: precompile,\n    precompileString: precompileString\n};\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/precompile-global.js":"'use strict';\n\nfunction precompileGlobal(templates, opts) {\n    var out = '', name, template;\n    opts = opts || {};\n\n    for ( var i = 0; i < templates.length; i++ ) {\n        name = JSON.stringify(templates[i].name);\n        template = templates[i].template;\n\n        out += '(function() {' +\n            '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' +\n            '[' + name + '] = (function() {\\n' + template + '\\n})();\\n';\n\n        if(opts.asFunction) {\n            out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\\n';\n        }\n\n        out += '})();\\n';\n    }\n    return out;\n}\n\nmodule.exports = precompileGlobal;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/jinja-compat.js":"function installCompat() {\n  'use strict';\n\n  // This must be called like `nunjucks.installCompat` so that `this`\n  // references the nunjucks instance\n  var runtime = this.runtime; // jshint ignore:line\n  var lib = this.lib; // jshint ignore:line\n\n  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;\n  runtime.contextOrFrameLookup = function(context, frame, key) {\n    var val = orig_contextOrFrameLookup.apply(this, arguments);\n    if (val === undefined) {\n      switch (key) {\n      case 'True':\n        return true;\n      case 'False':\n        return false;\n      case 'None':\n        return null;\n      }\n    }\n\n    return val;\n  };\n\n  var orig_memberLookup = runtime.memberLookup;\n  var ARRAY_MEMBERS = {\n    pop: function(index) {\n      if (index === undefined) {\n        return this.pop();\n      }\n      if (index >= this.length || index < 0) {\n        throw new Error('KeyError');\n      }\n      return this.splice(index, 1);\n    },\n    append: function(element) {\n        return this.push(element);\n    },\n    remove: function(element) {\n      for (var i = 0; i < this.length; i++) {\n        if (this[i] === element) {\n          return this.splice(i, 1);\n        }\n      }\n      throw new Error('ValueError');\n    },\n    count: function(element) {\n      var count = 0;\n      for (var i = 0; i < this.length; i++) {\n        if (this[i] === element) {\n          count++;\n        }\n      }\n      return count;\n    },\n    index: function(element) {\n      var i;\n      if ((i = this.indexOf(element)) === -1) {\n        throw new Error('ValueError');\n      }\n      return i;\n    },\n    find: function(element) {\n      return this.indexOf(element);\n    },\n    insert: function(index, elem) {\n      return this.splice(index, 0, elem);\n    }\n  };\n  var OBJECT_MEMBERS = {\n    items: function() {\n      var ret = [];\n      for(var k in this) {\n        ret.push([k, this[k]]);\n      }\n      return ret;\n    },\n    values: function() {\n      var ret = [];\n      for(var k in this) {\n        ret.push(this[k]);\n      }\n      return ret;\n    },\n    keys: function() {\n      var ret = [];\n      for(var k in this) {\n        ret.push(k);\n      }\n      return ret;\n    },\n    get: function(key, def) {\n      var output = this[key];\n      if (output === undefined) {\n        output = def;\n      }\n      return output;\n    },\n    has_key: function(key) {\n      return this.hasOwnProperty(key);\n    },\n    pop: function(key, def) {\n      var output = this[key];\n      if (output === undefined && def !== undefined) {\n        output = def;\n      } else if (output === undefined) {\n        throw new Error('KeyError');\n      } else {\n        delete this[key];\n      }\n      return output;\n    },\n    popitem: function() {\n      for (var k in this) {\n        // Return the first object pair.\n        var val = this[k];\n        delete this[k];\n        return [k, val];\n      }\n      throw new Error('KeyError');\n    },\n    setdefault: function(key, def) {\n      if (key in this) {\n        return this[key];\n      }\n      if (def === undefined) {\n        def = null;\n      }\n      return this[key] = def;\n    },\n    update: function(kwargs) {\n      for (var k in kwargs) {\n        this[k] = kwargs[k];\n      }\n      return null;  // Always returns None\n    }\n  };\n  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;\n  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;\n  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;\n  runtime.memberLookup = function(obj, val, autoescape) { // jshint ignore:line\n    obj = obj || {};\n\n    // If the object is an object, return any of the methods that Python would\n    // otherwise provide.\n    if (lib.isArray(obj) && ARRAY_MEMBERS.hasOwnProperty(val)) {\n      return function() {return ARRAY_MEMBERS[val].apply(obj, arguments);};\n    }\n\n    if (lib.isObject(obj) && OBJECT_MEMBERS.hasOwnProperty(val)) {\n      return function() {return OBJECT_MEMBERS[val].apply(obj, arguments);};\n    }\n\n    return orig_memberLookup.apply(this, arguments);\n  };\n}\n\nmodule.exports = installCompat;\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/bin/bundle.js":"#!/usr/bin/env node\n'use strict';\n\nvar path = require('path');\nvar webpack = require('webpack');\nvar fs = require('fs');\n\nvar VERSION = JSON.parse(fs.readFileSync('./package.json')).version;\nvar TYPE = '';\nvar SLIM = false;\nvar MINIFIED = false;\nvar TARGET = '';\n\nvar args = process.argv.slice(2);\nwhile(args.length > 0) {\n    if(args.length === 1) {\n        TARGET = args[0];\n    }\n    else {\n        switch(args[0]) {\n        case '-s':\n            SLIM = true;\n            TYPE = '(slim, only works with precompiled templates)';\n            break;\n        case '-m':\n            MINIFIED = true;\n            break;\n        }\n    }\n    args.shift();\n}\n\nvar config = {\n    entry: './index.js',\n    output: {\n        path: path.join(__dirname, '../browser'),\n        filename: TARGET,\n        library: 'nunjucks',\n        libraryTarget: 'umd'\n    },\n    node: {\n        process: 'empty'\n    },\n    plugins: [\n        new webpack.NormalModuleReplacementPlugin(/(path|precompile)$/,\n                                                  'node-libs-browser/mock/empty'),\n        new webpack.BannerPlugin(\n            'Browser bundle of nunjucks ' + VERSION + ' ' + TYPE\n        ),\n        new webpack.DefinePlugin({\n            'process.env': {\n                IS_BROWSER: true\n            }\n        })\n    ]\n};\n\nif(SLIM) {\n    config.plugins.push(\n        new webpack.NormalModuleReplacementPlugin(\n            /(nodes|lexer|parser|transformer|compiler|loaders)$/,\n            'node-libs-browser/mock/empty'\n        )\n    );\n}\nelse {\n    config.plugins.push(\n        new webpack.NormalModuleReplacementPlugin(/loaders\\.js$/,\n                                                  './web-loaders.js')\n    );\n}\n\nif(MINIFIED) {\n    config.plugins.push(\n        new webpack.optimize.UglifyJsPlugin({ sourceMap: false })\n    );\n}\n\nvar outputOptions = {\n    cached: false,\n    cachedAssets: false\n};\n\nwebpack(config).run(function (err, stats) {\n    if(err) {\n        throw new Error(err);\n    }\n    console.log(stats.toString(outputOptions));\n});\n","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/browser/nunjucks.js":"/*! Browser bundle of nunjucks 3.0.0  */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nunjucks\"] = factory();\n\telse\n\t\troot[\"nunjucks\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar env = __webpack_require__(2);\n\tvar Loader = __webpack_require__(15);\n\tvar loaders = __webpack_require__(14);\n\tvar precompile = __webpack_require__(3);\n\n\tmodule.exports = {};\n\tmodule.exports.Environment = env.Environment;\n\tmodule.exports.Template = env.Template;\n\n\tmodule.exports.Loader = Loader;\n\tmodule.exports.FileSystemLoader = loaders.FileSystemLoader;\n\tmodule.exports.PrecompiledLoader = loaders.PrecompiledLoader;\n\tmodule.exports.WebLoader = loaders.WebLoader;\n\n\tmodule.exports.compiler = __webpack_require__(7);\n\tmodule.exports.parser = __webpack_require__(8);\n\tmodule.exports.lexer = __webpack_require__(9);\n\tmodule.exports.runtime = __webpack_require__(12);\n\tmodule.exports.lib = lib;\n\tmodule.exports.nodes = __webpack_require__(10);\n\n\tmodule.exports.installJinjaCompat = __webpack_require__(21);\n\n\t// A single instance of an environment, since this is so commonly used\n\n\tvar e;\n\tmodule.exports.configure = function(templatesPath, opts) {\n\t    opts = opts || {};\n\t    if(lib.isObject(templatesPath)) {\n\t        opts = templatesPath;\n\t        templatesPath = null;\n\t    }\n\n\t    var TemplateLoader;\n\t    if(loaders.FileSystemLoader) {\n\t        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {\n\t            watch: opts.watch,\n\t            noCache: opts.noCache\n\t        });\n\t    }\n\t    else if(loaders.WebLoader) {\n\t        TemplateLoader = new loaders.WebLoader(templatesPath, {\n\t            useCache: opts.web && opts.web.useCache,\n\t            async: opts.web && opts.web.async\n\t        });\n\t    }\n\n\t    e = new env.Environment(TemplateLoader, opts);\n\n\t    if(opts && opts.express) {\n\t        e.express(opts.express);\n\t    }\n\n\t    return e;\n\t};\n\n\tmodule.exports.compile = function(src, env, path, eagerCompile) {\n\t    if(!e) {\n\t        module.exports.configure();\n\t    }\n\t    return new module.exports.Template(src, env, path, eagerCompile);\n\t};\n\n\tmodule.exports.render = function(name, ctx, cb) {\n\t    if(!e) {\n\t        module.exports.configure();\n\t    }\n\n\t    return e.render(name, ctx, cb);\n\t};\n\n\tmodule.exports.renderString = function(src, ctx, cb) {\n\t    if(!e) {\n\t        module.exports.configure();\n\t    }\n\n\t    return e.renderString(src, ctx, cb);\n\t};\n\n\tif(precompile) {\n\t    module.exports.precompile = precompile.precompile;\n\t    module.exports.precompileString = precompile.precompileString;\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tvar ArrayProto = Array.prototype;\n\tvar ObjProto = Object.prototype;\n\n\tvar escapeMap = {\n\t    '&': '&amp;',\n\t    '\"': '&quot;',\n\t    '\\'': '&#39;',\n\t    '<': '&lt;',\n\t    '>': '&gt;'\n\t};\n\n\tvar escapeRegex = /[&\"'<>]/g;\n\n\tvar lookupEscape = function(ch) {\n\t    return escapeMap[ch];\n\t};\n\n\tvar exports = module.exports = {};\n\n\texports.prettifyError = function(path, withInternals, err) {\n\t    // jshint -W022\n\t    // http://jslinterrors.com/do-not-assign-to-the-exception-parameter\n\t    if (!err.Update) {\n\t        // not one of ours, cast it\n\t        err = new exports.TemplateError(err);\n\t    }\n\t    err.Update(path);\n\n\t    // Unless they marked the dev flag, show them a trace from here\n\t    if (!withInternals) {\n\t        var old = err;\n\t        err = new Error(old.message);\n\t        err.name = old.name;\n\t    }\n\n\t    return err;\n\t};\n\n\texports.TemplateError = function(message, lineno, colno) {\n\t    var err = this;\n\n\t    if (message instanceof Error) { // for casting regular js errors\n\t        err = message;\n\t        message = message.name + ': ' + message.message;\n\n\t        try {\n\t            if(err.name = '') {}\n\t        }\n\t        catch(e) {\n\t            // If we can't set the name of the error object in this\n\t            // environment, don't use it\n\t            err = this;\n\t        }\n\t    } else {\n\t        if(Error.captureStackTrace) {\n\t            Error.captureStackTrace(err);\n\t        }\n\t    }\n\n\t    err.name = 'Template render error';\n\t    err.message = message;\n\t    err.lineno = lineno;\n\t    err.colno = colno;\n\t    err.firstUpdate = true;\n\n\t    err.Update = function(path) {\n\t        var message = '(' + (path || 'unknown path') + ')';\n\n\t        // only show lineno + colno next to path of template\n\t        // where error occurred\n\t        if (this.firstUpdate) {\n\t            if(this.lineno && this.colno) {\n\t                message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';\n\t            }\n\t            else if(this.lineno) {\n\t                message += ' [Line ' + this.lineno + ']';\n\t            }\n\t        }\n\n\t        message += '\\n ';\n\t        if (this.firstUpdate) {\n\t            message += ' ';\n\t        }\n\n\t        this.message = message + (this.message || '');\n\t        this.firstUpdate = false;\n\t        return this;\n\t    };\n\n\t    return err;\n\t};\n\n\texports.TemplateError.prototype = Error.prototype;\n\n\texports.escape = function(val) {\n\t  return val.replace(escapeRegex, lookupEscape);\n\t};\n\n\texports.isFunction = function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object Function]';\n\t};\n\n\texports.isArray = Array.isArray || function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object Array]';\n\t};\n\n\texports.isString = function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object String]';\n\t};\n\n\texports.isObject = function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object Object]';\n\t};\n\n\texports.groupBy = function(obj, val) {\n\t    var result = {};\n\t    var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };\n\t    for(var i=0; i<obj.length; i++) {\n\t        var value = obj[i];\n\t        var key = iterator(value, i);\n\t        (result[key] || (result[key] = [])).push(value);\n\t    }\n\t    return result;\n\t};\n\n\texports.toArray = function(obj) {\n\t    return Array.prototype.slice.call(obj);\n\t};\n\n\texports.without = function(array) {\n\t    var result = [];\n\t    if (!array) {\n\t        return result;\n\t    }\n\t    var index = -1,\n\t    length = array.length,\n\t    contains = exports.toArray(arguments).slice(1);\n\n\t    while(++index < length) {\n\t        if(exports.indexOf(contains, array[index]) === -1) {\n\t            result.push(array[index]);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\texports.extend = function(obj, obj2) {\n\t    for(var k in obj2) {\n\t        obj[k] = obj2[k];\n\t    }\n\t    return obj;\n\t};\n\n\texports.repeat = function(char_, n) {\n\t    var str = '';\n\t    for(var i=0; i<n; i++) {\n\t        str += char_;\n\t    }\n\t    return str;\n\t};\n\n\texports.each = function(obj, func, context) {\n\t    if(obj == null) {\n\t        return;\n\t    }\n\n\t    if(ArrayProto.each && obj.each === ArrayProto.each) {\n\t        obj.forEach(func, context);\n\t    }\n\t    else if(obj.length === +obj.length) {\n\t        for(var i=0, l=obj.length; i<l; i++) {\n\t            func.call(context, obj[i], i, obj);\n\t        }\n\t    }\n\t};\n\n\texports.map = function(obj, func) {\n\t    var results = [];\n\t    if(obj == null) {\n\t        return results;\n\t    }\n\n\t    if(ArrayProto.map && obj.map === ArrayProto.map) {\n\t        return obj.map(func);\n\t    }\n\n\t    for(var i=0; i<obj.length; i++) {\n\t        results[results.length] = func(obj[i], i);\n\t    }\n\n\t    if(obj.length === +obj.length) {\n\t        results.length = obj.length;\n\t    }\n\n\t    return results;\n\t};\n\n\texports.asyncIter = function(arr, iter, cb) {\n\t    var i = -1;\n\n\t    function next() {\n\t        i++;\n\n\t        if(i < arr.length) {\n\t            iter(arr[i], i, next, cb);\n\t        }\n\t        else {\n\t            cb();\n\t        }\n\t    }\n\n\t    next();\n\t};\n\n\texports.asyncFor = function(obj, iter, cb) {\n\t    var keys = exports.keys(obj);\n\t    var len = keys.length;\n\t    var i = -1;\n\n\t    function next() {\n\t        i++;\n\t        var k = keys[i];\n\n\t        if(i < len) {\n\t            iter(k, obj[k], i, len, next);\n\t        }\n\t        else {\n\t            cb();\n\t        }\n\t    }\n\n\t    next();\n\t};\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill\n\texports.indexOf = Array.prototype.indexOf ?\n\t    function (arr, searchElement, fromIndex) {\n\t        return Array.prototype.indexOf.call(arr, searchElement, fromIndex);\n\t    } :\n\t    function (arr, searchElement, fromIndex) {\n\t        var length = this.length >>> 0; // Hack to convert object.length to a UInt32\n\n\t        fromIndex = +fromIndex || 0;\n\n\t        if(Math.abs(fromIndex) === Infinity) {\n\t            fromIndex = 0;\n\t        }\n\n\t        if(fromIndex < 0) {\n\t            fromIndex += length;\n\t            if (fromIndex < 0) {\n\t                fromIndex = 0;\n\t            }\n\t        }\n\n\t        for(;fromIndex < length; fromIndex++) {\n\t            if (arr[fromIndex] === searchElement) {\n\t                return fromIndex;\n\t            }\n\t        }\n\n\t        return -1;\n\t    };\n\n\tif(!Array.prototype.map) {\n\t    Array.prototype.map = function() {\n\t        throw new Error('map is unimplemented for this js engine');\n\t    };\n\t}\n\n\texports.keys = function(obj) {\n\t    if(Object.prototype.keys) {\n\t        return obj.keys();\n\t    }\n\t    else {\n\t        var keys = [];\n\t        for(var k in obj) {\n\t            if(obj.hasOwnProperty(k)) {\n\t                keys.push(k);\n\t            }\n\t        }\n\t        return keys;\n\t    }\n\t};\n\n\texports.inOperator = function (key, val) {\n\t    if (exports.isArray(val)) {\n\t        return exports.indexOf(val, key) !== -1;\n\t    } else if (exports.isObject(val)) {\n\t        return key in val;\n\t    } else if (exports.isString(val)) {\n\t        return val.indexOf(key) !== -1;\n\t    } else {\n\t        throw new Error('Cannot use \"in\" operator to search for \"'\n\t            + key + '\" in unexpected types.');\n\t    }\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar path = __webpack_require__(3);\n\tvar asap = __webpack_require__(4);\n\tvar lib = __webpack_require__(1);\n\tvar Obj = __webpack_require__(6);\n\tvar compiler = __webpack_require__(7);\n\tvar builtin_filters = __webpack_require__(13);\n\tvar builtin_loaders = __webpack_require__(14);\n\tvar runtime = __webpack_require__(12);\n\tvar globals = __webpack_require__(17);\n\tvar waterfall = __webpack_require__(18);\n\tvar Frame = runtime.Frame;\n\tvar Template;\n\n\t// Unconditionally load in this loader, even if no other ones are\n\t// included (possible in the slim browser build)\n\tbuiltin_loaders.PrecompiledLoader = __webpack_require__(16);\n\n\t// If the user is using the async API, *always* call it\n\t// asynchronously even if the template was synchronous.\n\tfunction callbackAsap(cb, err, res) {\n\t    asap(function() { cb(err, res); });\n\t}\n\n\tvar Environment = Obj.extend({\n\t    init: function(loaders, opts) {\n\t        // The dev flag determines the trace that'll be shown on errors.\n\t        // If set to true, returns the full trace from the error point,\n\t        // otherwise will return trace starting from Template.render\n\t        // (the full trace from within nunjucks may confuse developers using\n\t        //  the library)\n\t        // defaults to false\n\t        opts = this.opts = opts || {};\n\t        this.opts.dev = !!opts.dev;\n\n\t        // The autoescape flag sets global autoescaping. If true,\n\t        // every string variable will be escaped by default.\n\t        // If false, strings can be manually escaped using the `escape` filter.\n\t        // defaults to true\n\t        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;\n\n\t        // If true, this will make the system throw errors if trying\n\t        // to output a null or undefined value\n\t        this.opts.throwOnUndefined = !!opts.throwOnUndefined;\n\t        this.opts.trimBlocks = !!opts.trimBlocks;\n\t        this.opts.lstripBlocks = !!opts.lstripBlocks;\n\n\t        this.loaders = [];\n\n\t        if(!loaders) {\n\t            // The filesystem loader is only available server-side\n\t            if(builtin_loaders.FileSystemLoader) {\n\t                this.loaders = [new builtin_loaders.FileSystemLoader('views')];\n\t            }\n\t            else if(builtin_loaders.WebLoader) {\n\t                this.loaders = [new builtin_loaders.WebLoader('/views')];\n\t            }\n\t        }\n\t        else {\n\t            this.loaders = lib.isArray(loaders) ? loaders : [loaders];\n\t        }\n\n\t        // It's easy to use precompiled templates: just include them\n\t        // before you configure nunjucks and this will automatically\n\t        // pick it up and use it\n\t        if((true) && window.nunjucksPrecompiled) {\n\t            this.loaders.unshift(\n\t                new builtin_loaders.PrecompiledLoader(window.nunjucksPrecompiled)\n\t            );\n\t        }\n\n\t        this.initCache();\n\n\t        this.globals = globals();\n\t        this.filters = {};\n\t        this.asyncFilters = [];\n\t        this.extensions = {};\n\t        this.extensionsList = [];\n\n\t        for(var name in builtin_filters) {\n\t            this.addFilter(name, builtin_filters[name]);\n\t        }\n\t    },\n\n\t    initCache: function() {\n\t        // Caching and cache busting\n\t        lib.each(this.loaders, function(loader) {\n\t            loader.cache = {};\n\n\t            if(typeof loader.on === 'function') {\n\t                loader.on('update', function(template) {\n\t                    loader.cache[template] = null;\n\t                });\n\t            }\n\t        });\n\t    },\n\n\t    addExtension: function(name, extension) {\n\t        extension._name = name;\n\t        this.extensions[name] = extension;\n\t        this.extensionsList.push(extension);\n\t        return this;\n\t    },\n\n\t    removeExtension: function(name) {\n\t        var extension = this.getExtension(name);\n\t        if (!extension) return;\n\n\t        this.extensionsList = lib.without(this.extensionsList, extension);\n\t        delete this.extensions[name];\n\t    },\n\n\t    getExtension: function(name) {\n\t        return this.extensions[name];\n\t    },\n\n\t    hasExtension: function(name) {\n\t        return !!this.extensions[name];\n\t    },\n\n\t    addGlobal: function(name, value) {\n\t        this.globals[name] = value;\n\t        return this;\n\t    },\n\n\t    getGlobal: function(name) {\n\t        if(typeof this.globals[name] === 'undefined') {\n\t            throw new Error('global not found: ' + name);\n\t        }\n\t        return this.globals[name];\n\t    },\n\n\t    addFilter: function(name, func, async) {\n\t        var wrapped = func;\n\n\t        if(async) {\n\t            this.asyncFilters.push(name);\n\t        }\n\t        this.filters[name] = wrapped;\n\t        return this;\n\t    },\n\n\t    getFilter: function(name) {\n\t        if(!this.filters[name]) {\n\t            throw new Error('filter not found: ' + name);\n\t        }\n\t        return this.filters[name];\n\t    },\n\n\t    resolveTemplate: function(loader, parentName, filename) {\n\t        var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;\n\t        return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;\n\t    },\n\n\t    getTemplate: function(name, eagerCompile, parentName, ignoreMissing, cb) {\n\t        var that = this;\n\t        var tmpl = null;\n\t        if(name && name.raw) {\n\t            // this fixes autoescape for templates referenced in symbols\n\t            name = name.raw;\n\t        }\n\n\t        if(lib.isFunction(parentName)) {\n\t            cb = parentName;\n\t            parentName = null;\n\t            eagerCompile = eagerCompile || false;\n\t        }\n\n\t        if(lib.isFunction(eagerCompile)) {\n\t            cb = eagerCompile;\n\t            eagerCompile = false;\n\t        }\n\n\t        if (name instanceof Template) {\n\t             tmpl = name;\n\t        }\n\t        else if(typeof name !== 'string') {\n\t            throw new Error('template names must be a string: ' + name);\n\t        }\n\t        else {\n\t            for (var i = 0; i < this.loaders.length; i++) {\n\t                var _name = this.resolveTemplate(this.loaders[i], parentName, name);\n\t                tmpl = this.loaders[i].cache[_name];\n\t                if (tmpl) break;\n\t            }\n\t        }\n\n\t        if(tmpl) {\n\t            if(eagerCompile) {\n\t                tmpl.compile();\n\t            }\n\n\t            if(cb) {\n\t                cb(null, tmpl);\n\t            }\n\t            else {\n\t                return tmpl;\n\t            }\n\t        } else {\n\t            var syncResult;\n\t            var _this = this;\n\n\t            var createTemplate = function(err, info) {\n\t                if(!info && !err) {\n\t                    if(!ignoreMissing) {\n\t                        err = new Error('template not found: ' + name);\n\t                    }\n\t                }\n\n\t                if (err) {\n\t                    if(cb) {\n\t                        cb(err);\n\t                    }\n\t                    else {\n\t                        throw err;\n\t                    }\n\t                }\n\t                else {\n\t                    var tmpl;\n\t                    if(info) {\n\t                        tmpl = new Template(info.src, _this,\n\t                                            info.path, eagerCompile);\n\n\t                        if(!info.noCache) {\n\t                            info.loader.cache[name] = tmpl;\n\t                        }\n\t                    }\n\t                    else {\n\t                        tmpl = new Template('', _this,\n\t                                            '', eagerCompile);\n\t                    }\n\n\t                    if(cb) {\n\t                        cb(null, tmpl);\n\t                    }\n\t                    else {\n\t                        syncResult = tmpl;\n\t                    }\n\t                }\n\t            };\n\n\t            lib.asyncIter(this.loaders, function(loader, i, next, done) {\n\t                function handle(err, src) {\n\t                    if(err) {\n\t                        done(err);\n\t                    }\n\t                    else if(src) {\n\t                        src.loader = loader;\n\t                        done(null, src);\n\t                    }\n\t                    else {\n\t                        next();\n\t                    }\n\t                }\n\n\t                // Resolve name relative to parentName\n\t                name = that.resolveTemplate(loader, parentName, name);\n\n\t                if(loader.async) {\n\t                    loader.getSource(name, handle);\n\t                }\n\t                else {\n\t                    handle(null, loader.getSource(name));\n\t                }\n\t            }, createTemplate);\n\n\t            return syncResult;\n\t        }\n\t    },\n\n\t    express: function(app) {\n\t        var env = this;\n\n\t        function NunjucksView(name, opts) {\n\t            this.name          = name;\n\t            this.path          = name;\n\t            this.defaultEngine = opts.defaultEngine;\n\t            this.ext           = path.extname(name);\n\t            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');\n\t            if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);\n\t        }\n\n\t        NunjucksView.prototype.render = function(opts, cb) {\n\t          env.render(this.name, opts, cb);\n\t        };\n\n\t        app.set('view', NunjucksView);\n\t        app.set('nunjucksEnv', this);\n\t        return this;\n\t    },\n\n\t    render: function(name, ctx, cb) {\n\t        if(lib.isFunction(ctx)) {\n\t            cb = ctx;\n\t            ctx = null;\n\t        }\n\n\t        // We support a synchronous API to make it easier to migrate\n\t        // existing code to async. This works because if you don't do\n\t        // anything async work, the whole thing is actually run\n\t        // synchronously.\n\t        var syncResult = null;\n\n\t        this.getTemplate(name, function(err, tmpl) {\n\t            if(err && cb) {\n\t                callbackAsap(cb, err);\n\t            }\n\t            else if(err) {\n\t                throw err;\n\t            }\n\t            else {\n\t                syncResult = tmpl.render(ctx, cb);\n\t            }\n\t        });\n\n\t        return syncResult;\n\t    },\n\n\t    renderString: function(src, ctx, opts, cb) {\n\t        if(lib.isFunction(opts)) {\n\t            cb = opts;\n\t            opts = {};\n\t        }\n\t        opts = opts || {};\n\n\t        var tmpl = new Template(src, this, opts.path);\n\t        return tmpl.render(ctx, cb);\n\t    },\n\n\t    waterfall: waterfall\n\t});\n\n\tvar Context = Obj.extend({\n\t    init: function(ctx, blocks, env) {\n\t        // Has to be tied to an environment so we can tap into its globals.\n\t        this.env = env || new Environment();\n\n\t        // Make a duplicate of ctx\n\t        this.ctx = {};\n\t        for(var k in ctx) {\n\t            if(ctx.hasOwnProperty(k)) {\n\t                this.ctx[k] = ctx[k];\n\t            }\n\t        }\n\n\t        this.blocks = {};\n\t        this.exported = [];\n\n\t        for(var name in blocks) {\n\t            this.addBlock(name, blocks[name]);\n\t        }\n\t    },\n\n\t    lookup: function(name) {\n\t        // This is one of the most called functions, so optimize for\n\t        // the typical case where the name isn't in the globals\n\t        if(name in this.env.globals && !(name in this.ctx)) {\n\t            return this.env.globals[name];\n\t        }\n\t        else {\n\t            return this.ctx[name];\n\t        }\n\t    },\n\n\t    setVariable: function(name, val) {\n\t        this.ctx[name] = val;\n\t    },\n\n\t    getVariables: function() {\n\t        return this.ctx;\n\t    },\n\n\t    addBlock: function(name, block) {\n\t        this.blocks[name] = this.blocks[name] || [];\n\t        this.blocks[name].push(block);\n\t        return this;\n\t    },\n\n\t    getBlock: function(name) {\n\t        if(!this.blocks[name]) {\n\t            throw new Error('unknown block \"' + name + '\"');\n\t        }\n\n\t        return this.blocks[name][0];\n\t    },\n\n\t    getSuper: function(env, name, block, frame, runtime, cb) {\n\t        var idx = lib.indexOf(this.blocks[name] || [], block);\n\t        var blk = this.blocks[name][idx + 1];\n\t        var context = this;\n\n\t        if(idx === -1 || !blk) {\n\t            throw new Error('no super block available for \"' + name + '\"');\n\t        }\n\n\t        blk(env, context, frame, runtime, cb);\n\t    },\n\n\t    addExport: function(name) {\n\t        this.exported.push(name);\n\t    },\n\n\t    getExported: function() {\n\t        var exported = {};\n\t        for(var i=0; i<this.exported.length; i++) {\n\t            var name = this.exported[i];\n\t            exported[name] = this.ctx[name];\n\t        }\n\t        return exported;\n\t    }\n\t});\n\n\tTemplate = Obj.extend({\n\t    init: function (src, env, path, eagerCompile) {\n\t        this.env = env || new Environment();\n\n\t        if(lib.isObject(src)) {\n\t            switch(src.type) {\n\t            case 'code': this.tmplProps = src.obj; break;\n\t            case 'string': this.tmplStr = src.obj; break;\n\t            }\n\t        }\n\t        else if(lib.isString(src)) {\n\t            this.tmplStr = src;\n\t        }\n\t        else {\n\t            throw new Error('src must be a string or an object describing ' +\n\t                            'the source');\n\t        }\n\n\t        this.path = path;\n\n\t        if(eagerCompile) {\n\t            var _this = this;\n\t            try {\n\t                _this._compile();\n\t            }\n\t            catch(err) {\n\t                throw lib.prettifyError(this.path, this.env.opts.dev, err);\n\t            }\n\t        }\n\t        else {\n\t            this.compiled = false;\n\t        }\n\t    },\n\n\t    render: function(ctx, parentFrame, cb) {\n\t        if (typeof ctx === 'function') {\n\t            cb = ctx;\n\t            ctx = {};\n\t        }\n\t        else if (typeof parentFrame === 'function') {\n\t            cb = parentFrame;\n\t            parentFrame = null;\n\t        }\n\n\t        var forceAsync = true;\n\t        if(parentFrame) {\n\t            // If there is a frame, we are being called from internal\n\t            // code of another template, and the internal system\n\t            // depends on the sync/async nature of the parent template\n\t            // to be inherited, so force an async callback\n\t            forceAsync = false;\n\t        }\n\n\t        var _this = this;\n\t        // Catch compile errors for async rendering\n\t        try {\n\t            _this.compile();\n\t        } catch (_err) {\n\t            var err = lib.prettifyError(this.path, this.env.opts.dev, _err);\n\t            if (cb) return callbackAsap(cb, err);\n\t            else throw err;\n\t        }\n\n\t        var context = new Context(ctx || {}, _this.blocks, _this.env);\n\t        var frame = parentFrame ? parentFrame.push(true) : new Frame();\n\t        frame.topLevel = true;\n\t        var syncResult = null;\n\n\t        _this.rootRenderFunc(\n\t            _this.env,\n\t            context,\n\t            frame || new Frame(),\n\t            runtime,\n\t            function(err, res) {\n\t                if(err) {\n\t                    err = lib.prettifyError(_this.path, _this.env.opts.dev, err);\n\t                }\n\n\t                if(cb) {\n\t                    if(forceAsync) {\n\t                        callbackAsap(cb, err, res);\n\t                    }\n\t                    else {\n\t                        cb(err, res);\n\t                    }\n\t                }\n\t                else {\n\t                    if(err) { throw err; }\n\t                    syncResult = res;\n\t                }\n\t            }\n\t        );\n\n\t        return syncResult;\n\t    },\n\n\n\t    getExported: function(ctx, parentFrame, cb) {\n\t        if (typeof ctx === 'function') {\n\t            cb = ctx;\n\t            ctx = {};\n\t        }\n\n\t        if (typeof parentFrame === 'function') {\n\t            cb = parentFrame;\n\t            parentFrame = null;\n\t        }\n\n\t        // Catch compile errors for async rendering\n\t        try {\n\t            this.compile();\n\t        } catch (e) {\n\t            if (cb) return cb(e);\n\t            else throw e;\n\t        }\n\n\t        var frame = parentFrame ? parentFrame.push() : new Frame();\n\t        frame.topLevel = true;\n\n\t        // Run the rootRenderFunc to populate the context with exported vars\n\t        var context = new Context(ctx || {}, this.blocks, this.env);\n\t        this.rootRenderFunc(this.env,\n\t                            context,\n\t                            frame,\n\t                            runtime,\n\t                            function(err) {\n\t        \t\t        if ( err ) {\n\t        \t\t\t    cb(err, null);\n\t        \t\t        } else {\n\t        \t\t\t    cb(null, context.getExported());\n\t        \t\t        }\n\t                            });\n\t    },\n\n\t    compile: function() {\n\t        if(!this.compiled) {\n\t            this._compile();\n\t        }\n\t    },\n\n\t    _compile: function() {\n\t        var props;\n\n\t        if(this.tmplProps) {\n\t            props = this.tmplProps;\n\t        }\n\t        else {\n\t            var source = compiler.compile(this.tmplStr,\n\t                                          this.env.asyncFilters,\n\t                                          this.env.extensionsList,\n\t                                          this.path,\n\t                                          this.env.opts);\n\n\t            /* jslint evil: true */\n\t            var func = new Function(source);\n\t            props = func();\n\t        }\n\n\t        this.blocks = this._getBlocks(props);\n\t        this.rootRenderFunc = props.root;\n\t        this.compiled = true;\n\t    },\n\n\t    _getBlocks: function(props) {\n\t        var blocks = {};\n\n\t        for(var k in props) {\n\t            if(k.slice(0, 2) === 'b_') {\n\t                blocks[k.slice(2)] = props[k];\n\t            }\n\t        }\n\n\t        return blocks;\n\t    }\n\t});\n\n\tmodule.exports = {\n\t    Environment: Environment,\n\t    Template: Template\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\t// rawAsap provides everything we need except exception management.\n\tvar rawAsap = __webpack_require__(5);\n\t// RawTasks are recycled to reduce GC churn.\n\tvar freeTasks = [];\n\t// We queue errors to ensure they are thrown in right order (FIFO).\n\t// Array-as-queue is good enough here, since we are just dealing with exceptions.\n\tvar pendingErrors = [];\n\tvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\n\tfunction throwFirstError() {\n\t    if (pendingErrors.length) {\n\t        throw pendingErrors.shift();\n\t    }\n\t}\n\n\t/**\n\t * Calls a task as soon as possible after returning, in its own event, with priority\n\t * over other events like animation, reflow, and repaint. An error thrown from an\n\t * event will not interrupt, nor even substantially slow down the processing of\n\t * other events, but will be rather postponed to a lower priority event.\n\t * @param {{call}} task A callable object, typically a function that takes no\n\t * arguments.\n\t */\n\tmodule.exports = asap;\n\tfunction asap(task) {\n\t    var rawTask;\n\t    if (freeTasks.length) {\n\t        rawTask = freeTasks.pop();\n\t    } else {\n\t        rawTask = new RawTask();\n\t    }\n\t    rawTask.task = task;\n\t    rawAsap(rawTask);\n\t}\n\n\t// We wrap tasks with recyclable task objects.  A task object implements\n\t// `call`, just like a function.\n\tfunction RawTask() {\n\t    this.task = null;\n\t}\n\n\t// The sole purpose of wrapping the task is to catch the exception and recycle\n\t// the task object after its single use.\n\tRawTask.prototype.call = function () {\n\t    try {\n\t        this.task.call();\n\t    } catch (error) {\n\t        if (asap.onerror) {\n\t            // This hook exists purely for testing purposes.\n\t            // Its name will be periodically randomized to break any code that\n\t            // depends on its existence.\n\t            asap.onerror(error);\n\t        } else {\n\t            // In a web browser, exceptions are not fatal. However, to avoid\n\t            // slowing down the queue of pending tasks, we rethrow the error in a\n\t            // lower priority turn.\n\t            pendingErrors.push(error);\n\t            requestErrorThrow();\n\t        }\n\t    } finally {\n\t        this.task = null;\n\t        freeTasks[freeTasks.length] = this;\n\t    }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\n\t// Use the fastest means possible to execute a task in its own turn, with\n\t// priority over other events including IO, animation, reflow, and redraw\n\t// events in browsers.\n\t//\n\t// An exception thrown by a task will permanently interrupt the processing of\n\t// subsequent tasks. The higher level `asap` function ensures that if an\n\t// exception is thrown by a task, that the task queue will continue flushing as\n\t// soon as possible, but if you use `rawAsap` directly, you are responsible to\n\t// either ensure that no exceptions are thrown from your task, or to manually\n\t// call `rawAsap.requestFlush` if an exception is thrown.\n\tmodule.exports = rawAsap;\n\tfunction rawAsap(task) {\n\t    if (!queue.length) {\n\t        requestFlush();\n\t        flushing = true;\n\t    }\n\t    // Equivalent to push, but avoids a function call.\n\t    queue[queue.length] = task;\n\t}\n\n\tvar queue = [];\n\t// Once a flush has been requested, no further calls to `requestFlush` are\n\t// necessary until the next `flush` completes.\n\tvar flushing = false;\n\t// `requestFlush` is an implementation-specific method that attempts to kick\n\t// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n\t// the event queue before yielding to the browser's own event loop.\n\tvar requestFlush;\n\t// The position of the next task to execute in the task queue. This is\n\t// preserved between calls to `flush` so that it can be resumed if\n\t// a task throws an exception.\n\tvar index = 0;\n\t// If a task schedules additional tasks recursively, the task queue can grow\n\t// unbounded. To prevent memory exhaustion, the task queue will periodically\n\t// truncate already-completed tasks.\n\tvar capacity = 1024;\n\n\t// The flush function processes all tasks that have been scheduled with\n\t// `rawAsap` unless and until one of those tasks throws an exception.\n\t// If a task throws an exception, `flush` ensures that its state will remain\n\t// consistent and will resume where it left off when called again.\n\t// However, `flush` does not make any arrangements to be called again if an\n\t// exception is thrown.\n\tfunction flush() {\n\t    while (index < queue.length) {\n\t        var currentIndex = index;\n\t        // Advance the index before calling the task. This ensures that we will\n\t        // begin flushing on the next task the task throws an error.\n\t        index = index + 1;\n\t        queue[currentIndex].call();\n\t        // Prevent leaking memory for long chains of recursive calls to `asap`.\n\t        // If we call `asap` within tasks scheduled by `asap`, the queue will\n\t        // grow, but to avoid an O(n) walk for every task we execute, we don't\n\t        // shift tasks off the queue after they have been executed.\n\t        // Instead, we periodically shift 1024 tasks off the queue.\n\t        if (index > capacity) {\n\t            // Manually shift all values starting at the index back to the\n\t            // beginning of the queue.\n\t            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n\t                queue[scan] = queue[scan + index];\n\t            }\n\t            queue.length -= index;\n\t            index = 0;\n\t        }\n\t    }\n\t    queue.length = 0;\n\t    index = 0;\n\t    flushing = false;\n\t}\n\n\t// `requestFlush` is implemented using a strategy based on data collected from\n\t// every available SauceLabs Selenium web driver worker at time of writing.\n\t// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n\t// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n\t// have WebKitMutationObserver but not un-prefixed MutationObserver.\n\t// Must use `global` instead of `window` to work in both frames and web\n\t// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\tvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n\t// MutationObservers are desirable because they have high priority and work\n\t// reliably everywhere they are implemented.\n\t// They are implemented in all modern browsers.\n\t//\n\t// - Android 4-4.3\n\t// - Chrome 26-34\n\t// - Firefox 14-29\n\t// - Internet Explorer 11\n\t// - iPad Safari 6-7.1\n\t// - iPhone Safari 7-7.1\n\t// - Safari 6-7\n\tif (typeof BrowserMutationObserver === \"function\") {\n\t    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n\t// MessageChannels are desirable because they give direct access to the HTML\n\t// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n\t// 11-12, and in web workers in many engines.\n\t// Although message channels yield to any queued rendering and IO tasks, they\n\t// would be better than imposing the 4ms delay of timers.\n\t// However, they do not work reliably in Internet Explorer or Safari.\n\n\t// Internet Explorer 10 is the only browser that has setImmediate but does\n\t// not have MutationObservers.\n\t// Although setImmediate yields to the browser's renderer, it would be\n\t// preferrable to falling back to setTimeout since it does not have\n\t// the minimum 4ms penalty.\n\t// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n\t// Desktop to a lesser extent) that renders both setImmediate and\n\t// MessageChannel useless for the purposes of ASAP.\n\t// https://github.com/kriskowal/q/issues/396\n\n\t// Timers are implemented universally.\n\t// We fall back to timers in workers in most engines, and in foreground\n\t// contexts in the following browsers.\n\t// However, note that even this simple case requires nuances to operate in a\n\t// broad spectrum of browsers.\n\t//\n\t// - Firefox 3-13\n\t// - Internet Explorer 6-9\n\t// - iPad Safari 4.3\n\t// - Lynx 2.8.7\n\t} else {\n\t    requestFlush = makeRequestCallFromTimer(flush);\n\t}\n\n\t// `requestFlush` requests that the high priority event queue be flushed as\n\t// soon as possible.\n\t// This is useful to prevent an error thrown in a task from stalling the event\n\t// queue if the exception handled by Node.js’s\n\t// `process.on(\"uncaughtException\")` or by a domain.\n\trawAsap.requestFlush = requestFlush;\n\n\t// To request a high priority event, we induce a mutation observer by toggling\n\t// the text of a text node between \"1\" and \"-1\".\n\tfunction makeRequestCallFromMutationObserver(callback) {\n\t    var toggle = 1;\n\t    var observer = new BrowserMutationObserver(callback);\n\t    var node = document.createTextNode(\"\");\n\t    observer.observe(node, {characterData: true});\n\t    return function requestCall() {\n\t        toggle = -toggle;\n\t        node.data = toggle;\n\t    };\n\t}\n\n\t// The message channel technique was discovered by Malte Ubl and was the\n\t// original foundation for this library.\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\n\n\t// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n\t// page's first load. Thankfully, this version of Safari supports\n\t// MutationObservers, so we don't need to fall back in that case.\n\n\t// function makeRequestCallFromMessageChannel(callback) {\n\t//     var channel = new MessageChannel();\n\t//     channel.port1.onmessage = callback;\n\t//     return function requestCall() {\n\t//         channel.port2.postMessage(0);\n\t//     };\n\t// }\n\n\t// For reasons explained above, we are also unable to use `setImmediate`\n\t// under any circumstances.\n\t// Even if we were, there is another bug in Internet Explorer 10.\n\t// It is not sufficient to assign `setImmediate` to `requestFlush` because\n\t// `setImmediate` must be called *by name* and therefore must be wrapped in a\n\t// closure.\n\t// Never forget.\n\n\t// function makeRequestCallFromSetImmediate(callback) {\n\t//     return function requestCall() {\n\t//         setImmediate(callback);\n\t//     };\n\t// }\n\n\t// Safari 6.0 has a problem where timers will get lost while the user is\n\t// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n\t// mutation observers, so that implementation is used instead.\n\t// However, if we ever elect to use timers in Safari, the prevalent work-around\n\t// is to add a scroll event listener that calls for a flush.\n\n\t// `setTimeout` does not call the passed callback if the delay is less than\n\t// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n\t// even then.\n\n\tfunction makeRequestCallFromTimer(callback) {\n\t    return function requestCall() {\n\t        // We dispatch a timeout with a specified delay of 0 for engines that\n\t        // can reliably accommodate that request. This will usually be snapped\n\t        // to a 4 milisecond delay, but once we're flushing, there's no delay\n\t        // between events.\n\t        var timeoutHandle = setTimeout(handleTimer, 0);\n\t        // However, since this timer gets frequently dropped in Firefox\n\t        // workers, we enlist an interval handle that will try to fire\n\t        // an event 20 times per second until it succeeds.\n\t        var intervalHandle = setInterval(handleTimer, 50);\n\n\t        function handleTimer() {\n\t            // Whichever timer succeeds will cancel both timers and\n\t            // execute the callback.\n\t            clearTimeout(timeoutHandle);\n\t            clearInterval(intervalHandle);\n\t            callback();\n\t        }\n\t    };\n\t}\n\n\t// This is for `asap.js` only.\n\t// Its name will be periodically randomized to break any code that depends on\n\t// its existence.\n\trawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n\t// ASAP was originally a nextTick shim included in Q. This was factored out\n\t// into this ASAP package. It was later adapted to RSVP which made further\n\t// amendments. These decisions, particularly to marginalize MessageChannel and\n\t// to capture the MutationObserver implementation in a closure, were integrated\n\t// back into ASAP proper.\n\t// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\t// A simple class system, more documentation to come\n\n\tfunction extend(cls, name, props) {\n\t    // This does that same thing as Object.create, but with support for IE8\n\t    var F = function() {};\n\t    F.prototype = cls.prototype;\n\t    var prototype = new F();\n\n\t    // jshint undef: false\n\t    var fnTest = /xyz/.test(function(){ xyz; }) ? /\\bparent\\b/ : /.*/;\n\t    props = props || {};\n\n\t    for(var k in props) {\n\t        var src = props[k];\n\t        var parent = prototype[k];\n\n\t        if(typeof parent === 'function' &&\n\t           typeof src === 'function' &&\n\t           fnTest.test(src)) {\n\t            /*jshint -W083 */\n\t            prototype[k] = (function (src, parent) {\n\t                return function() {\n\t                    // Save the current parent method\n\t                    var tmp = this.parent;\n\n\t                    // Set parent to the previous method, call, and restore\n\t                    this.parent = parent;\n\t                    var res = src.apply(this, arguments);\n\t                    this.parent = tmp;\n\n\t                    return res;\n\t                };\n\t            })(src, parent);\n\t        }\n\t        else {\n\t            prototype[k] = src;\n\t        }\n\t    }\n\n\t    prototype.typename = name;\n\n\t    var new_cls = function() {\n\t        if(prototype.init) {\n\t            prototype.init.apply(this, arguments);\n\t        }\n\t    };\n\n\t    new_cls.prototype = prototype;\n\t    new_cls.prototype.constructor = new_cls;\n\n\t    new_cls.extend = function(name, props) {\n\t        if(typeof name === 'object') {\n\t            props = name;\n\t            name = 'anonymous';\n\t        }\n\t        return extend(new_cls, name, props);\n\t    };\n\n\t    return new_cls;\n\t}\n\n\tmodule.exports = extend(Object, 'Object', {});\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar parser = __webpack_require__(8);\n\tvar transformer = __webpack_require__(11);\n\tvar nodes = __webpack_require__(10);\n\t// jshint -W079\n\tvar Object = __webpack_require__(6);\n\tvar Frame = __webpack_require__(12).Frame;\n\n\t// These are all the same for now, but shouldn't be passed straight\n\t// through\n\tvar compareOps = {\n\t    '==': '==',\n\t    '===': '===',\n\t    '!=': '!=',\n\t    '!==': '!==',\n\t    '<': '<',\n\t    '>': '>',\n\t    '<=': '<=',\n\t    '>=': '>='\n\t};\n\n\t// A common pattern is to emit binary operators\n\tfunction binOpEmitter(str) {\n\t    return function(node, frame) {\n\t        this.compile(node.left, frame);\n\t        this.emit(str);\n\t        this.compile(node.right, frame);\n\t    };\n\t}\n\n\tvar Compiler = Object.extend({\n\t    init: function(templateName, throwOnUndefined) {\n\t        this.templateName = templateName;\n\t        this.codebuf = [];\n\t        this.lastId = 0;\n\t        this.buffer = null;\n\t        this.bufferStack = [];\n\t        this.scopeClosers = '';\n\t        this.inBlock = false;\n\t        this.throwOnUndefined = throwOnUndefined;\n\t    },\n\n\t    fail: function (msg, lineno, colno) {\n\t        if (lineno !== undefined) lineno += 1;\n\t        if (colno !== undefined) colno += 1;\n\n\t        throw new lib.TemplateError(msg, lineno, colno);\n\t    },\n\n\t    pushBufferId: function(id) {\n\t        this.bufferStack.push(this.buffer);\n\t        this.buffer = id;\n\t        this.emit('var ' + this.buffer + ' = \"\";');\n\t    },\n\n\t    popBufferId: function() {\n\t        this.buffer = this.bufferStack.pop();\n\t    },\n\n\t    emit: function(code) {\n\t        this.codebuf.push(code);\n\t    },\n\n\t    emitLine: function(code) {\n\t        this.emit(code + '\\n');\n\t    },\n\n\t    emitLines: function() {\n\t        lib.each(lib.toArray(arguments), function(line) {\n\t            this.emitLine(line);\n\t        }, this);\n\t    },\n\n\t    emitFuncBegin: function(name) {\n\t        this.buffer = 'output';\n\t        this.scopeClosers = '';\n\t        this.emitLine('function ' + name + '(env, context, frame, runtime, cb) {');\n\t        this.emitLine('var lineno = null;');\n\t        this.emitLine('var colno = null;');\n\t        this.emitLine('var ' + this.buffer + ' = \"\";');\n\t        this.emitLine('try {');\n\t    },\n\n\t    emitFuncEnd: function(noReturn) {\n\t        if(!noReturn) {\n\t            this.emitLine('cb(null, ' + this.buffer +');');\n\t        }\n\n\t        this.closeScopeLevels();\n\t        this.emitLine('} catch (e) {');\n\t        this.emitLine('  cb(runtime.handleError(e, lineno, colno));');\n\t        this.emitLine('}');\n\t        this.emitLine('}');\n\t        this.buffer = null;\n\t    },\n\n\t    addScopeLevel: function() {\n\t        this.scopeClosers += '})';\n\t    },\n\n\t    closeScopeLevels: function() {\n\t        this.emitLine(this.scopeClosers + ';');\n\t        this.scopeClosers = '';\n\t    },\n\n\t    withScopedSyntax: function(func) {\n\t        var scopeClosers = this.scopeClosers;\n\t        this.scopeClosers = '';\n\n\t        func.call(this);\n\n\t        this.closeScopeLevels();\n\t        this.scopeClosers = scopeClosers;\n\t    },\n\n\t    makeCallback: function(res) {\n\t        var err = this.tmpid();\n\n\t        return 'function(' + err + (res ? ',' + res : '') + ') {\\n' +\n\t            'if(' + err + ') { cb(' + err + '); return; }';\n\t    },\n\n\t    tmpid: function() {\n\t        this.lastId++;\n\t        return 't_' + this.lastId;\n\t    },\n\n\t    _templateName: function() {\n\t        return this.templateName == null? 'undefined' : JSON.stringify(this.templateName);\n\t    },\n\n\t    _compileChildren: function(node, frame) {\n\t        var children = node.children;\n\t        for(var i=0, l=children.length; i<l; i++) {\n\t            this.compile(children[i], frame);\n\t        }\n\t    },\n\n\t    _compileAggregate: function(node, frame, startChar, endChar) {\n\t        if(startChar) {\n\t            this.emit(startChar);\n\t        }\n\n\t        for(var i=0; i<node.children.length; i++) {\n\t            if(i > 0) {\n\t                this.emit(',');\n\t            }\n\n\t            this.compile(node.children[i], frame);\n\t        }\n\n\t        if(endChar) {\n\t            this.emit(endChar);\n\t        }\n\t    },\n\n\t    _compileExpression: function(node, frame) {\n\t        // TODO: I'm not really sure if this type check is worth it or\n\t        // not.\n\t        this.assertType(\n\t            node,\n\t            nodes.Literal,\n\t            nodes.Symbol,\n\t            nodes.Group,\n\t            nodes.Array,\n\t            nodes.Dict,\n\t            nodes.FunCall,\n\t            nodes.Caller,\n\t            nodes.Filter,\n\t            nodes.LookupVal,\n\t            nodes.Compare,\n\t            nodes.InlineIf,\n\t            nodes.In,\n\t            nodes.And,\n\t            nodes.Or,\n\t            nodes.Not,\n\t            nodes.Add,\n\t            nodes.Concat,\n\t            nodes.Sub,\n\t            nodes.Mul,\n\t            nodes.Div,\n\t            nodes.FloorDiv,\n\t            nodes.Mod,\n\t            nodes.Pow,\n\t            nodes.Neg,\n\t            nodes.Pos,\n\t            nodes.Compare,\n\t            nodes.NodeList\n\t        );\n\t        this.compile(node, frame);\n\t    },\n\n\t    assertType: function(node /*, types */) {\n\t        var types = lib.toArray(arguments).slice(1);\n\t        var success = false;\n\n\t        for(var i=0; i<types.length; i++) {\n\t            if(node instanceof types[i]) {\n\t                success = true;\n\t            }\n\t        }\n\n\t        if(!success) {\n\t            this.fail('assertType: invalid type: ' + node.typename,\n\t                      node.lineno,\n\t                      node.colno);\n\t        }\n\t    },\n\n\t    compileCallExtension: function(node, frame, async) {\n\t        var args = node.args;\n\t        var contentArgs = node.contentArgs;\n\t        var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;\n\n\t        if(!async) {\n\t            this.emit(this.buffer + ' += runtime.suppressValue(');\n\t        }\n\n\t        this.emit('env.getExtension(\"' + node.extName + '\")[\"' + node.prop + '\"](');\n\t        this.emit('context');\n\n\t        if(args || contentArgs) {\n\t            this.emit(',');\n\t        }\n\n\t        if(args) {\n\t            if(!(args instanceof nodes.NodeList)) {\n\t                this.fail('compileCallExtension: arguments must be a NodeList, ' +\n\t                          'use `parser.parseSignature`');\n\t            }\n\n\t            lib.each(args.children, function(arg, i) {\n\t                // Tag arguments are passed normally to the call. Note\n\t                // that keyword arguments are turned into a single js\n\t                // object as the last argument, if they exist.\n\t                this._compileExpression(arg, frame);\n\n\t                if(i !== args.children.length - 1 || contentArgs.length) {\n\t                    this.emit(',');\n\t                }\n\t            }, this);\n\t        }\n\n\t        if(contentArgs.length) {\n\t            lib.each(contentArgs, function(arg, i) {\n\t                if(i > 0) {\n\t                    this.emit(',');\n\t                }\n\n\t                if(arg) {\n\t                    var id = this.tmpid();\n\n\t                    this.emitLine('function(cb) {');\n\t                    this.emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');\n\t                    this.pushBufferId(id);\n\n\t                    this.withScopedSyntax(function() {\n\t                        this.compile(arg, frame);\n\t                        this.emitLine('cb(null, ' + id + ');');\n\t                    });\n\n\t                    this.popBufferId();\n\t                    this.emitLine('return ' + id + ';');\n\t                    this.emitLine('}');\n\t                }\n\t                else {\n\t                    this.emit('null');\n\t                }\n\t            }, this);\n\t        }\n\n\t        if(async) {\n\t            var res = this.tmpid();\n\t            this.emitLine(', ' + this.makeCallback(res));\n\t            this.emitLine(this.buffer + ' += runtime.suppressValue(' + res + ', ' + autoescape + ' && env.opts.autoescape);');\n\t            this.addScopeLevel();\n\t        }\n\t        else {\n\t            this.emit(')');\n\t            this.emit(', ' + autoescape + ' && env.opts.autoescape);\\n');\n\t        }\n\t    },\n\n\t    compileCallExtensionAsync: function(node, frame) {\n\t        this.compileCallExtension(node, frame, true);\n\t    },\n\n\t    compileNodeList: function(node, frame) {\n\t        this._compileChildren(node, frame);\n\t    },\n\n\t    compileLiteral: function(node) {\n\t        if(typeof node.value === 'string') {\n\t            var val = node.value.replace(/\\\\/g, '\\\\\\\\');\n\t            val = val.replace(/\"/g, '\\\\\"');\n\t            val = val.replace(/\\n/g, '\\\\n');\n\t            val = val.replace(/\\r/g, '\\\\r');\n\t            val = val.replace(/\\t/g, '\\\\t');\n\t            this.emit('\"' + val  + '\"');\n\t        }\n\t        else if (node.value === null) {\n\t            this.emit('null');\n\t        }\n\t        else {\n\t            this.emit(node.value.toString());\n\t        }\n\t    },\n\n\t    compileSymbol: function(node, frame) {\n\t        var name = node.value;\n\t        var v;\n\n\t        if((v = frame.lookup(name))) {\n\t            this.emit(v);\n\t        }\n\t        else {\n\t            this.emit('runtime.contextOrFrameLookup(' +\n\t                      'context, frame, \"' + name + '\")');\n\t        }\n\t    },\n\n\t    compileGroup: function(node, frame) {\n\t        this._compileAggregate(node, frame, '(', ')');\n\t    },\n\n\t    compileArray: function(node, frame) {\n\t        this._compileAggregate(node, frame, '[', ']');\n\t    },\n\n\t    compileDict: function(node, frame) {\n\t        this._compileAggregate(node, frame, '{', '}');\n\t    },\n\n\t    compilePair: function(node, frame) {\n\t        var key = node.key;\n\t        var val = node.value;\n\n\t        if(key instanceof nodes.Symbol) {\n\t            key = new nodes.Literal(key.lineno, key.colno, key.value);\n\t        }\n\t        else if(!(key instanceof nodes.Literal &&\n\t                  typeof key.value === 'string')) {\n\t            this.fail('compilePair: Dict keys must be strings or names',\n\t                      key.lineno,\n\t                      key.colno);\n\t        }\n\n\t        this.compile(key, frame);\n\t        this.emit(': ');\n\t        this._compileExpression(val, frame);\n\t    },\n\n\t    compileInlineIf: function(node, frame) {\n\t        this.emit('(');\n\t        this.compile(node.cond, frame);\n\t        this.emit('?');\n\t        this.compile(node.body, frame);\n\t        this.emit(':');\n\t        if(node.else_ !== null)\n\t            this.compile(node.else_, frame);\n\t        else\n\t            this.emit('\"\"');\n\t        this.emit(')');\n\t    },\n\n\t    compileIn: function(node, frame) {\n\t      this.emit('runtime.inOperator(');\n\t      this.compile(node.left, frame);\n\t      this.emit(',');\n\t      this.compile(node.right, frame);\n\t      this.emit(')');\n\t    },\n\n\t    compileOr: binOpEmitter(' || '),\n\t    compileAnd: binOpEmitter(' && '),\n\t    compileAdd: binOpEmitter(' + '),\n\t    // ensure concatenation instead of addition\n\t    // by adding empty string in between\n\t    compileConcat: binOpEmitter(' + \"\" + '),\n\t    compileSub: binOpEmitter(' - '),\n\t    compileMul: binOpEmitter(' * '),\n\t    compileDiv: binOpEmitter(' / '),\n\t    compileMod: binOpEmitter(' % '),\n\n\t    compileNot: function(node, frame) {\n\t        this.emit('!');\n\t        this.compile(node.target, frame);\n\t    },\n\n\t    compileFloorDiv: function(node, frame) {\n\t        this.emit('Math.floor(');\n\t        this.compile(node.left, frame);\n\t        this.emit(' / ');\n\t        this.compile(node.right, frame);\n\t        this.emit(')');\n\t    },\n\n\t    compilePow: function(node, frame) {\n\t        this.emit('Math.pow(');\n\t        this.compile(node.left, frame);\n\t        this.emit(', ');\n\t        this.compile(node.right, frame);\n\t        this.emit(')');\n\t    },\n\n\t    compileNeg: function(node, frame) {\n\t        this.emit('-');\n\t        this.compile(node.target, frame);\n\t    },\n\n\t    compilePos: function(node, frame) {\n\t        this.emit('+');\n\t        this.compile(node.target, frame);\n\t    },\n\n\t    compileCompare: function(node, frame) {\n\t        this.compile(node.expr, frame);\n\n\t        for(var i=0; i<node.ops.length; i++) {\n\t            var n = node.ops[i];\n\t            this.emit(' ' + compareOps[n.type] + ' ');\n\t            this.compile(n.expr, frame);\n\t        }\n\t    },\n\n\t    compileLookupVal: function(node, frame) {\n\t        this.emit('runtime.memberLookup((');\n\t        this._compileExpression(node.target, frame);\n\t        this.emit('),');\n\t        this._compileExpression(node.val, frame);\n\t        this.emit(')');\n\t    },\n\n\t    _getNodeName: function(node) {\n\t        switch (node.typename) {\n\t            case 'Symbol':\n\t                return node.value;\n\t            case 'FunCall':\n\t                return 'the return value of (' + this._getNodeName(node.name) + ')';\n\t            case 'LookupVal':\n\t                return this._getNodeName(node.target) + '[\"' +\n\t                       this._getNodeName(node.val) + '\"]';\n\t            case 'Literal':\n\t                return node.value.toString();\n\t            default:\n\t                return '--expression--';\n\t        }\n\t    },\n\n\t    compileFunCall: function(node, frame) {\n\t        // Keep track of line/col info at runtime by settings\n\t        // variables within an expression. An expression in javascript\n\t        // like (x, y, z) returns the last value, and x and y can be\n\t        // anything\n\t        this.emit('(lineno = ' + node.lineno +\n\t                  ', colno = ' + node.colno + ', ');\n\n\t        this.emit('runtime.callWrap(');\n\t        // Compile it as normal.\n\t        this._compileExpression(node.name, frame);\n\n\t        // Output the name of what we're calling so we can get friendly errors\n\t        // if the lookup fails.\n\t        this.emit(', \"' + this._getNodeName(node.name).replace(/\"/g, '\\\\\"') + '\", context, ');\n\n\t        this._compileAggregate(node.args, frame, '[', '])');\n\n\t        this.emit(')');\n\t    },\n\n\t    compileFilter: function(node, frame) {\n\t        var name = node.name;\n\t        this.assertType(name, nodes.Symbol);\n\t        this.emit('env.getFilter(\"' + name.value + '\").call(context, ');\n\t        this._compileAggregate(node.args, frame);\n\t        this.emit(')');\n\t    },\n\n\t    compileFilterAsync: function(node, frame) {\n\t        var name = node.name;\n\t        this.assertType(name, nodes.Symbol);\n\n\t        var symbol = node.symbol.value;\n\t        frame.set(symbol, symbol);\n\n\t        this.emit('env.getFilter(\"' + name.value + '\").call(context, ');\n\t        this._compileAggregate(node.args, frame);\n\t        this.emitLine(', ' + this.makeCallback(symbol));\n\n\t        this.addScopeLevel();\n\t    },\n\n\t    compileKeywordArgs: function(node, frame) {\n\t        var names = [];\n\n\t        lib.each(node.children, function(pair) {\n\t            names.push(pair.key.value);\n\t        });\n\n\t        this.emit('runtime.makeKeywordArgs(');\n\t        this.compileDict(node, frame);\n\t        this.emit(')');\n\t    },\n\n\t    compileSet: function(node, frame) {\n\t        var ids = [];\n\n\t        // Lookup the variable names for each identifier and create\n\t        // new ones if necessary\n\t        lib.each(node.targets, function(target) {\n\t            var name = target.value;\n\t            var id = frame.lookup(name);\n\n\t            if (id === null || id === undefined) {\n\t                id = this.tmpid();\n\n\t                // Note: This relies on js allowing scope across\n\t                // blocks, in case this is created inside an `if`\n\t                this.emitLine('var ' + id + ';');\n\t            }\n\n\t            ids.push(id);\n\t        }, this);\n\n\t        if (node.value) {\n\t          this.emit(ids.join(' = ') + ' = ');\n\t          this._compileExpression(node.value, frame);\n\t          this.emitLine(';');\n\t        }\n\t        else {\n\t          this.emit(ids.join(' = ') + ' = ');\n\t          this.compile(node.body, frame);\n\t          this.emitLine(';');\n\t        }\n\n\t        lib.each(node.targets, function(target, i) {\n\t            var id = ids[i];\n\t            var name = target.value;\n\n\t            // We are running this for every var, but it's very\n\t            // uncommon to assign to multiple vars anyway\n\t            this.emitLine('frame.set(\"' + name + '\", ' + id + ', true);');\n\n\t            this.emitLine('if(frame.topLevel) {');\n\t            this.emitLine('context.setVariable(\"' + name + '\", ' + id + ');');\n\t            this.emitLine('}');\n\n\t            if(name.charAt(0) !== '_') {\n\t                this.emitLine('if(frame.topLevel) {');\n\t                this.emitLine('context.addExport(\"' + name + '\", ' + id + ');');\n\t                this.emitLine('}');\n\t            }\n\t        }, this);\n\t    },\n\n\t    compileIf: function(node, frame, async) {\n\t        this.emit('if(');\n\t        this._compileExpression(node.cond, frame);\n\t        this.emitLine(') {');\n\n\t        this.withScopedSyntax(function() {\n\t            this.compile(node.body, frame);\n\n\t            if(async) {\n\t                this.emit('cb()');\n\t            }\n\t        });\n\n\t        if(node.else_) {\n\t            this.emitLine('}\\nelse {');\n\n\t            this.withScopedSyntax(function() {\n\t                this.compile(node.else_, frame);\n\n\t                if(async) {\n\t                    this.emit('cb()');\n\t                }\n\t            });\n\t        } else if(async) {\n\t            this.emitLine('}\\nelse {');\n\t            this.emit('cb()');\n\t        }\n\n\t        this.emitLine('}');\n\t    },\n\n\t    compileIfAsync: function(node, frame) {\n\t        this.emit('(function(cb) {');\n\t        this.compileIf(node, frame, true);\n\t        this.emit('})(' + this.makeCallback());\n\t        this.addScopeLevel();\n\t    },\n\n\t    emitLoopBindings: function(node, arr, i, len) {\n\t        var bindings = {\n\t            index: i + ' + 1',\n\t            index0: i,\n\t            revindex: len + ' - ' + i,\n\t            revindex0: len + ' - ' + i + ' - 1',\n\t            first: i + ' === 0',\n\t            last: i + ' === ' + len + ' - 1',\n\t            length: len\n\t        };\n\n\t        for (var name in bindings) {\n\t            this.emitLine('frame.set(\"loop.' + name + '\", ' + bindings[name] + ');');\n\t        }\n\t    },\n\n\t    compileFor: function(node, frame) {\n\t        // Some of this code is ugly, but it keeps the generated code\n\t        // as fast as possible. ForAsync also shares some of this, but\n\t        // not much.\n\n\t        var v;\n\t        var i = this.tmpid();\n\t        var len = this.tmpid();\n\t        var arr = this.tmpid();\n\t        frame = frame.push();\n\n\t        this.emitLine('frame = frame.push();');\n\n\t        this.emit('var ' + arr + ' = ');\n\t        this._compileExpression(node.arr, frame);\n\t        this.emitLine(';');\n\n\t        this.emit('if(' + arr + ') {');\n\n\t        // If multiple names are passed, we need to bind them\n\t        // appropriately\n\t        if(node.name instanceof nodes.Array) {\n\t            this.emitLine('var ' + i + ';');\n\n\t            // The object could be an arroy or object. Note that the\n\t            // body of the loop is duplicated for each condition, but\n\t            // we are optimizing for speed over size.\n\t            this.emitLine('if(runtime.isArray(' + arr + ')) {'); {\n\t                this.emitLine('var ' + len + ' = ' + arr + '.length;');\n\t                this.emitLine('for(' + i + '=0; ' + i + ' < ' + arr + '.length; '\n\t                              + i + '++) {');\n\n\t                // Bind each declared var\n\t                for (var u=0; u < node.name.children.length; u++) {\n\t                    var tid = this.tmpid();\n\t                    this.emitLine('var ' + tid + ' = ' + arr + '[' + i + '][' + u + ']');\n\t                    this.emitLine('frame.set(\"' + node.name.children[u].value\n\t                                  + '\", ' + arr + '[' + i + '][' + u + ']' + ');');\n\t                    frame.set(node.name.children[u].value, tid);\n\t                }\n\n\t                this.emitLoopBindings(node, arr, i, len);\n\t                this.withScopedSyntax(function() {\n\t                    this.compile(node.body, frame);\n\t                });\n\t                this.emitLine('}');\n\t            }\n\n\t            this.emitLine('} else {'); {\n\t                // Iterate over the key/values of an object\n\t                var key = node.name.children[0];\n\t                var val = node.name.children[1];\n\t                var k = this.tmpid();\n\t                v = this.tmpid();\n\t                frame.set(key.value, k);\n\t                frame.set(val.value, v);\n\n\t                this.emitLine(i + ' = -1;');\n\t                this.emitLine('var ' + len + ' = runtime.keys(' + arr + ').length;');\n\t                this.emitLine('for(var ' + k + ' in ' + arr + ') {');\n\t                this.emitLine(i + '++;');\n\t                this.emitLine('var ' + v + ' = ' + arr + '[' + k + '];');\n\t                this.emitLine('frame.set(\"' + key.value + '\", ' + k + ');');\n\t                this.emitLine('frame.set(\"' + val.value + '\", ' + v + ');');\n\n\t                this.emitLoopBindings(node, arr, i, len);\n\t                this.withScopedSyntax(function() {\n\t                    this.compile(node.body, frame);\n\t                });\n\t                this.emitLine('}');\n\t            }\n\n\t            this.emitLine('}');\n\t        }\n\t        else {\n\t            // Generate a typical array iteration\n\t            v = this.tmpid();\n\t            frame.set(node.name.value, v);\n\n\t            this.emitLine('var ' + len + ' = ' + arr + '.length;');\n\t            this.emitLine('for(var ' + i + '=0; ' + i + ' < ' + arr + '.length; ' +\n\t                          i + '++) {');\n\t            this.emitLine('var ' + v + ' = ' + arr + '[' + i + '];');\n\t            this.emitLine('frame.set(\"' + node.name.value + '\", ' + v + ');');\n\n\t            this.emitLoopBindings(node, arr, i, len);\n\n\t            this.withScopedSyntax(function() {\n\t                this.compile(node.body, frame);\n\t            });\n\n\t            this.emitLine('}');\n\t        }\n\n\t        this.emitLine('}');\n\t        if (node.else_) {\n\t          this.emitLine('if (!' + len + ') {');\n\t          this.compile(node.else_, frame);\n\t          this.emitLine('}');\n\t        }\n\n\t        this.emitLine('frame = frame.pop();');\n\t    },\n\n\t    _compileAsyncLoop: function(node, frame, parallel) {\n\t        // This shares some code with the For tag, but not enough to\n\t        // worry about. This iterates across an object asynchronously,\n\t        // but not in parallel.\n\n\t        var i = this.tmpid();\n\t        var len = this.tmpid();\n\t        var arr = this.tmpid();\n\t        var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';\n\t        frame = frame.push();\n\n\t        this.emitLine('frame = frame.push();');\n\n\t        this.emit('var ' + arr + ' = ');\n\t        this._compileExpression(node.arr, frame);\n\t        this.emitLine(';');\n\n\t        if(node.name instanceof nodes.Array) {\n\t            this.emit('runtime.' + asyncMethod + '(' + arr + ', ' +\n\t                      node.name.children.length + ', function(');\n\n\t            lib.each(node.name.children, function(name) {\n\t                this.emit(name.value + ',');\n\t            }, this);\n\n\t            this.emit(i + ',' + len + ',next) {');\n\n\t            lib.each(node.name.children, function(name) {\n\t                var id = name.value;\n\t                frame.set(id, id);\n\t                this.emitLine('frame.set(\"' + id + '\", ' + id + ');');\n\t            }, this);\n\t        }\n\t        else {\n\t            var id = node.name.value;\n\t            this.emitLine('runtime.' + asyncMethod + '(' + arr + ', 1, function(' + id + ', ' + i + ', ' + len + ',next) {');\n\t            this.emitLine('frame.set(\"' + id + '\", ' + id + ');');\n\t            frame.set(id, id);\n\t        }\n\n\t        this.emitLoopBindings(node, arr, i, len);\n\n\t        this.withScopedSyntax(function() {\n\t            var buf;\n\t            if(parallel) {\n\t                buf = this.tmpid();\n\t                this.pushBufferId(buf);\n\t            }\n\n\t            this.compile(node.body, frame);\n\t            this.emitLine('next(' + i + (buf ? ',' + buf : '') + ');');\n\n\t            if(parallel) {\n\t                this.popBufferId();\n\t            }\n\t        });\n\n\t        var output = this.tmpid();\n\t        this.emitLine('}, ' + this.makeCallback(output));\n\t        this.addScopeLevel();\n\n\t        if(parallel) {\n\t            this.emitLine(this.buffer + ' += ' + output + ';');\n\t        }\n\n\t        if (node.else_) {\n\t          this.emitLine('if (!' + arr + '.length) {');\n\t          this.compile(node.else_, frame);\n\t          this.emitLine('}');\n\t        }\n\n\t        this.emitLine('frame = frame.pop();');\n\t    },\n\n\t    compileAsyncEach: function(node, frame) {\n\t        this._compileAsyncLoop(node, frame);\n\t    },\n\n\t    compileAsyncAll: function(node, frame) {\n\t        this._compileAsyncLoop(node, frame, true);\n\t    },\n\n\t    _compileMacro: function(node) {\n\t        var args = [];\n\t        var kwargs = null;\n\t        var funcId = 'macro_' + this.tmpid();\n\n\t        // Type check the definition of the args\n\t        lib.each(node.args.children, function(arg, i) {\n\t            if(i === node.args.children.length - 1 &&\n\t               arg instanceof nodes.Dict) {\n\t                kwargs = arg;\n\t            }\n\t            else {\n\t                this.assertType(arg, nodes.Symbol);\n\t                args.push(arg);\n\t            }\n\t        }, this);\n\n\t        var realNames = lib.map(args, function(n) { return 'l_' + n.value; });\n\t        realNames.push('kwargs');\n\n\t        // Quoted argument names\n\t        var argNames = lib.map(args, function(n) { return '\"' + n.value + '\"'; });\n\t        var kwargNames = lib.map((kwargs && kwargs.children) || [],\n\t                                 function(n) { return '\"' + n.key.value + '\"'; });\n\n\t        // We pass a function to makeMacro which destructures the\n\t        // arguments so support setting positional args with keywords\n\t        // args and passing keyword args as positional args\n\t        // (essentially default values). See runtime.js.\n\t        var frame = new Frame();\n\t        this.emitLines(\n\t            'var ' + funcId + ' = runtime.makeMacro(',\n\t            '[' + argNames.join(', ') + '], ',\n\t            '[' + kwargNames.join(', ') + '], ',\n\t            'function (' + realNames.join(', ') + ') {',\n\t            'var callerFrame = frame;',\n\t            'frame = new runtime.Frame();',\n\t            'kwargs = kwargs || {};',\n\t            'if (kwargs.hasOwnProperty(\"caller\")) {',\n\t            'frame.set(\"caller\", kwargs.caller); }'\n\t        );\n\n\t        // Expose the arguments to the template. Don't need to use\n\t        // random names because the function\n\t        // will create a new run-time scope for us\n\t        lib.each(args, function(arg) {\n\t            this.emitLine('frame.set(\"' + arg.value + '\", ' +\n\t                          'l_' + arg.value + ');');\n\t            frame.set(arg.value, 'l_' + arg.value);\n\t        }, this);\n\n\t        // Expose the keyword arguments\n\t        if(kwargs) {\n\t            lib.each(kwargs.children, function(pair) {\n\t                var name = pair.key.value;\n\t                this.emit('frame.set(\"' + name + '\", ' +\n\t                          'kwargs.hasOwnProperty(\"' + name + '\") ? ' +\n\t                          'kwargs[\"' + name + '\"] : ');\n\t                this._compileExpression(pair.value, frame);\n\t                this.emitLine(');');\n\t            }, this);\n\t        }\n\n\t        var bufferId = this.tmpid();\n\t        this.pushBufferId(bufferId);\n\n\t        this.withScopedSyntax(function () {\n\t          this.compile(node.body, frame);\n\t        });\n\n\t        this.emitLine('frame = callerFrame;');\n\t        this.emitLine('return new runtime.SafeString(' + bufferId + ');');\n\t        this.emitLine('});');\n\t        this.popBufferId();\n\n\t        return funcId;\n\t    },\n\n\t    compileMacro: function(node, frame) {\n\t        var funcId = this._compileMacro(node, frame);\n\n\t        // Expose the macro to the templates\n\t        var name = node.name.value;\n\t        frame.set(name, funcId);\n\n\t        if(frame.parent) {\n\t            this.emitLine('frame.set(\"' + name + '\", ' + funcId + ');');\n\t        }\n\t        else {\n\t            if(node.name.value.charAt(0) !== '_') {\n\t                this.emitLine('context.addExport(\"' + name + '\");');\n\t            }\n\t            this.emitLine('context.setVariable(\"' + name + '\", ' + funcId + ');');\n\t        }\n\t    },\n\n\t    compileCaller: function(node, frame) {\n\t        // basically an anonymous \"macro expression\"\n\t        this.emit('(function (){');\n\t        var funcId = this._compileMacro(node, frame);\n\t        this.emit('return ' + funcId + ';})()');\n\t    },\n\n\t    compileImport: function(node, frame) {\n\t        var id = this.tmpid();\n\t        var target = node.target.value;\n\n\t        this.emit('env.getTemplate(');\n\t        this._compileExpression(node.template, frame);\n\t        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(id));\n\t        this.addScopeLevel();\n\n\t        this.emitLine(id + '.getExported(' +\n\t            (node.withContext ? 'context.getVariables(), frame, ' : '') +\n\t            this.makeCallback(id));\n\t        this.addScopeLevel();\n\n\t        frame.set(target, id);\n\n\t        if(frame.parent) {\n\t            this.emitLine('frame.set(\"' + target + '\", ' + id + ');');\n\t        }\n\t        else {\n\t            this.emitLine('context.setVariable(\"' + target + '\", ' + id + ');');\n\t        }\n\t    },\n\n\t    compileFromImport: function(node, frame) {\n\t        var importedId = this.tmpid();\n\n\t        this.emit('env.getTemplate(');\n\t        this._compileExpression(node.template, frame);\n\t        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(importedId));\n\t        this.addScopeLevel();\n\n\t        this.emitLine(importedId + '.getExported(' +\n\t            (node.withContext ? 'context.getVariables(), frame, ' : '') +\n\t            this.makeCallback(importedId));\n\t        this.addScopeLevel();\n\n\t        lib.each(node.names.children, function(nameNode) {\n\t            var name;\n\t            var alias;\n\t            var id = this.tmpid();\n\n\t            if(nameNode instanceof nodes.Pair) {\n\t                name = nameNode.key.value;\n\t                alias = nameNode.value.value;\n\t            }\n\t            else {\n\t                name = nameNode.value;\n\t                alias = name;\n\t            }\n\n\t            this.emitLine('if(' + importedId + '.hasOwnProperty(\"' + name + '\")) {');\n\t            this.emitLine('var ' + id + ' = ' + importedId + '.' + name + ';');\n\t            this.emitLine('} else {');\n\t            this.emitLine('cb(new Error(\"cannot import \\'' + name + '\\'\")); return;');\n\t            this.emitLine('}');\n\n\t            frame.set(alias, id);\n\n\t            if(frame.parent) {\n\t                this.emitLine('frame.set(\"' + alias + '\", ' + id + ');');\n\t            }\n\t            else {\n\t                this.emitLine('context.setVariable(\"' + alias + '\", ' + id + ');');\n\t            }\n\t        }, this);\n\t    },\n\n\t    compileBlock: function(node) {\n\t        var id = this.tmpid();\n\n\t        // If we are executing outside a block (creating a top-level\n\t        // block), we really don't want to execute its code because it\n\t        // will execute twice: once when the child template runs and\n\t        // again when the parent template runs. Note that blocks\n\t        // within blocks will *always* execute immediately *and*\n\t        // wherever else they are invoked (like used in a parent\n\t        // template). This may have behavioral differences from jinja\n\t        // because blocks can have side effects, but it seems like a\n\t        // waste of performance to always execute huge top-level\n\t        // blocks twice\n\t        if(!this.inBlock) {\n\t            this.emit('(parentTemplate ? function(e, c, f, r, cb) { cb(\"\"); } : ');\n\t        }\n\t        this.emit('context.getBlock(\"' + node.name.value + '\")');\n\t        if(!this.inBlock) {\n\t            this.emit(')');\n\t        }\n\t        this.emitLine('(env, context, frame, runtime, ' + this.makeCallback(id));\n\t        this.emitLine(this.buffer + ' += ' + id + ';');\n\t        this.addScopeLevel();\n\t    },\n\n\t    compileSuper: function(node, frame) {\n\t        var name = node.blockName.value;\n\t        var id = node.symbol.value;\n\n\t        this.emitLine('context.getSuper(env, ' +\n\t                      '\"' + name + '\", ' +\n\t                      'b_' + name + ', ' +\n\t                      'frame, runtime, '+\n\t                      this.makeCallback(id));\n\t        this.emitLine(id + ' = runtime.markSafe(' + id + ');');\n\t        this.addScopeLevel();\n\t        frame.set(id, id);\n\t    },\n\n\t    compileExtends: function(node, frame) {\n\t        var k = this.tmpid();\n\n\t        this.emit('env.getTemplate(');\n\t        this._compileExpression(node.template, frame);\n\t        this.emitLine(', true, '+this._templateName()+', false, ' + this.makeCallback('_parentTemplate'));\n\n\t        // extends is a dynamic tag and can occur within a block like\n\t        // `if`, so if this happens we need to capture the parent\n\t        // template in the top-level scope\n\t        this.emitLine('parentTemplate = _parentTemplate');\n\n\t        this.emitLine('for(var ' + k + ' in parentTemplate.blocks) {');\n\t        this.emitLine('context.addBlock(' + k +\n\t                      ', parentTemplate.blocks[' + k + ']);');\n\t        this.emitLine('}');\n\n\t        this.addScopeLevel();\n\t    },\n\n\t    compileInclude: function(node, frame) {\n\t        var id = this.tmpid();\n\t        var id2 = this.tmpid();\n\n\t        this.emitLine('var tasks = [];');\n\t        this.emitLine('tasks.push(');\n\t        this.emitLine('function(callback) {');\n\t        this.emit('env.getTemplate(');\n\t        this._compileExpression(node.template, frame);\n\t        this.emitLine(', false, '+this._templateName()+', ' + node.ignoreMissing + ', ' + this.makeCallback(id));\n\t        this.emitLine('callback(null,' + id + ');});');\n\t        this.emitLine('});');\n\n\t        this.emitLine('tasks.push(');\n\t        this.emitLine('function(template, callback){');\n\t        this.emitLine('template.render(' +\n\t            'context.getVariables(), frame, ' + this.makeCallback(id2));\n\t        this.emitLine('callback(null,' + id2 + ');});');\n\t        this.emitLine('});');\n\n\t        this.emitLine('tasks.push(');\n\t        this.emitLine('function(result, callback){');\n\t        this.emitLine(this.buffer + ' += result;');\n\t        this.emitLine('callback(null);');\n\t        this.emitLine('});');\n\t        this.emitLine('env.waterfall(tasks, function(){');\n\t        this.addScopeLevel();\n\t    },\n\n\t    compileTemplateData: function(node, frame) {\n\t        this.compileLiteral(node, frame);\n\t    },\n\n\t    compileCapture: function(node, frame) {\n\t        this.emitLine('(function() {');\n\t        this.emitLine('var output = \"\";');\n\t        this.withScopedSyntax(function () {\n\t            this.compile(node.body, frame);\n\t        });\n\t        this.emitLine('return output;');\n\t        this.emitLine('})()');\n\t    },\n\n\t    compileOutput: function(node, frame) {\n\t        var children = node.children;\n\t        for(var i=0, l=children.length; i<l; i++) {\n\t            // TemplateData is a special case because it is never\n\t            // autoescaped, so simply output it for optimization\n\t            if(children[i] instanceof nodes.TemplateData) {\n\t                if(children[i].value) {\n\t                    this.emit(this.buffer + ' += ');\n\t                    this.compileLiteral(children[i], frame);\n\t                    this.emitLine(';');\n\t                }\n\t            }\n\t            else {\n\t                this.emit(this.buffer + ' += runtime.suppressValue(');\n\t                if(this.throwOnUndefined) {\n\t                    this.emit('runtime.ensureDefined(');\n\t                }\n\t                this.compile(children[i], frame);\n\t                if(this.throwOnUndefined) {\n\t                    this.emit(',' + node.lineno + ',' + node.colno + ')');\n\t                }\n\t                this.emit(', env.opts.autoescape);\\n');\n\t            }\n\t        }\n\t    },\n\n\t    compileRoot: function(node, frame) {\n\t        if(frame) {\n\t            this.fail('compileRoot: root node can\\'t have frame');\n\t        }\n\n\t        frame = new Frame();\n\n\t        this.emitFuncBegin('root');\n\t        this.emitLine('var parentTemplate = null;');\n\t        this._compileChildren(node, frame);\n\t        this.emitLine('if(parentTemplate) {');\n\t        this.emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');\n\t        this.emitLine('} else {');\n\t        this.emitLine('cb(null, ' + this.buffer +');');\n\t        this.emitLine('}');\n\t        this.emitFuncEnd(true);\n\n\t        this.inBlock = true;\n\n\t        var blockNames = [];\n\n\t        var i, name, block, blocks = node.findAll(nodes.Block);\n\t        for (i = 0; i < blocks.length; i++) {\n\t            block = blocks[i];\n\t            name = block.name.value;\n\n\t            if (blockNames.indexOf(name) !== -1) {\n\t                throw new Error('Block \"' + name + '\" defined more than once.');\n\t            }\n\t            blockNames.push(name);\n\n\t            this.emitFuncBegin('b_' + name);\n\n\t            var tmpFrame = new Frame();\n\t            this.emitLine('var frame = frame.push(true);');\n\t            this.compile(block.body, tmpFrame);\n\t            this.emitFuncEnd();\n\t        }\n\n\t        this.emitLine('return {');\n\t        for (i = 0; i < blocks.length; i++) {\n\t            block = blocks[i];\n\t            name = 'b_' + block.name.value;\n\t            this.emitLine(name + ': ' + name + ',');\n\t        }\n\t        this.emitLine('root: root\\n};');\n\t    },\n\n\t    compile: function (node, frame) {\n\t        var _compile = this['compile' + node.typename];\n\t        if(_compile) {\n\t            _compile.call(this, node, frame);\n\t        }\n\t        else {\n\t            this.fail('compile: Cannot compile node: ' + node.typename,\n\t                      node.lineno,\n\t                      node.colno);\n\t        }\n\t    },\n\n\t    getCode: function() {\n\t        return this.codebuf.join('');\n\t    }\n\t});\n\n\t// var c = new Compiler();\n\t// var src = 'hello {% filter title %}' +\n\t//     'Hello madam how are you' +\n\t//     '{% endfilter %}'\n\t// var ast = transformer.transform(parser.parse(src));\n\t// nodes.printNodes(ast);\n\t// c.compile(ast);\n\t// var tmpl = c.getCode();\n\t// console.log(tmpl);\n\n\tmodule.exports = {\n\t    compile: function(src, asyncFilters, extensions, name, opts) {\n\t        var c = new Compiler(name, opts.throwOnUndefined);\n\n\t        // Run the extension preprocessors against the source.\n\t        if(extensions && extensions.length) {\n\t            for(var i=0; i<extensions.length; i++) {\n\t                if('preprocess' in extensions[i]) {\n\t                    src = extensions[i].preprocess(src, name);\n\t                }\n\t            }\n\t        }\n\n\t        c.compile(transformer.transform(\n\t            parser.parse(src,\n\t                         extensions,\n\t                         opts),\n\t            asyncFilters,\n\t            name\n\t        ));\n\t        return c.getCode();\n\t    },\n\n\t    Compiler: Compiler\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lexer = __webpack_require__(9);\n\tvar nodes = __webpack_require__(10);\n\t// jshint -W079\n\tvar Object = __webpack_require__(6);\n\tvar lib = __webpack_require__(1);\n\n\tvar Parser = Object.extend({\n\t    init: function (tokens) {\n\t        this.tokens = tokens;\n\t        this.peeked = null;\n\t        this.breakOnBlocks = null;\n\t        this.dropLeadingWhitespace = false;\n\n\t        this.extensions = [];\n\t    },\n\n\t    nextToken: function (withWhitespace) {\n\t        var tok;\n\n\t        if(this.peeked) {\n\t            if(!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {\n\t                this.peeked = null;\n\t            }\n\t            else {\n\t                tok = this.peeked;\n\t                this.peeked = null;\n\t                return tok;\n\t            }\n\t        }\n\n\t        tok = this.tokens.nextToken();\n\n\t        if(!withWhitespace) {\n\t            while(tok && tok.type === lexer.TOKEN_WHITESPACE) {\n\t                tok = this.tokens.nextToken();\n\t            }\n\t        }\n\n\t        return tok;\n\t    },\n\n\t    peekToken: function () {\n\t        this.peeked = this.peeked || this.nextToken();\n\t        return this.peeked;\n\t    },\n\n\t    pushToken: function(tok) {\n\t        if(this.peeked) {\n\t            throw new Error('pushToken: can only push one token on between reads');\n\t        }\n\t        this.peeked = tok;\n\t    },\n\n\t    fail: function (msg, lineno, colno) {\n\t        if((lineno === undefined || colno === undefined) && this.peekToken()) {\n\t            var tok = this.peekToken();\n\t            lineno = tok.lineno;\n\t            colno = tok.colno;\n\t        }\n\t        if (lineno !== undefined) lineno += 1;\n\t        if (colno !== undefined) colno += 1;\n\n\t        throw new lib.TemplateError(msg, lineno, colno);\n\t    },\n\n\t    skip: function(type) {\n\t        var tok = this.nextToken();\n\t        if(!tok || tok.type !== type) {\n\t            this.pushToken(tok);\n\t            return false;\n\t        }\n\t        return true;\n\t    },\n\n\t    expect: function(type) {\n\t        var tok = this.nextToken();\n\t        if(tok.type !== type) {\n\t            this.fail('expected ' + type + ', got ' + tok.type,\n\t                      tok.lineno,\n\t                      tok.colno);\n\t        }\n\t        return tok;\n\t    },\n\n\t    skipValue: function(type, val) {\n\t        var tok = this.nextToken();\n\t        if(!tok || tok.type !== type || tok.value !== val) {\n\t            this.pushToken(tok);\n\t            return false;\n\t        }\n\t        return true;\n\t    },\n\n\t    skipSymbol: function(val) {\n\t        return this.skipValue(lexer.TOKEN_SYMBOL, val);\n\t    },\n\n\t    advanceAfterBlockEnd: function(name) {\n\t        var tok;\n\t        if(!name) {\n\t            tok = this.peekToken();\n\n\t            if(!tok) {\n\t                this.fail('unexpected end of file');\n\t            }\n\n\t            if(tok.type !== lexer.TOKEN_SYMBOL) {\n\t                this.fail('advanceAfterBlockEnd: expected symbol token or ' +\n\t                          'explicit name to be passed');\n\t            }\n\n\t            name = this.nextToken().value;\n\t        }\n\n\t        tok = this.nextToken();\n\n\t        if(tok && tok.type === lexer.TOKEN_BLOCK_END) {\n\t            if(tok.value.charAt(0) === '-') {\n\t                this.dropLeadingWhitespace = true;\n\t            }\n\t        }\n\t        else {\n\t            this.fail('expected block end in ' + name + ' statement');\n\t        }\n\n\t        return tok;\n\t    },\n\n\t    advanceAfterVariableEnd: function() {\n\t        var tok = this.nextToken();\n\n\t        if(tok && tok.type === lexer.TOKEN_VARIABLE_END) {\n\t            this.dropLeadingWhitespace = tok.value.charAt(\n\t                tok.value.length - this.tokens.tags.VARIABLE_END.length - 1\n\t            ) === '-';\n\t        } else {\n\t            this.pushToken(tok);\n\t            this.fail('expected variable end');\n\t        }\n\t    },\n\n\t    parseFor: function() {\n\t        var forTok = this.peekToken();\n\t        var node;\n\t        var endBlock;\n\n\t        if(this.skipSymbol('for')) {\n\t            node = new nodes.For(forTok.lineno, forTok.colno);\n\t            endBlock = 'endfor';\n\t        }\n\t        else if(this.skipSymbol('asyncEach')) {\n\t            node = new nodes.AsyncEach(forTok.lineno, forTok.colno);\n\t            endBlock = 'endeach';\n\t        }\n\t        else if(this.skipSymbol('asyncAll')) {\n\t            node = new nodes.AsyncAll(forTok.lineno, forTok.colno);\n\t            endBlock = 'endall';\n\t        }\n\t        else {\n\t            this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);\n\t        }\n\n\t        node.name = this.parsePrimary();\n\n\t        if(!(node.name instanceof nodes.Symbol)) {\n\t            this.fail('parseFor: variable name expected for loop');\n\t        }\n\n\t        var type = this.peekToken().type;\n\t        if(type === lexer.TOKEN_COMMA) {\n\t            // key/value iteration\n\t            var key = node.name;\n\t            node.name = new nodes.Array(key.lineno, key.colno);\n\t            node.name.addChild(key);\n\n\t            while(this.skip(lexer.TOKEN_COMMA)) {\n\t                var prim = this.parsePrimary();\n\t                node.name.addChild(prim);\n\t            }\n\t        }\n\n\t        if(!this.skipSymbol('in')) {\n\t            this.fail('parseFor: expected \"in\" keyword for loop',\n\t                      forTok.lineno,\n\t                      forTok.colno);\n\t        }\n\n\t        node.arr = this.parseExpression();\n\t        this.advanceAfterBlockEnd(forTok.value);\n\n\t        node.body = this.parseUntilBlocks(endBlock, 'else');\n\n\t        if(this.skipSymbol('else')) {\n\t            this.advanceAfterBlockEnd('else');\n\t            node.else_ = this.parseUntilBlocks(endBlock);\n\t        }\n\n\t        this.advanceAfterBlockEnd();\n\n\t        return node;\n\t    },\n\n\t    parseMacro: function() {\n\t        var macroTok = this.peekToken();\n\t        if(!this.skipSymbol('macro')) {\n\t            this.fail('expected macro');\n\t        }\n\n\t        var name = this.parsePrimary(true);\n\t        var args = this.parseSignature();\n\t        var node = new nodes.Macro(macroTok.lineno,\n\t                                   macroTok.colno,\n\t                                   name,\n\t                                   args);\n\n\t        this.advanceAfterBlockEnd(macroTok.value);\n\t        node.body = this.parseUntilBlocks('endmacro');\n\t        this.advanceAfterBlockEnd();\n\n\t        return node;\n\t    },\n\n\t    parseCall: function() {\n\t        // a call block is parsed as a normal FunCall, but with an added\n\t        // 'caller' kwarg which is a Caller node.\n\t        var callTok = this.peekToken();\n\t        if(!this.skipSymbol('call')) {\n\t            this.fail('expected call');\n\t        }\n\n\t        var callerArgs = this.parseSignature(true) || new nodes.NodeList();\n\t        var macroCall = this.parsePrimary();\n\n\t        this.advanceAfterBlockEnd(callTok.value);\n\t        var body = this.parseUntilBlocks('endcall');\n\t        this.advanceAfterBlockEnd();\n\n\t        var callerName = new nodes.Symbol(callTok.lineno,\n\t                                          callTok.colno,\n\t                                          'caller');\n\t        var callerNode = new nodes.Caller(callTok.lineno,\n\t                                          callTok.colno,\n\t                                          callerName,\n\t                                          callerArgs,\n\t                                          body);\n\n\t        // add the additional caller kwarg, adding kwargs if necessary\n\t        var args = macroCall.args.children;\n\t        if (!(args[args.length-1] instanceof nodes.KeywordArgs)) {\n\t          args.push(new nodes.KeywordArgs());\n\t        }\n\t        var kwargs = args[args.length - 1];\n\t        kwargs.addChild(new nodes.Pair(callTok.lineno,\n\t                                       callTok.colno,\n\t                                       callerName,\n\t                                       callerNode));\n\n\t        return new nodes.Output(callTok.lineno,\n\t                                callTok.colno,\n\t                                [macroCall]);\n\t    },\n\n\t    parseWithContext: function() {\n\t        var tok = this.peekToken();\n\n\t        var withContext = null;\n\n\t        if(this.skipSymbol('with')) {\n\t            withContext = true;\n\t        }\n\t        else if(this.skipSymbol('without')) {\n\t            withContext = false;\n\t        }\n\n\t        if(withContext !== null) {\n\t            if(!this.skipSymbol('context')) {\n\t                this.fail('parseFrom: expected context after with/without',\n\t                            tok.lineno,\n\t                            tok.colno);\n\t            }\n\t        }\n\n\t        return withContext;\n\t    },\n\n\t    parseImport: function() {\n\t        var importTok = this.peekToken();\n\t        if(!this.skipSymbol('import')) {\n\t            this.fail('parseImport: expected import',\n\t                      importTok.lineno,\n\t                      importTok.colno);\n\t        }\n\n\t        var template = this.parseExpression();\n\n\t        if(!this.skipSymbol('as')) {\n\t            this.fail('parseImport: expected \"as\" keyword',\n\t                            importTok.lineno,\n\t                            importTok.colno);\n\t        }\n\n\t        var target = this.parseExpression();\n\n\t        var withContext = this.parseWithContext();\n\n\t        var node = new nodes.Import(importTok.lineno,\n\t                                    importTok.colno,\n\t                                    template,\n\t                                    target,\n\t                                    withContext);\n\n\t        this.advanceAfterBlockEnd(importTok.value);\n\n\t        return node;\n\t    },\n\n\t    parseFrom: function() {\n\t        var fromTok = this.peekToken();\n\t        if(!this.skipSymbol('from')) {\n\t            this.fail('parseFrom: expected from');\n\t        }\n\n\t        var template = this.parseExpression();\n\n\t        if(!this.skipSymbol('import')) {\n\t            this.fail('parseFrom: expected import',\n\t                            fromTok.lineno,\n\t                            fromTok.colno);\n\t        }\n\n\t        var names = new nodes.NodeList(),\n\t            withContext;\n\n\t        while(1) {\n\t            var nextTok = this.peekToken();\n\t            if(nextTok.type === lexer.TOKEN_BLOCK_END) {\n\t                if(!names.children.length) {\n\t                    this.fail('parseFrom: Expected at least one import name',\n\t                              fromTok.lineno,\n\t                              fromTok.colno);\n\t                }\n\n\t                // Since we are manually advancing past the block end,\n\t                // need to keep track of whitespace control (normally\n\t                // this is done in `advanceAfterBlockEnd`\n\t                if(nextTok.value.charAt(0) === '-') {\n\t                    this.dropLeadingWhitespace = true;\n\t                }\n\n\t                this.nextToken();\n\t                break;\n\t            }\n\n\t            if(names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {\n\t                this.fail('parseFrom: expected comma',\n\t                                fromTok.lineno,\n\t                                fromTok.colno);\n\t            }\n\n\t            var name = this.parsePrimary();\n\t            if(name.value.charAt(0) === '_') {\n\t                this.fail('parseFrom: names starting with an underscore ' +\n\t                          'cannot be imported',\n\t                          name.lineno,\n\t                          name.colno);\n\t            }\n\n\t            if(this.skipSymbol('as')) {\n\t                var alias = this.parsePrimary();\n\t                names.addChild(new nodes.Pair(name.lineno,\n\t                                              name.colno,\n\t                                              name,\n\t                                              alias));\n\t            }\n\t            else {\n\t                names.addChild(name);\n\t            }\n\n\t            withContext = this.parseWithContext();\n\t        }\n\n\t        return new nodes.FromImport(fromTok.lineno,\n\t                                    fromTok.colno,\n\t                                    template,\n\t                                    names,\n\t                                    withContext);\n\t    },\n\n\t    parseBlock: function() {\n\t        var tag = this.peekToken();\n\t        if(!this.skipSymbol('block')) {\n\t            this.fail('parseBlock: expected block', tag.lineno, tag.colno);\n\t        }\n\n\t        var node = new nodes.Block(tag.lineno, tag.colno);\n\n\t        node.name = this.parsePrimary();\n\t        if(!(node.name instanceof nodes.Symbol)) {\n\t            this.fail('parseBlock: variable name expected',\n\t                      tag.lineno,\n\t                      tag.colno);\n\t        }\n\n\t        this.advanceAfterBlockEnd(tag.value);\n\n\t        node.body = this.parseUntilBlocks('endblock');\n\t        this.skipSymbol('endblock');\n\t        this.skipSymbol(node.name.value);\n\n\t        var tok = this.peekToken();\n\t        if(!tok) {\n\t            this.fail('parseBlock: expected endblock, got end of file');\n\t        }\n\n\t        this.advanceAfterBlockEnd(tok.value);\n\n\t        return node;\n\t    },\n\n\t    parseExtends: function() {\n\t        var tagName = 'extends';\n\t        var tag = this.peekToken();\n\t        if(!this.skipSymbol(tagName)) {\n\t            this.fail('parseTemplateRef: expected '+ tagName);\n\t        }\n\n\t        var node = new nodes.Extends(tag.lineno, tag.colno);\n\t        node.template = this.parseExpression();\n\n\t        this.advanceAfterBlockEnd(tag.value);\n\t        return node;\n\t    },\n\n\t    parseInclude: function() {\n\t        var tagName = 'include';\n\t        var tag = this.peekToken();\n\t        if(!this.skipSymbol(tagName)) {\n\t            this.fail('parseInclude: expected '+ tagName);\n\t        }\n\n\t        var node = new nodes.Include(tag.lineno, tag.colno);\n\t        node.template = this.parseExpression();\n\n\t        if(this.skipSymbol('ignore') && this.skipSymbol('missing')) {\n\t            node.ignoreMissing = true;\n\t        }\n\n\t        this.advanceAfterBlockEnd(tag.value);\n\t        return node;\n\t    },\n\n\t    parseIf: function() {\n\t        var tag = this.peekToken();\n\t        var node;\n\n\t        if(this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {\n\t            node = new nodes.If(tag.lineno, tag.colno);\n\t        }\n\t        else if(this.skipSymbol('ifAsync')) {\n\t            node = new nodes.IfAsync(tag.lineno, tag.colno);\n\t        }\n\t        else {\n\t            this.fail('parseIf: expected if, elif, or elseif',\n\t                      tag.lineno,\n\t                      tag.colno);\n\t        }\n\n\t        node.cond = this.parseExpression();\n\t        this.advanceAfterBlockEnd(tag.value);\n\n\t        node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');\n\t        var tok = this.peekToken();\n\n\t        switch(tok && tok.value) {\n\t        case 'elseif':\n\t        case 'elif':\n\t            node.else_ = this.parseIf();\n\t            break;\n\t        case 'else':\n\t            this.advanceAfterBlockEnd();\n\t            node.else_ = this.parseUntilBlocks('endif');\n\t            this.advanceAfterBlockEnd();\n\t            break;\n\t        case 'endif':\n\t            node.else_ = null;\n\t            this.advanceAfterBlockEnd();\n\t            break;\n\t        default:\n\t            this.fail('parseIf: expected elif, else, or endif, ' +\n\t                      'got end of file');\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseSet: function() {\n\t        var tag = this.peekToken();\n\t        if(!this.skipSymbol('set')) {\n\t            this.fail('parseSet: expected set', tag.lineno, tag.colno);\n\t        }\n\n\t        var node = new nodes.Set(tag.lineno, tag.colno, []);\n\n\t        var target;\n\t        while((target = this.parsePrimary())) {\n\t            node.targets.push(target);\n\n\t            if(!this.skip(lexer.TOKEN_COMMA)) {\n\t                break;\n\t            }\n\t        }\n\n\t        if(!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {\n\t            if (!this.skip(lexer.TOKEN_BLOCK_END)) {\n\t                this.fail('parseSet: expected = or block end in set tag',\n\t                          tag.lineno,\n\t                          tag.colno);\n\t            }\n\t            else {\n\t                node.body = new nodes.Capture(\n\t                    tag.lineno,\n\t                    tag.colno,\n\t                    this.parseUntilBlocks('endset')\n\t                );\n\t                node.value = null;\n\t                this.advanceAfterBlockEnd();\n\t            }\n\t        }\n\t        else {\n\t            node.value = this.parseExpression();\n\t            this.advanceAfterBlockEnd(tag.value);\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseStatement: function () {\n\t        var tok = this.peekToken();\n\t        var node;\n\n\t        if(tok.type !== lexer.TOKEN_SYMBOL) {\n\t            this.fail('tag name expected', tok.lineno, tok.colno);\n\t        }\n\n\t        if(this.breakOnBlocks &&\n\t           lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {\n\t            return null;\n\t        }\n\n\t        switch(tok.value) {\n\t        case 'raw': return this.parseRaw();\n\t        case 'verbatim': return this.parseRaw('verbatim');\n\t        case 'if':\n\t        case 'ifAsync':\n\t            return this.parseIf();\n\t        case 'for':\n\t        case 'asyncEach':\n\t        case 'asyncAll':\n\t            return this.parseFor();\n\t        case 'block': return this.parseBlock();\n\t        case 'extends': return this.parseExtends();\n\t        case 'include': return this.parseInclude();\n\t        case 'set': return this.parseSet();\n\t        case 'macro': return this.parseMacro();\n\t        case 'call': return this.parseCall();\n\t        case 'import': return this.parseImport();\n\t        case 'from': return this.parseFrom();\n\t        case 'filter': return this.parseFilterStatement();\n\t        default:\n\t            if (this.extensions.length) {\n\t                for (var i = 0; i < this.extensions.length; i++) {\n\t                    var ext = this.extensions[i];\n\t                    if (lib.indexOf(ext.tags || [], tok.value) !== -1) {\n\t                        return ext.parse(this, nodes, lexer);\n\t                    }\n\t                }\n\t            }\n\t            this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseRaw: function(tagName) {\n\t        tagName = tagName || 'raw';\n\t        var endTagName = 'end' + tagName;\n\t        // Look for upcoming raw blocks (ignore all other kinds of blocks)\n\t        var rawBlockRegex = new RegExp('([\\\\s\\\\S]*?){%\\\\s*(' + tagName + '|' + endTagName + ')\\\\s*(?=%})%}');\n\t        var rawLevel = 1;\n\t        var str = '';\n\t        var matches = null;\n\n\t        // Skip opening raw token\n\t        // Keep this token to track line and column numbers\n\t        var begun = this.advanceAfterBlockEnd();\n\n\t        // Exit when there's nothing to match\n\t        // or when we've found the matching \"endraw\" block\n\t        while((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {\n\t            var all = matches[0];\n\t            var pre = matches[1];\n\t            var blockName = matches[2];\n\n\t            // Adjust rawlevel\n\t            if(blockName === tagName) {\n\t                rawLevel += 1;\n\t            } else if(blockName === endTagName) {\n\t                rawLevel -= 1;\n\t            }\n\n\t            // Add to str\n\t            if(rawLevel === 0) {\n\t                // We want to exclude the last \"endraw\"\n\t                str += pre;\n\t                // Move tokenizer to beginning of endraw block\n\t                this.tokens.backN(all.length - pre.length);\n\t            } else {\n\t                str += all;\n\t            }\n\t        }\n\n\t        return new nodes.Output(\n\t            begun.lineno,\n\t            begun.colno,\n\t            [new nodes.TemplateData(begun.lineno, begun.colno, str)]\n\t        );\n\t    },\n\n\t    parsePostfix: function(node) {\n\t        var lookup, tok = this.peekToken();\n\n\t        while(tok) {\n\t            if(tok.type === lexer.TOKEN_LEFT_PAREN) {\n\t                // Function call\n\t                node = new nodes.FunCall(tok.lineno,\n\t                                         tok.colno,\n\t                                         node,\n\t                                         this.parseSignature());\n\t            }\n\t            else if(tok.type === lexer.TOKEN_LEFT_BRACKET) {\n\t                // Reference\n\t                lookup = this.parseAggregate();\n\t                if(lookup.children.length > 1) {\n\t                    this.fail('invalid index');\n\t                }\n\n\t                node =  new nodes.LookupVal(tok.lineno,\n\t                                            tok.colno,\n\t                                            node,\n\t                                            lookup.children[0]);\n\t            }\n\t            else if(tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {\n\t                // Reference\n\t                this.nextToken();\n\t                var val = this.nextToken();\n\n\t                if(val.type !== lexer.TOKEN_SYMBOL) {\n\t                    this.fail('expected name as lookup value, got ' + val.value,\n\t                              val.lineno,\n\t                              val.colno);\n\t                }\n\n\t                // Make a literal string because it's not a variable\n\t                // reference\n\t                lookup = new nodes.Literal(val.lineno,\n\t                                               val.colno,\n\t                                               val.value);\n\n\t                node =  new nodes.LookupVal(tok.lineno,\n\t                                            tok.colno,\n\t                                            node,\n\t                                            lookup);\n\t            }\n\t            else {\n\t                break;\n\t            }\n\n\t            tok = this.peekToken();\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseExpression: function() {\n\t        var node = this.parseInlineIf();\n\t        return node;\n\t    },\n\n\t    parseInlineIf: function() {\n\t        var node = this.parseOr();\n\t        if(this.skipSymbol('if')) {\n\t            var cond_node = this.parseOr();\n\t            var body_node = node;\n\t            node = new nodes.InlineIf(node.lineno, node.colno);\n\t            node.body = body_node;\n\t            node.cond = cond_node;\n\t            if(this.skipSymbol('else')) {\n\t                node.else_ = this.parseOr();\n\t            } else {\n\t                node.else_ = null;\n\t            }\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseOr: function() {\n\t        var node = this.parseAnd();\n\t        while(this.skipSymbol('or')) {\n\t            var node2 = this.parseAnd();\n\t            node = new nodes.Or(node.lineno,\n\t                                node.colno,\n\t                                node,\n\t                                node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseAnd: function() {\n\t        var node = this.parseNot();\n\t        while(this.skipSymbol('and')) {\n\t            var node2 = this.parseNot();\n\t            node = new nodes.And(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseNot: function() {\n\t        var tok = this.peekToken();\n\t        if(this.skipSymbol('not')) {\n\t            return new nodes.Not(tok.lineno,\n\t                                 tok.colno,\n\t                                 this.parseNot());\n\t        }\n\t        return this.parseIn();\n\t    },\n\n\t    parseIn: function() {\n\t      var node = this.parseCompare();\n\t      while(1) {\n\t        // check if the next token is 'not'\n\t        var tok = this.nextToken();\n\t        if (!tok) { break; }\n\t        var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not';\n\t        // if it wasn't 'not', put it back\n\t        if (!invert) { this.pushToken(tok); }\n\t        if (this.skipSymbol('in')) {\n\t          var node2 = this.parseCompare();\n\t          node = new nodes.In(node.lineno,\n\t                              node.colno,\n\t                              node,\n\t                              node2);\n\t          if (invert) {\n\t            node = new nodes.Not(node.lineno,\n\t                                 node.colno,\n\t                                 node);\n\t          }\n\t        }\n\t        else {\n\t          // if we'd found a 'not' but this wasn't an 'in', put back the 'not'\n\t          if (invert) { this.pushToken(tok); }\n\t          break;\n\t        }\n\t      }\n\t      return node;\n\t    },\n\n\t    parseCompare: function() {\n\t        var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];\n\t        var expr = this.parseConcat();\n\t        var ops = [];\n\n\t        while(1) {\n\t            var tok = this.nextToken();\n\n\t            if(!tok) {\n\t                break;\n\t            }\n\t            else if(lib.indexOf(compareOps, tok.value) !== -1) {\n\t                ops.push(new nodes.CompareOperand(tok.lineno,\n\t                                                  tok.colno,\n\t                                                  this.parseConcat(),\n\t                                                  tok.value));\n\t            }\n\t            else {\n\t                this.pushToken(tok);\n\t                break;\n\t            }\n\t        }\n\n\t        if(ops.length) {\n\t            return new nodes.Compare(ops[0].lineno,\n\t                                     ops[0].colno,\n\t                                     expr,\n\t                                     ops);\n\t        }\n\t        else {\n\t            return expr;\n\t        }\n\t    },\n\n\t    // finds the '~' for string concatenation\n\t    parseConcat: function(){\n\t        var node = this.parseAdd();\n\t        while(this.skipValue(lexer.TOKEN_TILDE, '~')) {\n\t            var node2 = this.parseAdd();\n\t            node = new nodes.Concat(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseAdd: function() {\n\t        var node = this.parseSub();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {\n\t            var node2 = this.parseSub();\n\t            node = new nodes.Add(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseSub: function() {\n\t        var node = this.parseMul();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {\n\t            var node2 = this.parseMul();\n\t            node = new nodes.Sub(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseMul: function() {\n\t        var node = this.parseDiv();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '*')) {\n\t            var node2 = this.parseDiv();\n\t            node = new nodes.Mul(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseDiv: function() {\n\t        var node = this.parseFloorDiv();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '/')) {\n\t            var node2 = this.parseFloorDiv();\n\t            node = new nodes.Div(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseFloorDiv: function() {\n\t        var node = this.parseMod();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '//')) {\n\t            var node2 = this.parseMod();\n\t            node = new nodes.FloorDiv(node.lineno,\n\t                                      node.colno,\n\t                                      node,\n\t                                      node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseMod: function() {\n\t        var node = this.parsePow();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '%')) {\n\t            var node2 = this.parsePow();\n\t            node = new nodes.Mod(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parsePow: function() {\n\t        var node = this.parseUnary();\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '**')) {\n\t            var node2 = this.parseUnary();\n\t            node = new nodes.Pow(node.lineno,\n\t                                 node.colno,\n\t                                 node,\n\t                                 node2);\n\t        }\n\t        return node;\n\t    },\n\n\t    parseUnary: function(noFilters) {\n\t        var tok = this.peekToken();\n\t        var node;\n\n\t        if(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {\n\t            node = new nodes.Neg(tok.lineno,\n\t                                 tok.colno,\n\t                                 this.parseUnary(true));\n\t        }\n\t        else if(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {\n\t            node = new nodes.Pos(tok.lineno,\n\t                                 tok.colno,\n\t                                 this.parseUnary(true));\n\t        }\n\t        else {\n\t            node = this.parsePrimary();\n\t        }\n\n\t        if(!noFilters) {\n\t            node = this.parseFilter(node);\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parsePrimary: function (noPostfix) {\n\t        var tok = this.nextToken();\n\t        var val;\n\t        var node = null;\n\n\t        if(!tok) {\n\t            this.fail('expected expression, got end of file');\n\t        }\n\t        else if(tok.type === lexer.TOKEN_STRING) {\n\t            val = tok.value;\n\t        }\n\t        else if(tok.type === lexer.TOKEN_INT) {\n\t            val = parseInt(tok.value, 10);\n\t        }\n\t        else if(tok.type === lexer.TOKEN_FLOAT) {\n\t            val = parseFloat(tok.value);\n\t        }\n\t        else if(tok.type === lexer.TOKEN_BOOLEAN) {\n\t            if(tok.value === 'true') {\n\t                val = true;\n\t            }\n\t            else if(tok.value === 'false') {\n\t                val = false;\n\t            }\n\t            else {\n\t                this.fail('invalid boolean: ' + tok.value,\n\t                          tok.lineno,\n\t                          tok.colno);\n\t            }\n\t        }\n\t        else if(tok.type === lexer.TOKEN_NONE) {\n\t            val = null;\n\t        }\n\t        else if (tok.type === lexer.TOKEN_REGEX) {\n\t            val = new RegExp(tok.value.body, tok.value.flags);\n\t        }\n\n\t        if(val !== undefined) {\n\t            node = new nodes.Literal(tok.lineno, tok.colno, val);\n\t        }\n\t        else if(tok.type === lexer.TOKEN_SYMBOL) {\n\t            node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);\n\n\t            if(!noPostfix) {\n\t                node = this.parsePostfix(node);\n\t            }\n\t        }\n\t        else {\n\t            // See if it's an aggregate type, we need to push the\n\t            // current delimiter token back on\n\t            this.pushToken(tok);\n\t            node = this.parseAggregate();\n\t        }\n\n\t        if(node) {\n\t            return node;\n\t        }\n\t        else {\n\t            this.fail('unexpected token: ' + tok.value,\n\t                      tok.lineno,\n\t                      tok.colno);\n\t        }\n\t    },\n\n\t    parseFilterName: function() {\n\t        var tok = this.expect(lexer.TOKEN_SYMBOL);\n\t        var name = tok.value;\n\n\t        while(this.skipValue(lexer.TOKEN_OPERATOR, '.')) {\n\t            name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;\n\t        }\n\n\t        return new nodes.Symbol(tok.lineno, tok.colno, name);\n\t    },\n\n\t    parseFilterArgs: function(node) {\n\t        if(this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {\n\t            // Get a FunCall node and add the parameters to the\n\t            // filter\n\t            var call = this.parsePostfix(node);\n\t            return call.args.children;\n\t        }\n\t        return [];\n\t    },\n\n\t    parseFilter: function(node) {\n\t        while(this.skip(lexer.TOKEN_PIPE)) {\n\t            var name = this.parseFilterName();\n\n\t            node = new nodes.Filter(\n\t                name.lineno,\n\t                name.colno,\n\t                name,\n\t                new nodes.NodeList(\n\t                    name.lineno,\n\t                    name.colno,\n\t                    [node].concat(this.parseFilterArgs(node))\n\t                )\n\t            );\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseFilterStatement: function() {\n\t        var filterTok = this.peekToken();\n\t        if(!this.skipSymbol('filter')) {\n\t            this.fail('parseFilterStatement: expected filter');\n\t        }\n\n\t        var name = this.parseFilterName();\n\t        var args = this.parseFilterArgs(name);\n\n\t        this.advanceAfterBlockEnd(filterTok.value);\n\t        var body = new nodes.Capture(\n\t            name.lineno,\n\t            name.colno,\n\t            this.parseUntilBlocks('endfilter')\n\t        );\n\t        this.advanceAfterBlockEnd();\n\n\t        var node = new nodes.Filter(\n\t            name.lineno,\n\t            name.colno,\n\t            name,\n\t            new nodes.NodeList(\n\t                name.lineno,\n\t                name.colno,\n\t                [body].concat(args)\n\t            )\n\t        );\n\n\t        return new nodes.Output(\n\t            name.lineno,\n\t            name.colno,\n\t            [node]\n\t        );\n\t    },\n\n\t    parseAggregate: function() {\n\t        var tok = this.nextToken();\n\t        var node;\n\n\t        switch(tok.type) {\n\t        case lexer.TOKEN_LEFT_PAREN:\n\t            node = new nodes.Group(tok.lineno, tok.colno); break;\n\t        case lexer.TOKEN_LEFT_BRACKET:\n\t            node = new nodes.Array(tok.lineno, tok.colno); break;\n\t        case lexer.TOKEN_LEFT_CURLY:\n\t            node = new nodes.Dict(tok.lineno, tok.colno); break;\n\t        default:\n\t            return null;\n\t        }\n\n\t        while(1) {\n\t            var type = this.peekToken().type;\n\t            if(type === lexer.TOKEN_RIGHT_PAREN ||\n\t               type === lexer.TOKEN_RIGHT_BRACKET ||\n\t               type === lexer.TOKEN_RIGHT_CURLY) {\n\t                this.nextToken();\n\t                break;\n\t            }\n\n\t            if(node.children.length > 0) {\n\t                if(!this.skip(lexer.TOKEN_COMMA)) {\n\t                    this.fail('parseAggregate: expected comma after expression',\n\t                              tok.lineno,\n\t                              tok.colno);\n\t                }\n\t            }\n\n\t            if(node instanceof nodes.Dict) {\n\t                // TODO: check for errors\n\t                var key = this.parsePrimary();\n\n\t                // We expect a key/value pair for dicts, separated by a\n\t                // colon\n\t                if(!this.skip(lexer.TOKEN_COLON)) {\n\t                    this.fail('parseAggregate: expected colon after dict key',\n\t                        tok.lineno,\n\t                        tok.colno);\n\t                }\n\n\t                // TODO: check for errors\n\t                var value = this.parseExpression();\n\t                node.addChild(new nodes.Pair(key.lineno,\n\t                                             key.colno,\n\t                                             key,\n\t                                             value));\n\t            }\n\t            else {\n\t                // TODO: check for errors\n\t                var expr = this.parseExpression();\n\t                node.addChild(expr);\n\t            }\n\t        }\n\n\t        return node;\n\t    },\n\n\t    parseSignature: function(tolerant, noParens) {\n\t        var tok = this.peekToken();\n\t        if(!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {\n\t            if(tolerant) {\n\t                return null;\n\t            }\n\t            else {\n\t                this.fail('expected arguments', tok.lineno, tok.colno);\n\t            }\n\t        }\n\n\t        if(tok.type === lexer.TOKEN_LEFT_PAREN) {\n\t            tok = this.nextToken();\n\t        }\n\n\t        var args = new nodes.NodeList(tok.lineno, tok.colno);\n\t        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);\n\t        var checkComma = false;\n\n\t        while(1) {\n\t            tok = this.peekToken();\n\t            if(!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {\n\t                this.nextToken();\n\t                break;\n\t            }\n\t            else if(noParens && tok.type === lexer.TOKEN_BLOCK_END) {\n\t                break;\n\t            }\n\n\t            if(checkComma && !this.skip(lexer.TOKEN_COMMA)) {\n\t                this.fail('parseSignature: expected comma after expression',\n\t                          tok.lineno,\n\t                          tok.colno);\n\t            }\n\t            else {\n\t                var arg = this.parseExpression();\n\n\t                if(this.skipValue(lexer.TOKEN_OPERATOR, '=')) {\n\t                    kwargs.addChild(\n\t                        new nodes.Pair(arg.lineno,\n\t                                       arg.colno,\n\t                                       arg,\n\t                                       this.parseExpression())\n\t                    );\n\t                }\n\t                else {\n\t                    args.addChild(arg);\n\t                }\n\t            }\n\n\t            checkComma = true;\n\t        }\n\n\t        if(kwargs.children.length) {\n\t            args.addChild(kwargs);\n\t        }\n\n\t        return args;\n\t    },\n\n\t    parseUntilBlocks: function(/* blockNames */) {\n\t        var prev = this.breakOnBlocks;\n\t        this.breakOnBlocks = lib.toArray(arguments);\n\n\t        var ret = this.parse();\n\n\t        this.breakOnBlocks = prev;\n\t        return ret;\n\t    },\n\n\t    parseNodes: function () {\n\t        var tok;\n\t        var buf = [];\n\n\t        while((tok = this.nextToken())) {\n\t            if(tok.type === lexer.TOKEN_DATA) {\n\t                var data = tok.value;\n\t                var nextToken = this.peekToken();\n\t                var nextVal = nextToken && nextToken.value;\n\n\t                // If the last token has \"-\" we need to trim the\n\t                // leading whitespace of the data. This is marked with\n\t                // the `dropLeadingWhitespace` variable.\n\t                if(this.dropLeadingWhitespace) {\n\t                    // TODO: this could be optimized (don't use regex)\n\t                    data = data.replace(/^\\s*/, '');\n\t                    this.dropLeadingWhitespace = false;\n\t                }\n\n\t                // Same for the succeeding block start token\n\t                if(nextToken &&\n\t                    ((nextToken.type === lexer.TOKEN_BLOCK_START &&\n\t                      nextVal.charAt(nextVal.length - 1) === '-') ||\n\t                    (nextToken.type === lexer.TOKEN_VARIABLE_START &&\n\t                      nextVal.charAt(this.tokens.tags.VARIABLE_START.length)\n\t                        === '-') ||\n\t                    (nextToken.type === lexer.TOKEN_COMMENT &&\n\t                      nextVal.charAt(this.tokens.tags.COMMENT_START.length)\n\t                        === '-'))) {\n\t                    // TODO: this could be optimized (don't use regex)\n\t                    data = data.replace(/\\s*$/, '');\n\t                }\n\n\t                buf.push(new nodes.Output(tok.lineno,\n\t                                          tok.colno,\n\t                                          [new nodes.TemplateData(tok.lineno,\n\t                                                                  tok.colno,\n\t                                                                  data)]));\n\t            }\n\t            else if(tok.type === lexer.TOKEN_BLOCK_START) {\n\t                this.dropLeadingWhitespace = false;\n\t                var n = this.parseStatement();\n\t                if(!n) {\n\t                    break;\n\t                }\n\t                buf.push(n);\n\t            }\n\t            else if(tok.type === lexer.TOKEN_VARIABLE_START) {\n\t                var e = this.parseExpression();\n\t                this.dropLeadingWhitespace = false;\n\t                this.advanceAfterVariableEnd();\n\t                buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));\n\t            }\n\t            else if(tok.type === lexer.TOKEN_COMMENT) {\n\t                this.dropLeadingWhitespace = tok.value.charAt(\n\t                    tok.value.length - this.tokens.tags.COMMENT_END.length - 1\n\t                ) === '-';\n\t            } else {\n\t                // Ignore comments, otherwise this should be an error\n\t                this.fail('Unexpected token at top-level: ' +\n\t                                tok.type, tok.lineno, tok.colno);\n\n\t            }\n\t        }\n\n\t        return buf;\n\t    },\n\n\t    parse: function() {\n\t        return new nodes.NodeList(0, 0, this.parseNodes());\n\t    },\n\n\t    parseAsRoot: function() {\n\t        return new nodes.Root(0, 0, this.parseNodes());\n\t    }\n\t});\n\n\t// var util = require('util');\n\n\t// var l = lexer.lex('{%- if x -%}\\n hello {% endif %}');\n\t// var t;\n\t// while((t = l.nextToken())) {\n\t//     console.log(util.inspect(t));\n\t// }\n\n\t// var p = new Parser(lexer.lex('hello {% filter title %}' +\n\t//                              'Hello madam how are you' +\n\t//                              '{% endfilter %}'));\n\t// var n = p.parseAsRoot();\n\t// nodes.printNodes(n);\n\n\tmodule.exports = {\n\t    parse: function(src, extensions, opts) {\n\t        var p = new Parser(lexer.lex(src, opts));\n\t        if (extensions !== undefined) {\n\t            p.extensions = extensions;\n\t        }\n\t        return p.parseAsRoot();\n\t    }\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\n\tvar whitespaceChars = ' \\n\\t\\r\\u00A0';\n\tvar delimChars = '()[]{}%*-+~/#,:|.<>=!';\n\tvar intChars = '0123456789';\n\n\tvar BLOCK_START = '{%';\n\tvar BLOCK_END = '%}';\n\tvar VARIABLE_START = '{{';\n\tvar VARIABLE_END = '}}';\n\tvar COMMENT_START = '{#';\n\tvar COMMENT_END = '#}';\n\n\tvar TOKEN_STRING = 'string';\n\tvar TOKEN_WHITESPACE = 'whitespace';\n\tvar TOKEN_DATA = 'data';\n\tvar TOKEN_BLOCK_START = 'block-start';\n\tvar TOKEN_BLOCK_END = 'block-end';\n\tvar TOKEN_VARIABLE_START = 'variable-start';\n\tvar TOKEN_VARIABLE_END = 'variable-end';\n\tvar TOKEN_COMMENT = 'comment';\n\tvar TOKEN_LEFT_PAREN = 'left-paren';\n\tvar TOKEN_RIGHT_PAREN = 'right-paren';\n\tvar TOKEN_LEFT_BRACKET = 'left-bracket';\n\tvar TOKEN_RIGHT_BRACKET = 'right-bracket';\n\tvar TOKEN_LEFT_CURLY = 'left-curly';\n\tvar TOKEN_RIGHT_CURLY = 'right-curly';\n\tvar TOKEN_OPERATOR = 'operator';\n\tvar TOKEN_COMMA = 'comma';\n\tvar TOKEN_COLON = 'colon';\n\tvar TOKEN_TILDE = 'tilde';\n\tvar TOKEN_PIPE = 'pipe';\n\tvar TOKEN_INT = 'int';\n\tvar TOKEN_FLOAT = 'float';\n\tvar TOKEN_BOOLEAN = 'boolean';\n\tvar TOKEN_NONE = 'none';\n\tvar TOKEN_SYMBOL = 'symbol';\n\tvar TOKEN_SPECIAL = 'special';\n\tvar TOKEN_REGEX = 'regex';\n\n\tfunction token(type, value, lineno, colno) {\n\t    return {\n\t        type: type,\n\t        value: value,\n\t        lineno: lineno,\n\t        colno: colno\n\t    };\n\t}\n\n\tfunction Tokenizer(str, opts) {\n\t    this.str = str;\n\t    this.index = 0;\n\t    this.len = str.length;\n\t    this.lineno = 0;\n\t    this.colno = 0;\n\n\t    this.in_code = false;\n\n\t    opts = opts || {};\n\n\t    var tags = opts.tags || {};\n\t    this.tags = {\n\t        BLOCK_START: tags.blockStart || BLOCK_START,\n\t        BLOCK_END: tags.blockEnd || BLOCK_END,\n\t        VARIABLE_START: tags.variableStart || VARIABLE_START,\n\t        VARIABLE_END: tags.variableEnd || VARIABLE_END,\n\t        COMMENT_START: tags.commentStart || COMMENT_START,\n\t        COMMENT_END: tags.commentEnd || COMMENT_END\n\t    };\n\n\t    this.trimBlocks = !!opts.trimBlocks;\n\t    this.lstripBlocks = !!opts.lstripBlocks;\n\t}\n\n\tTokenizer.prototype.nextToken = function() {\n\t    var lineno = this.lineno;\n\t    var colno = this.colno;\n\t    var tok;\n\n\t    if(this.in_code) {\n\t        // Otherwise, if we are in a block parse it as code\n\t        var cur = this.current();\n\n\t        if(this.is_finished()) {\n\t            // We have nothing else to parse\n\t            return null;\n\t        }\n\t        else if(cur === '\"' || cur === '\\'') {\n\t            // We've hit a string\n\t            return token(TOKEN_STRING, this.parseString(cur), lineno, colno);\n\t        }\n\t        else if((tok = this._extract(whitespaceChars))) {\n\t            // We hit some whitespace\n\t            return token(TOKEN_WHITESPACE, tok, lineno, colno);\n\t        }\n\t        else if((tok = this._extractString(this.tags.BLOCK_END)) ||\n\t                (tok = this._extractString('-' + this.tags.BLOCK_END))) {\n\t            // Special check for the block end tag\n\t            //\n\t            // It is a requirement that start and end tags are composed of\n\t            // delimiter characters (%{}[] etc), and our code always\n\t            // breaks on delimiters so we can assume the token parsing\n\t            // doesn't consume these elsewhere\n\t            this.in_code = false;\n\t            if(this.trimBlocks) {\n\t                cur = this.current();\n\t                if(cur === '\\n') {\n\t                    // Skip newline\n\t                    this.forward();\n\t                }else if(cur === '\\r'){\n\t                    // Skip CRLF newline\n\t                    this.forward();\n\t                    cur = this.current();\n\t                    if(cur === '\\n'){\n\t                        this.forward();\n\t                    }else{\n\t                        // Was not a CRLF, so go back\n\t                        this.back();\n\t                    }\n\t                }\n\t            }\n\t            return token(TOKEN_BLOCK_END, tok, lineno, colno);\n\t        }\n\t        else if((tok = this._extractString(this.tags.VARIABLE_END)) ||\n\t                (tok = this._extractString('-' + this.tags.VARIABLE_END))) {\n\t            // Special check for variable end tag (see above)\n\t            this.in_code = false;\n\t            return token(TOKEN_VARIABLE_END, tok, lineno, colno);\n\t        }\n\t        else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {\n\t            // Skip past 'r/'.\n\t            this.forwardN(2);\n\n\t            // Extract until the end of the regex -- / ends it, \\/ does not.\n\t            var regexBody = '';\n\t            while (!this.is_finished()) {\n\t                if (this.current() === '/' && this.previous() !== '\\\\') {\n\t                    this.forward();\n\t                    break;\n\t                } else {\n\t                    regexBody += this.current();\n\t                    this.forward();\n\t                }\n\t            }\n\n\t            // Check for flags.\n\t            // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)\n\t            var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];\n\t            var regexFlags = '';\n\t            while (!this.is_finished()) {\n\t                var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;\n\t                if (isCurrentAFlag) {\n\t                    regexFlags += this.current();\n\t                    this.forward();\n\t                } else {\n\t                    break;\n\t                }\n\t            }\n\n\t            return token(TOKEN_REGEX, {body: regexBody, flags: regexFlags}, lineno, colno);\n\t        }\n\t        else if(delimChars.indexOf(cur) !== -1) {\n\t            // We've hit a delimiter (a special char like a bracket)\n\t            this.forward();\n\t            var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];\n\t            var curComplex = cur + this.current();\n\t            var type;\n\n\t            if(lib.indexOf(complexOps, curComplex) !== -1) {\n\t                this.forward();\n\t                cur = curComplex;\n\n\t                // See if this is a strict equality/inequality comparator\n\t                if(lib.indexOf(complexOps, curComplex + this.current()) !== -1) {\n\t                    cur = curComplex + this.current();\n\t                    this.forward();\n\t                }\n\t            }\n\n\t            switch(cur) {\n\t            case '(': type = TOKEN_LEFT_PAREN; break;\n\t            case ')': type = TOKEN_RIGHT_PAREN; break;\n\t            case '[': type = TOKEN_LEFT_BRACKET; break;\n\t            case ']': type = TOKEN_RIGHT_BRACKET; break;\n\t            case '{': type = TOKEN_LEFT_CURLY; break;\n\t            case '}': type = TOKEN_RIGHT_CURLY; break;\n\t            case ',': type = TOKEN_COMMA; break;\n\t            case ':': type = TOKEN_COLON; break;\n\t            case '~': type = TOKEN_TILDE; break;\n\t            case '|': type = TOKEN_PIPE; break;\n\t            default: type = TOKEN_OPERATOR;\n\t            }\n\n\t            return token(type, cur, lineno, colno);\n\t        }\n\t        else {\n\t            // We are not at whitespace or a delimiter, so extract the\n\t            // text and parse it\n\t            tok = this._extractUntil(whitespaceChars + delimChars);\n\n\t            if(tok.match(/^[-+]?[0-9]+$/)) {\n\t                if(this.current() === '.') {\n\t                    this.forward();\n\t                    var dec = this._extract(intChars);\n\t                    return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);\n\t                }\n\t                else {\n\t                    return token(TOKEN_INT, tok, lineno, colno);\n\t                }\n\t            }\n\t            else if(tok.match(/^(true|false)$/)) {\n\t                return token(TOKEN_BOOLEAN, tok, lineno, colno);\n\t            }\n\t            else if(tok === 'none') {\n\t                return token(TOKEN_NONE, tok, lineno, colno);\n\t            }\n\t            else if(tok) {\n\t                return token(TOKEN_SYMBOL, tok, lineno, colno);\n\t            }\n\t            else {\n\t                throw new Error('Unexpected value while parsing: ' + tok);\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        // Parse out the template text, breaking on tag\n\t        // delimiters because we need to look for block/variable start\n\t        // tags (don't use the full delimChars for optimization)\n\t        var beginChars = (this.tags.BLOCK_START.charAt(0) +\n\t                          this.tags.VARIABLE_START.charAt(0) +\n\t                          this.tags.COMMENT_START.charAt(0) +\n\t                          this.tags.COMMENT_END.charAt(0));\n\n\t        if(this.is_finished()) {\n\t            return null;\n\t        }\n\t        else if((tok = this._extractString(this.tags.BLOCK_START + '-')) ||\n\t                (tok = this._extractString(this.tags.BLOCK_START))) {\n\t            this.in_code = true;\n\t            return token(TOKEN_BLOCK_START, tok, lineno, colno);\n\t        }\n\t        else if((tok = this._extractString(this.tags.VARIABLE_START + '-')) ||\n\t                (tok = this._extractString(this.tags.VARIABLE_START))) {\n\t            this.in_code = true;\n\t            return token(TOKEN_VARIABLE_START, tok, lineno, colno);\n\t        }\n\t        else {\n\t            tok = '';\n\t            var data;\n\t            var in_comment = false;\n\n\t            if(this._matches(this.tags.COMMENT_START)) {\n\t                in_comment = true;\n\t                tok = this._extractString(this.tags.COMMENT_START);\n\t            }\n\n\t            // Continually consume text, breaking on the tag delimiter\n\t            // characters and checking to see if it's a start tag.\n\t            //\n\t            // We could hit the end of the template in the middle of\n\t            // our looping, so check for the null return value from\n\t            // _extractUntil\n\t            while((data = this._extractUntil(beginChars)) !== null) {\n\t                tok += data;\n\n\t                if((this._matches(this.tags.BLOCK_START) ||\n\t                    this._matches(this.tags.VARIABLE_START) ||\n\t                    this._matches(this.tags.COMMENT_START)) &&\n\t                  !in_comment) {\n\t                    if(this.lstripBlocks &&\n\t                        this._matches(this.tags.BLOCK_START) &&\n\t                        this.colno > 0 &&\n\t                        this.colno <= tok.length) {\n\t                        var lastLine = tok.slice(-this.colno);\n\t                        if(/^\\s+$/.test(lastLine)) {\n\t                            // Remove block leading whitespace from beginning of the string\n\t                            tok = tok.slice(0, -this.colno);\n\t                            if(!tok.length) {\n\t                                // All data removed, collapse to avoid unnecessary nodes\n\t                                // by returning next token (block start)\n\t                                return this.nextToken();\n\t                            }\n\t                        }\n\t                    }\n\t                    // If it is a start tag, stop looping\n\t                    break;\n\t                }\n\t                else if(this._matches(this.tags.COMMENT_END)) {\n\t                    if(!in_comment) {\n\t                        throw new Error('unexpected end of comment');\n\t                    }\n\t                    tok += this._extractString(this.tags.COMMENT_END);\n\t                    break;\n\t                }\n\t                else {\n\t                    // It does not match any tag, so add the character and\n\t                    // carry on\n\t                    tok += this.current();\n\t                    this.forward();\n\t                }\n\t            }\n\n\t            if(data === null && in_comment) {\n\t                throw new Error('expected end of comment, got end of file');\n\t            }\n\n\t            return token(in_comment ? TOKEN_COMMENT : TOKEN_DATA,\n\t                         tok,\n\t                         lineno,\n\t                         colno);\n\t        }\n\t    }\n\n\t    throw new Error('Could not parse text');\n\t};\n\n\tTokenizer.prototype.parseString = function(delimiter) {\n\t    this.forward();\n\n\t    var str = '';\n\n\t    while(!this.is_finished() && this.current() !== delimiter) {\n\t        var cur = this.current();\n\n\t        if(cur === '\\\\') {\n\t            this.forward();\n\t            switch(this.current()) {\n\t            case 'n': str += '\\n'; break;\n\t            case 't': str += '\\t'; break;\n\t            case 'r': str += '\\r'; break;\n\t            default:\n\t                str += this.current();\n\t            }\n\t            this.forward();\n\t        }\n\t        else {\n\t            str += cur;\n\t            this.forward();\n\t        }\n\t    }\n\n\t    this.forward();\n\t    return str;\n\t};\n\n\tTokenizer.prototype._matches = function(str) {\n\t    if(this.index + str.length > this.len) {\n\t        return null;\n\t    }\n\n\t    var m = this.str.slice(this.index, this.index + str.length);\n\t    return m === str;\n\t};\n\n\tTokenizer.prototype._extractString = function(str) {\n\t    if(this._matches(str)) {\n\t        this.index += str.length;\n\t        return str;\n\t    }\n\t    return null;\n\t};\n\n\tTokenizer.prototype._extractUntil = function(charString) {\n\t    // Extract all non-matching chars, with the default matching set\n\t    // to everything\n\t    return this._extractMatching(true, charString || '');\n\t};\n\n\tTokenizer.prototype._extract = function(charString) {\n\t    // Extract all matching chars (no default, so charString must be\n\t    // explicit)\n\t    return this._extractMatching(false, charString);\n\t};\n\n\tTokenizer.prototype._extractMatching = function (breakOnMatch, charString) {\n\t    // Pull out characters until a breaking char is hit.\n\t    // If breakOnMatch is false, a non-matching char stops it.\n\t    // If breakOnMatch is true, a matching char stops it.\n\n\t    if(this.is_finished()) {\n\t        return null;\n\t    }\n\n\t    var first = charString.indexOf(this.current());\n\n\t    // Only proceed if the first character doesn't meet our condition\n\t    if((breakOnMatch && first === -1) ||\n\t       (!breakOnMatch && first !== -1)) {\n\t        var t = this.current();\n\t        this.forward();\n\n\t        // And pull out all the chars one at a time until we hit a\n\t        // breaking char\n\t        var idx = charString.indexOf(this.current());\n\n\t        while(((breakOnMatch && idx === -1) ||\n\t               (!breakOnMatch && idx !== -1)) && !this.is_finished()) {\n\t            t += this.current();\n\t            this.forward();\n\n\t            idx = charString.indexOf(this.current());\n\t        }\n\n\t        return t;\n\t    }\n\n\t    return '';\n\t};\n\n\tTokenizer.prototype._extractRegex = function(regex) {\n\t    var matches = this.currentStr().match(regex);\n\t    if(!matches) {\n\t        return null;\n\t    }\n\n\t    // Move forward whatever was matched\n\t    this.forwardN(matches[0].length);\n\n\t    return matches;\n\t};\n\n\tTokenizer.prototype.is_finished = function() {\n\t    return this.index >= this.len;\n\t};\n\n\tTokenizer.prototype.forwardN = function(n) {\n\t    for(var i=0; i<n; i++) {\n\t        this.forward();\n\t    }\n\t};\n\n\tTokenizer.prototype.forward = function() {\n\t    this.index++;\n\n\t    if(this.previous() === '\\n') {\n\t        this.lineno++;\n\t        this.colno = 0;\n\t    }\n\t    else {\n\t        this.colno++;\n\t    }\n\t};\n\n\tTokenizer.prototype.backN = function(n) {\n\t    for(var i=0; i<n; i++) {\n\t        this.back();\n\t    }\n\t};\n\n\tTokenizer.prototype.back = function() {\n\t    this.index--;\n\n\t    if(this.current() === '\\n') {\n\t        this.lineno--;\n\n\t        var idx = this.src.lastIndexOf('\\n', this.index-1);\n\t        if(idx === -1) {\n\t            this.colno = this.index;\n\t        }\n\t        else {\n\t            this.colno = this.index - idx;\n\t        }\n\t    }\n\t    else {\n\t        this.colno--;\n\t    }\n\t};\n\n\t// current returns current character\n\tTokenizer.prototype.current = function() {\n\t    if(!this.is_finished()) {\n\t        return this.str.charAt(this.index);\n\t    }\n\t    return '';\n\t};\n\n\t// currentStr returns what's left of the unparsed string\n\tTokenizer.prototype.currentStr = function() {\n\t    if(!this.is_finished()) {\n\t        return this.str.substr(this.index);\n\t    }\n\t    return '';\n\t};\n\n\tTokenizer.prototype.previous = function() {\n\t    return this.str.charAt(this.index-1);\n\t};\n\n\tmodule.exports = {\n\t    lex: function(src, opts) {\n\t        return new Tokenizer(src, opts);\n\t    },\n\n\t    TOKEN_STRING: TOKEN_STRING,\n\t    TOKEN_WHITESPACE: TOKEN_WHITESPACE,\n\t    TOKEN_DATA: TOKEN_DATA,\n\t    TOKEN_BLOCK_START: TOKEN_BLOCK_START,\n\t    TOKEN_BLOCK_END: TOKEN_BLOCK_END,\n\t    TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,\n\t    TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,\n\t    TOKEN_COMMENT: TOKEN_COMMENT,\n\t    TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,\n\t    TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,\n\t    TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,\n\t    TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,\n\t    TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,\n\t    TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,\n\t    TOKEN_OPERATOR: TOKEN_OPERATOR,\n\t    TOKEN_COMMA: TOKEN_COMMA,\n\t    TOKEN_COLON: TOKEN_COLON,\n\t    TOKEN_TILDE: TOKEN_TILDE,\n\t    TOKEN_PIPE: TOKEN_PIPE,\n\t    TOKEN_INT: TOKEN_INT,\n\t    TOKEN_FLOAT: TOKEN_FLOAT,\n\t    TOKEN_BOOLEAN: TOKEN_BOOLEAN,\n\t    TOKEN_NONE: TOKEN_NONE,\n\t    TOKEN_SYMBOL: TOKEN_SYMBOL,\n\t    TOKEN_SPECIAL: TOKEN_SPECIAL,\n\t    TOKEN_REGEX: TOKEN_REGEX\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\n\tvar lib = __webpack_require__(1);\n\t// jshint -W079\n\tvar Object = __webpack_require__(6);\n\n\tfunction traverseAndCheck(obj, type, results) {\n\t    if(obj instanceof type) {\n\t        results.push(obj);\n\t    }\n\n\t    if(obj instanceof Node) {\n\t        obj.findAll(type, results);\n\t    }\n\t}\n\n\tvar Node = Object.extend('Node', {\n\t    init: function(lineno, colno) {\n\t        this.lineno = lineno;\n\t        this.colno = colno;\n\n\t        var fields = this.fields;\n\t        for(var i = 0, l = fields.length; i < l; i++) {\n\t            var field = fields[i];\n\n\t            // The first two args are line/col numbers, so offset by 2\n\t            var val = arguments[i + 2];\n\n\t            // Fields should never be undefined, but null. It makes\n\t            // testing easier to normalize values.\n\t            if(val === undefined) {\n\t                val = null;\n\t            }\n\n\t            this[field] = val;\n\t        }\n\t    },\n\n\t    findAll: function(type, results) {\n\t        results = results || [];\n\n\t        var i, l;\n\t        if(this instanceof NodeList) {\n\t            var children = this.children;\n\n\t            for(i = 0, l = children.length; i < l; i++) {\n\t                traverseAndCheck(children[i], type, results);\n\t            }\n\t        }\n\t        else {\n\t            var fields = this.fields;\n\n\t            for(i = 0, l = fields.length; i < l; i++) {\n\t                traverseAndCheck(this[fields[i]], type, results);\n\t            }\n\t        }\n\n\t        return results;\n\t    },\n\n\t    iterFields: function(func) {\n\t        lib.each(this.fields, function(field) {\n\t            func(this[field], field);\n\t        }, this);\n\t    }\n\t});\n\n\t// Abstract nodes\n\tvar Value = Node.extend('Value', { fields: ['value'] });\n\n\t// Concrete nodes\n\tvar NodeList = Node.extend('NodeList', {\n\t    fields: ['children'],\n\n\t    init: function(lineno, colno, nodes) {\n\t        this.parent(lineno, colno, nodes || []);\n\t    },\n\n\t    addChild: function(node) {\n\t        this.children.push(node);\n\t    }\n\t});\n\n\tvar Root = NodeList.extend('Root');\n\tvar Literal = Value.extend('Literal');\n\tvar Symbol = Value.extend('Symbol');\n\tvar Group = NodeList.extend('Group');\n\tvar Array = NodeList.extend('Array');\n\tvar Pair = Node.extend('Pair', { fields: ['key', 'value'] });\n\tvar Dict = NodeList.extend('Dict');\n\tvar LookupVal = Node.extend('LookupVal', { fields: ['target', 'val'] });\n\tvar If = Node.extend('If', { fields: ['cond', 'body', 'else_'] });\n\tvar IfAsync = If.extend('IfAsync');\n\tvar InlineIf = Node.extend('InlineIf', { fields: ['cond', 'body', 'else_'] });\n\tvar For = Node.extend('For', { fields: ['arr', 'name', 'body', 'else_'] });\n\tvar AsyncEach = For.extend('AsyncEach');\n\tvar AsyncAll = For.extend('AsyncAll');\n\tvar Macro = Node.extend('Macro', { fields: ['name', 'args', 'body'] });\n\tvar Caller = Macro.extend('Caller');\n\tvar Import = Node.extend('Import', { fields: ['template', 'target', 'withContext'] });\n\tvar FromImport = Node.extend('FromImport', {\n\t    fields: ['template', 'names', 'withContext'],\n\n\t    init: function(lineno, colno, template, names, withContext) {\n\t        this.parent(lineno, colno,\n\t                    template,\n\t                    names || new NodeList(), withContext);\n\t    }\n\t});\n\tvar FunCall = Node.extend('FunCall', { fields: ['name', 'args'] });\n\tvar Filter = FunCall.extend('Filter');\n\tvar FilterAsync = Filter.extend('FilterAsync', {\n\t    fields: ['name', 'args', 'symbol']\n\t});\n\tvar KeywordArgs = Dict.extend('KeywordArgs');\n\tvar Block = Node.extend('Block', { fields: ['name', 'body'] });\n\tvar Super = Node.extend('Super', { fields: ['blockName', 'symbol'] });\n\tvar TemplateRef = Node.extend('TemplateRef', { fields: ['template'] });\n\tvar Extends = TemplateRef.extend('Extends');\n\tvar Include = Node.extend('Include', { fields: ['template', 'ignoreMissing'] });\n\tvar Set = Node.extend('Set', { fields: ['targets', 'value'] });\n\tvar Output = NodeList.extend('Output');\n\tvar Capture = Node.extend('Capture', { fields: ['body'] });\n\tvar TemplateData = Literal.extend('TemplateData');\n\tvar UnaryOp = Node.extend('UnaryOp', { fields: ['target'] });\n\tvar BinOp = Node.extend('BinOp', { fields: ['left', 'right'] });\n\tvar In = BinOp.extend('In');\n\tvar Or = BinOp.extend('Or');\n\tvar And = BinOp.extend('And');\n\tvar Not = UnaryOp.extend('Not');\n\tvar Add = BinOp.extend('Add');\n\tvar Concat = BinOp.extend('Concat');\n\tvar Sub = BinOp.extend('Sub');\n\tvar Mul = BinOp.extend('Mul');\n\tvar Div = BinOp.extend('Div');\n\tvar FloorDiv = BinOp.extend('FloorDiv');\n\tvar Mod = BinOp.extend('Mod');\n\tvar Pow = BinOp.extend('Pow');\n\tvar Neg = UnaryOp.extend('Neg');\n\tvar Pos = UnaryOp.extend('Pos');\n\tvar Compare = Node.extend('Compare', { fields: ['expr', 'ops'] });\n\tvar CompareOperand = Node.extend('CompareOperand', {\n\t    fields: ['expr', 'type']\n\t});\n\n\tvar CallExtension = Node.extend('CallExtension', {\n\t    fields: ['extName', 'prop', 'args', 'contentArgs'],\n\n\t    init: function(ext, prop, args, contentArgs) {\n\t        this.extName = ext._name || ext;\n\t        this.prop = prop;\n\t        this.args = args || new NodeList();\n\t        this.contentArgs = contentArgs || [];\n\t        this.autoescape = ext.autoescape;\n\t    }\n\t});\n\n\tvar CallExtensionAsync = CallExtension.extend('CallExtensionAsync');\n\n\t// Print the AST in a nicely formatted tree format for debuggin\n\tfunction printNodes(node, indent) {\n\t    indent = indent || 0;\n\n\t    // This is hacky, but this is just a debugging function anyway\n\t    function print(str, indent, inline) {\n\t        var lines = str.split('\\n');\n\n\t        for(var i=0; i<lines.length; i++) {\n\t            if(lines[i]) {\n\t                if((inline && i > 0) || !inline) {\n\t                    for(var j=0; j<indent; j++) {\n\t                        process.stdout.write(' ');\n\t                    }\n\t                }\n\t            }\n\n\t            if(i === lines.length-1) {\n\t                process.stdout.write(lines[i]);\n\t            }\n\t            else {\n\t                process.stdout.write(lines[i] + '\\n');\n\t            }\n\t        }\n\t    }\n\n\t    print(node.typename + ': ', indent);\n\n\t    if(node instanceof NodeList) {\n\t        print('\\n');\n\t        lib.each(node.children, function(n) {\n\t            printNodes(n, indent + 2);\n\t        });\n\t    }\n\t    else if(node instanceof CallExtension) {\n\t        print(node.extName + '.' + node.prop);\n\t        print('\\n');\n\n\t        if(node.args) {\n\t            printNodes(node.args, indent + 2);\n\t        }\n\n\t        if(node.contentArgs) {\n\t            lib.each(node.contentArgs, function(n) {\n\t                printNodes(n, indent + 2);\n\t            });\n\t        }\n\t    }\n\t    else {\n\t        var nodes = null;\n\t        var props = null;\n\n\t        node.iterFields(function(val, field) {\n\t            if(val instanceof Node) {\n\t                nodes = nodes || {};\n\t                nodes[field] = val;\n\t            }\n\t            else {\n\t                props = props || {};\n\t                props[field] = val;\n\t            }\n\t        });\n\n\t        if(props) {\n\t            print(JSON.stringify(props, null, 2) + '\\n', null, true);\n\t        }\n\t        else {\n\t            print('\\n');\n\t        }\n\n\t        if(nodes) {\n\t            for(var k in nodes) {\n\t                printNodes(nodes[k], indent + 2);\n\t            }\n\t        }\n\n\t    }\n\t}\n\n\t// var t = new NodeList(0, 0,\n\t//                      [new Value(0, 0, 3),\n\t//                       new Value(0, 0, 10),\n\t//                       new Pair(0, 0,\n\t//                                new Value(0, 0, 'key'),\n\t//                                new Value(0, 0, 'value'))]);\n\t// printNodes(t);\n\n\tmodule.exports = {\n\t    Node: Node,\n\t    Root: Root,\n\t    NodeList: NodeList,\n\t    Value: Value,\n\t    Literal: Literal,\n\t    Symbol: Symbol,\n\t    Group: Group,\n\t    Array: Array,\n\t    Pair: Pair,\n\t    Dict: Dict,\n\t    Output: Output,\n\t    Capture: Capture,\n\t    TemplateData: TemplateData,\n\t    If: If,\n\t    IfAsync: IfAsync,\n\t    InlineIf: InlineIf,\n\t    For: For,\n\t    AsyncEach: AsyncEach,\n\t    AsyncAll: AsyncAll,\n\t    Macro: Macro,\n\t    Caller: Caller,\n\t    Import: Import,\n\t    FromImport: FromImport,\n\t    FunCall: FunCall,\n\t    Filter: Filter,\n\t    FilterAsync: FilterAsync,\n\t    KeywordArgs: KeywordArgs,\n\t    Block: Block,\n\t    Super: Super,\n\t    Extends: Extends,\n\t    Include: Include,\n\t    Set: Set,\n\t    LookupVal: LookupVal,\n\t    BinOp: BinOp,\n\t    In: In,\n\t    Or: Or,\n\t    And: And,\n\t    Not: Not,\n\t    Add: Add,\n\t    Concat: Concat,\n\t    Sub: Sub,\n\t    Mul: Mul,\n\t    Div: Div,\n\t    FloorDiv: FloorDiv,\n\t    Mod: Mod,\n\t    Pow: Pow,\n\t    Neg: Neg,\n\t    Pos: Pos,\n\t    Compare: Compare,\n\t    CompareOperand: CompareOperand,\n\n\t    CallExtension: CallExtension,\n\t    CallExtensionAsync: CallExtensionAsync,\n\n\t    printNodes: printNodes\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar nodes = __webpack_require__(10);\n\tvar lib = __webpack_require__(1);\n\n\tvar sym = 0;\n\tfunction gensym() {\n\t    return 'hole_' + sym++;\n\t}\n\n\t// copy-on-write version of map\n\tfunction mapCOW(arr, func) {\n\t    var res = null;\n\n\t    for(var i=0; i<arr.length; i++) {\n\t        var item = func(arr[i]);\n\n\t        if(item !== arr[i]) {\n\t            if(!res) {\n\t                res = arr.slice();\n\t            }\n\n\t            res[i] = item;\n\t        }\n\t    }\n\n\t    return res || arr;\n\t}\n\n\tfunction walk(ast, func, depthFirst) {\n\t    if(!(ast instanceof nodes.Node)) {\n\t        return ast;\n\t    }\n\n\t    if(!depthFirst) {\n\t        var astT = func(ast);\n\n\t        if(astT && astT !== ast) {\n\t            return astT;\n\t        }\n\t    }\n\n\t    if(ast instanceof nodes.NodeList) {\n\t        var children = mapCOW(ast.children, function(node) {\n\t            return walk(node, func, depthFirst);\n\t        });\n\n\t        if(children !== ast.children) {\n\t            ast = new nodes[ast.typename](ast.lineno, ast.colno, children);\n\t        }\n\t    }\n\t    else if(ast instanceof nodes.CallExtension) {\n\t        var args = walk(ast.args, func, depthFirst);\n\n\t        var contentArgs = mapCOW(ast.contentArgs, function(node) {\n\t            return walk(node, func, depthFirst);\n\t        });\n\n\t        if(args !== ast.args || contentArgs !== ast.contentArgs) {\n\t            ast = new nodes[ast.typename](ast.extName,\n\t                                          ast.prop,\n\t                                          args,\n\t                                          contentArgs);\n\t        }\n\t    }\n\t    else {\n\t        var props = ast.fields.map(function(field) {\n\t            return ast[field];\n\t        });\n\n\t        var propsT = mapCOW(props, function(prop) {\n\t            return walk(prop, func, depthFirst);\n\t        });\n\n\t        if(propsT !== props) {\n\t            ast = new nodes[ast.typename](ast.lineno, ast.colno);\n\n\t            propsT.forEach(function(prop, i) {\n\t                ast[ast.fields[i]] = prop;\n\t            });\n\t        }\n\t    }\n\n\t    return depthFirst ? (func(ast) || ast) : ast;\n\t}\n\n\tfunction depthWalk(ast, func) {\n\t    return walk(ast, func, true);\n\t}\n\n\tfunction _liftFilters(node, asyncFilters, prop) {\n\t    var children = [];\n\n\t    var walked = depthWalk(prop ? node[prop] : node, function(node) {\n\t        if(node instanceof nodes.Block) {\n\t            return node;\n\t        }\n\t        else if((node instanceof nodes.Filter &&\n\t                 lib.indexOf(asyncFilters, node.name.value) !== -1) ||\n\t                node instanceof nodes.CallExtensionAsync) {\n\t            var symbol = new nodes.Symbol(node.lineno,\n\t                                          node.colno,\n\t                                          gensym());\n\n\t            children.push(new nodes.FilterAsync(node.lineno,\n\t                                                node.colno,\n\t                                                node.name,\n\t                                                node.args,\n\t                                                symbol));\n\t            return symbol;\n\t        }\n\t    });\n\n\t    if(prop) {\n\t        node[prop] = walked;\n\t    }\n\t    else {\n\t        node = walked;\n\t    }\n\n\t    if(children.length) {\n\t        children.push(node);\n\n\t        return new nodes.NodeList(\n\t            node.lineno,\n\t            node.colno,\n\t            children\n\t        );\n\t    }\n\t    else {\n\t        return node;\n\t    }\n\t}\n\n\tfunction liftFilters(ast, asyncFilters) {\n\t    return depthWalk(ast, function(node) {\n\t        if(node instanceof nodes.Output) {\n\t            return _liftFilters(node, asyncFilters);\n\t        }\n\t        else if(node instanceof nodes.Set) {\n\t            return _liftFilters(node, asyncFilters, 'value');\n\t        }\n\t        else if(node instanceof nodes.For) {\n\t            return _liftFilters(node, asyncFilters, 'arr');\n\t        }\n\t        else if(node instanceof nodes.If) {\n\t            return _liftFilters(node, asyncFilters, 'cond');\n\t        }\n\t        else if(node instanceof nodes.CallExtension) {\n\t            return _liftFilters(node, asyncFilters, 'args');\n\t        }\n\t    });\n\t}\n\n\tfunction liftSuper(ast) {\n\t    return walk(ast, function(blockNode) {\n\t        if(!(blockNode instanceof nodes.Block)) {\n\t            return;\n\t        }\n\n\t        var hasSuper = false;\n\t        var symbol = gensym();\n\n\t        blockNode.body = walk(blockNode.body, function(node) {\n\t            if(node instanceof nodes.FunCall &&\n\t               node.name.value === 'super') {\n\t                hasSuper = true;\n\t                return new nodes.Symbol(node.lineno, node.colno, symbol);\n\t            }\n\t        });\n\n\t        if(hasSuper) {\n\t            blockNode.body.children.unshift(new nodes.Super(\n\t                0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)\n\t            ));\n\t        }\n\t    });\n\t}\n\n\tfunction convertStatements(ast) {\n\t    return depthWalk(ast, function(node) {\n\t        if(!(node instanceof nodes.If) &&\n\t           !(node instanceof nodes.For)) {\n\t            return;\n\t        }\n\n\t        var async = false;\n\t        walk(node, function(node) {\n\t            if(node instanceof nodes.FilterAsync ||\n\t               node instanceof nodes.IfAsync ||\n\t               node instanceof nodes.AsyncEach ||\n\t               node instanceof nodes.AsyncAll ||\n\t               node instanceof nodes.CallExtensionAsync) {\n\t                async = true;\n\t                // Stop iterating by returning the node\n\t                return node;\n\t            }\n\t        });\n\n\t        if(async) {\n\t\t        if(node instanceof nodes.If) {\n\t                return new nodes.IfAsync(\n\t                    node.lineno,\n\t                    node.colno,\n\t                    node.cond,\n\t                    node.body,\n\t                    node.else_\n\t                );\n\t            }\n\t            else if(node instanceof nodes.For) {\n\t                return new nodes.AsyncEach(\n\t                    node.lineno,\n\t                    node.colno,\n\t                    node.arr,\n\t                    node.name,\n\t                    node.body,\n\t                    node.else_\n\t                );\n\t            }\n\t        }\n\t    });\n\t}\n\n\tfunction cps(ast, asyncFilters) {\n\t    return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));\n\t}\n\n\tfunction transform(ast, asyncFilters) {\n\t    return cps(ast, asyncFilters || []);\n\t}\n\n\t// var parser = require('./parser');\n\t// var src = 'hello {% foo %}{% endfoo %} end';\n\t// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);\n\t// nodes.printNodes(ast);\n\n\tmodule.exports = {\n\t    transform: transform\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar Obj = __webpack_require__(6);\n\n\t// Frames keep track of scoping both at compile-time and run-time so\n\t// we know how to access variables. Block tags can introduce special\n\t// variables, for example.\n\tvar Frame = Obj.extend({\n\t    init: function(parent, isolateWrites) {\n\t        this.variables = {};\n\t        this.parent = parent;\n\t        this.topLevel = false;\n\t        // if this is true, writes (set) should never propagate upwards past\n\t        // this frame to its parent (though reads may).\n\t        this.isolateWrites = isolateWrites;\n\t    },\n\n\t    set: function(name, val, resolveUp) {\n\t        // Allow variables with dots by automatically creating the\n\t        // nested structure\n\t        var parts = name.split('.');\n\t        var obj = this.variables;\n\t        var frame = this;\n\n\t        if(resolveUp) {\n\t            if((frame = this.resolve(parts[0], true))) {\n\t                frame.set(name, val);\n\t                return;\n\t            }\n\t        }\n\n\t        for(var i=0; i<parts.length - 1; i++) {\n\t            var id = parts[i];\n\n\t            if(!obj[id]) {\n\t                obj[id] = {};\n\t            }\n\t            obj = obj[id];\n\t        }\n\n\t        obj[parts[parts.length - 1]] = val;\n\t    },\n\n\t    get: function(name) {\n\t        var val = this.variables[name];\n\t        if(val !== undefined) {\n\t            return val;\n\t        }\n\t        return null;\n\t    },\n\n\t    lookup: function(name) {\n\t        var p = this.parent;\n\t        var val = this.variables[name];\n\t        if(val !== undefined) {\n\t            return val;\n\t        }\n\t        return p && p.lookup(name);\n\t    },\n\n\t    resolve: function(name, forWrite) {\n\t        var p = (forWrite && this.isolateWrites) ? undefined : this.parent;\n\t        var val = this.variables[name];\n\t        if(val !== undefined) {\n\t            return this;\n\t        }\n\t        return p && p.resolve(name);\n\t    },\n\n\t    push: function(isolateWrites) {\n\t        return new Frame(this, isolateWrites);\n\t    },\n\n\t    pop: function() {\n\t        return this.parent;\n\t    }\n\t});\n\n\tfunction makeMacro(argNames, kwargNames, func) {\n\t    return function() {\n\t        var argCount = numArgs(arguments);\n\t        var args;\n\t        var kwargs = getKeywordArgs(arguments);\n\t        var i;\n\n\t        if(argCount > argNames.length) {\n\t            args = Array.prototype.slice.call(arguments, 0, argNames.length);\n\n\t            // Positional arguments that should be passed in as\n\t            // keyword arguments (essentially default values)\n\t            var vals = Array.prototype.slice.call(arguments, args.length, argCount);\n\t            for(i = 0; i < vals.length; i++) {\n\t                if(i < kwargNames.length) {\n\t                    kwargs[kwargNames[i]] = vals[i];\n\t                }\n\t            }\n\n\t            args.push(kwargs);\n\t        }\n\t        else if(argCount < argNames.length) {\n\t            args = Array.prototype.slice.call(arguments, 0, argCount);\n\n\t            for(i = argCount; i < argNames.length; i++) {\n\t                var arg = argNames[i];\n\n\t                // Keyword arguments that should be passed as\n\t                // positional arguments, i.e. the caller explicitly\n\t                // used the name of a positional arg\n\t                args.push(kwargs[arg]);\n\t                delete kwargs[arg];\n\t            }\n\n\t            args.push(kwargs);\n\t        }\n\t        else {\n\t            args = arguments;\n\t        }\n\n\t        return func.apply(this, args);\n\t    };\n\t}\n\n\tfunction makeKeywordArgs(obj) {\n\t    obj.__keywords = true;\n\t    return obj;\n\t}\n\n\tfunction getKeywordArgs(args) {\n\t    var len = args.length;\n\t    if(len) {\n\t        var lastArg = args[len - 1];\n\t        if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n\t            return lastArg;\n\t        }\n\t    }\n\t    return {};\n\t}\n\n\tfunction numArgs(args) {\n\t    var len = args.length;\n\t    if(len === 0) {\n\t        return 0;\n\t    }\n\n\t    var lastArg = args[len - 1];\n\t    if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n\t        return len - 1;\n\t    }\n\t    else {\n\t        return len;\n\t    }\n\t}\n\n\t// A SafeString object indicates that the string should not be\n\t// autoescaped. This happens magically because autoescaping only\n\t// occurs on primitive string objects.\n\tfunction SafeString(val) {\n\t    if(typeof val !== 'string') {\n\t        return val;\n\t    }\n\n\t    this.val = val;\n\t    this.length = val.length;\n\t}\n\n\tSafeString.prototype = Object.create(String.prototype, {\n\t    length: { writable: true, configurable: true, value: 0 }\n\t});\n\tSafeString.prototype.valueOf = function() {\n\t    return this.val;\n\t};\n\tSafeString.prototype.toString = function() {\n\t    return this.val;\n\t};\n\n\tfunction copySafeness(dest, target) {\n\t    if(dest instanceof SafeString) {\n\t        return new SafeString(target);\n\t    }\n\t    return target.toString();\n\t}\n\n\tfunction markSafe(val) {\n\t    var type = typeof val;\n\n\t    if(type === 'string') {\n\t        return new SafeString(val);\n\t    }\n\t    else if(type !== 'function') {\n\t        return val;\n\t    }\n\t    else {\n\t        return function() {\n\t            var ret = val.apply(this, arguments);\n\n\t            if(typeof ret === 'string') {\n\t                return new SafeString(ret);\n\t            }\n\n\t            return ret;\n\t        };\n\t    }\n\t}\n\n\tfunction suppressValue(val, autoescape) {\n\t    val = (val !== undefined && val !== null) ? val : '';\n\n\t    if(autoescape && !(val instanceof SafeString)) {\n\t        val = lib.escape(val.toString());\n\t    }\n\n\t    return val;\n\t}\n\n\tfunction ensureDefined(val, lineno, colno) {\n\t    if(val === null || val === undefined) {\n\t        throw new lib.TemplateError(\n\t            'attempted to output null or undefined value',\n\t            lineno + 1,\n\t            colno + 1\n\t        );\n\t    }\n\t    return val;\n\t}\n\n\tfunction memberLookup(obj, val) {\n\t    obj = obj || {};\n\n\t    if(typeof obj[val] === 'function') {\n\t        return function() {\n\t            return obj[val].apply(obj, arguments);\n\t        };\n\t    }\n\n\t    return obj[val];\n\t}\n\n\tfunction callWrap(obj, name, context, args) {\n\t    if(!obj) {\n\t        throw new Error('Unable to call `' + name + '`, which is undefined or falsey');\n\t    }\n\t    else if(typeof obj !== 'function') {\n\t        throw new Error('Unable to call `' + name + '`, which is not a function');\n\t    }\n\n\t    // jshint validthis: true\n\t    return obj.apply(context, args);\n\t}\n\n\tfunction contextOrFrameLookup(context, frame, name) {\n\t    var val = frame.lookup(name);\n\t    return (val !== undefined) ?\n\t        val :\n\t        context.lookup(name);\n\t}\n\n\tfunction handleError(error, lineno, colno) {\n\t    if(error.lineno) {\n\t        return error;\n\t    }\n\t    else {\n\t        return new lib.TemplateError(error, lineno, colno);\n\t    }\n\t}\n\n\tfunction asyncEach(arr, dimen, iter, cb) {\n\t    if(lib.isArray(arr)) {\n\t        var len = arr.length;\n\n\t        lib.asyncIter(arr, function(item, i, next) {\n\t            switch(dimen) {\n\t            case 1: iter(item, i, len, next); break;\n\t            case 2: iter(item[0], item[1], i, len, next); break;\n\t            case 3: iter(item[0], item[1], item[2], i, len, next); break;\n\t            default:\n\t                item.push(i, next);\n\t                iter.apply(this, item);\n\t            }\n\t        }, cb);\n\t    }\n\t    else {\n\t        lib.asyncFor(arr, function(key, val, i, len, next) {\n\t            iter(key, val, i, len, next);\n\t        }, cb);\n\t    }\n\t}\n\n\tfunction asyncAll(arr, dimen, func, cb) {\n\t    var finished = 0;\n\t    var len, i;\n\t    var outputArr;\n\n\t    function done(i, output) {\n\t        finished++;\n\t        outputArr[i] = output;\n\n\t        if(finished === len) {\n\t            cb(null, outputArr.join(''));\n\t        }\n\t    }\n\n\t    if(lib.isArray(arr)) {\n\t        len = arr.length;\n\t        outputArr = new Array(len);\n\n\t        if(len === 0) {\n\t            cb(null, '');\n\t        }\n\t        else {\n\t            for(i = 0; i < arr.length; i++) {\n\t                var item = arr[i];\n\n\t                switch(dimen) {\n\t                case 1: func(item, i, len, done); break;\n\t                case 2: func(item[0], item[1], i, len, done); break;\n\t                case 3: func(item[0], item[1], item[2], i, len, done); break;\n\t                default:\n\t                    item.push(i, done);\n\t                    // jshint validthis: true\n\t                    func.apply(this, item);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        var keys = lib.keys(arr);\n\t        len = keys.length;\n\t        outputArr = new Array(len);\n\n\t        if(len === 0) {\n\t            cb(null, '');\n\t        }\n\t        else {\n\t            for(i = 0; i < keys.length; i++) {\n\t                var k = keys[i];\n\t                func(k, arr[k], i, len, done);\n\t            }\n\t        }\n\t    }\n\t}\n\n\tmodule.exports = {\n\t    Frame: Frame,\n\t    makeMacro: makeMacro,\n\t    makeKeywordArgs: makeKeywordArgs,\n\t    numArgs: numArgs,\n\t    suppressValue: suppressValue,\n\t    ensureDefined: ensureDefined,\n\t    memberLookup: memberLookup,\n\t    contextOrFrameLookup: contextOrFrameLookup,\n\t    callWrap: callWrap,\n\t    handleError: handleError,\n\t    isArray: lib.isArray,\n\t    keys: lib.keys,\n\t    SafeString: SafeString,\n\t    copySafeness: copySafeness,\n\t    markSafe: markSafe,\n\t    asyncEach: asyncEach,\n\t    asyncAll: asyncAll,\n\t    inOperator: lib.inOperator\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar r = __webpack_require__(12);\n\n\tfunction normalize(value, defaultValue) {\n\t    if(value === null || value === undefined || value === false) {\n\t        return defaultValue;\n\t    }\n\t    return value;\n\t}\n\n\tvar filters = {\n\t    abs: function(n) {\n\t        return Math.abs(n);\n\t    },\n\n\t    batch: function(arr, linecount, fill_with) {\n\t        var i;\n\t        var res = [];\n\t        var tmp = [];\n\n\t        for(i = 0; i < arr.length; i++) {\n\t            if(i % linecount === 0 && tmp.length) {\n\t                res.push(tmp);\n\t                tmp = [];\n\t            }\n\n\t            tmp.push(arr[i]);\n\t        }\n\n\t        if(tmp.length) {\n\t            if(fill_with) {\n\t                for(i = tmp.length; i < linecount; i++) {\n\t                    tmp.push(fill_with);\n\t                }\n\t            }\n\n\t            res.push(tmp);\n\t        }\n\n\t        return res;\n\t    },\n\n\t    capitalize: function(str) {\n\t        str = normalize(str, '');\n\t        var ret = str.toLowerCase();\n\t        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));\n\t    },\n\n\t    center: function(str, width) {\n\t        str = normalize(str, '');\n\t        width = width || 80;\n\n\t        if(str.length >= width) {\n\t            return str;\n\t        }\n\n\t        var spaces = width - str.length;\n\t        var pre = lib.repeat(' ', spaces/2 - spaces % 2);\n\t        var post = lib.repeat(' ', spaces/2);\n\t        return r.copySafeness(str, pre + str + post);\n\t    },\n\n\t    'default': function(val, def, bool) {\n\t        if(bool) {\n\t            return val ? val : def;\n\t        }\n\t        else {\n\t            return (val !== undefined) ? val : def;\n\t        }\n\t    },\n\n\t    dictsort: function(val, case_sensitive, by) {\n\t        if (!lib.isObject(val)) {\n\t            throw new lib.TemplateError('dictsort filter: val must be an object');\n\t        }\n\n\t        var array = [];\n\t        for (var k in val) {\n\t            // deliberately include properties from the object's prototype\n\t            array.push([k,val[k]]);\n\t        }\n\n\t        var si;\n\t        if (by === undefined || by === 'key') {\n\t            si = 0;\n\t        } else if (by === 'value') {\n\t            si = 1;\n\t        } else {\n\t            throw new lib.TemplateError(\n\t                'dictsort filter: You can only sort by either key or value');\n\t        }\n\n\t        array.sort(function(t1, t2) {\n\t            var a = t1[si];\n\t            var b = t2[si];\n\n\t            if (!case_sensitive) {\n\t                if (lib.isString(a)) {\n\t                    a = a.toUpperCase();\n\t                }\n\t                if (lib.isString(b)) {\n\t                    b = b.toUpperCase();\n\t                }\n\t            }\n\n\t            return a > b ? 1 : (a === b ? 0 : -1);\n\t        });\n\n\t        return array;\n\t    },\n\n\t    dump: function(obj, spaces) {\n\t        return JSON.stringify(obj, null, spaces);\n\t    },\n\n\t    escape: function(str) {\n\t        if(str instanceof r.SafeString) {\n\t            return str;\n\t        }\n\t        str = (str === null || str === undefined) ? '' : str;\n\t        return r.markSafe(lib.escape(str.toString()));\n\t    },\n\n\t    safe: function(str) {\n\t        if (str instanceof r.SafeString) {\n\t            return str;\n\t        }\n\t        str = (str === null || str === undefined) ? '' : str;\n\t        return r.markSafe(str.toString());\n\t    },\n\n\t    first: function(arr) {\n\t        return arr[0];\n\t    },\n\n\t    groupby: function(arr, attr) {\n\t        return lib.groupBy(arr, attr);\n\t    },\n\n\t    indent: function(str, width, indentfirst) {\n\t        str = normalize(str, '');\n\n\t        if (str === '') return '';\n\n\t        width = width || 4;\n\t        var res = '';\n\t        var lines = str.split('\\n');\n\t        var sp = lib.repeat(' ', width);\n\n\t        for(var i=0; i<lines.length; i++) {\n\t            if(i === 0 && !indentfirst) {\n\t                res += lines[i] + '\\n';\n\t            }\n\t            else {\n\t                res += sp + lines[i] + '\\n';\n\t            }\n\t        }\n\n\t        return r.copySafeness(str, res);\n\t    },\n\n\t    join: function(arr, del, attr) {\n\t        del = del || '';\n\n\t        if(attr) {\n\t            arr = lib.map(arr, function(v) {\n\t                return v[attr];\n\t            });\n\t        }\n\n\t        return arr.join(del);\n\t    },\n\n\t    last: function(arr) {\n\t        return arr[arr.length-1];\n\t    },\n\n\t    length: function(val) {\n\t        var value = normalize(val, '');\n\n\t        if(value !== undefined) {\n\t            if(\n\t                (typeof Map === 'function' && value instanceof Map) ||\n\t                (typeof Set === 'function' && value instanceof Set)\n\t            ) {\n\t                // ECMAScript 2015 Maps and Sets\n\t                return value.size;\n\t            }\n\t            if(lib.isObject(value) && !(value instanceof r.SafeString)) {\n\t                // Objects (besides SafeStrings), non-primative Arrays\n\t                return Object.keys(value).length;\n\t            }\n\t            return value.length;\n\t        }\n\t        return 0;\n\t    },\n\n\t    list: function(val) {\n\t        if(lib.isString(val)) {\n\t            return val.split('');\n\t        }\n\t        else if(lib.isObject(val)) {\n\t            var keys = [];\n\n\t            if(Object.keys) {\n\t                keys = Object.keys(val);\n\t            }\n\t            else {\n\t                for(var k in val) {\n\t                    keys.push(k);\n\t                }\n\t            }\n\n\t            return lib.map(keys, function(k) {\n\t                return { key: k,\n\t                         value: val[k] };\n\t            });\n\t        }\n\t        else if(lib.isArray(val)) {\n\t          return val;\n\t        }\n\t        else {\n\t            throw new lib.TemplateError('list filter: type not iterable');\n\t        }\n\t    },\n\n\t    lower: function(str) {\n\t        str = normalize(str, '');\n\t        return str.toLowerCase();\n\t    },\n\n\t    nl2br: function(str) {\n\t        if (str === null || str === undefined) {\n\t            return '';\n\t        }\n\t        return r.copySafeness(str, str.replace(/\\r\\n|\\n/g, '<br />\\n'));\n\t    },\n\n\t    random: function(arr) {\n\t        return arr[Math.floor(Math.random() * arr.length)];\n\t    },\n\n\t    rejectattr: function(arr, attr) {\n\t      return arr.filter(function (item) {\n\t        return !item[attr];\n\t      });\n\t    },\n\n\t    selectattr: function(arr, attr) {\n\t      return arr.filter(function (item) {\n\t        return !!item[attr];\n\t      });\n\t    },\n\n\t    replace: function(str, old, new_, maxCount) {\n\t        var originalStr = str;\n\n\t        if (old instanceof RegExp) {\n\t            return str.replace(old, new_);\n\t        }\n\n\t        if(typeof maxCount === 'undefined'){\n\t            maxCount = -1;\n\t        }\n\n\t        var res = '';  // Output\n\n\t        // Cast Numbers in the search term to string\n\t        if(typeof old === 'number'){\n\t            old = old + '';\n\t        }\n\t        else if(typeof old !== 'string') {\n\t            // If it is something other than number or string,\n\t            // return the original string\n\t            return str;\n\t        }\n\n\t        // Cast numbers in the replacement to string\n\t        if(typeof str === 'number'){\n\t            str = str + '';\n\t        }\n\n\t        // If by now, we don't have a string, throw it back\n\t        if(typeof str !== 'string' && !(str instanceof r.SafeString)){\n\t            return str;\n\t        }\n\n\t        // ShortCircuits\n\t        if(old === ''){\n\t            // Mimic the python behaviour: empty string is replaced\n\t            // by replacement e.g. \"abc\"|replace(\"\", \".\") -> .a.b.c.\n\t            res = new_ + str.split('').join(new_) + new_;\n\t            return r.copySafeness(str, res);\n\t        }\n\n\t        var nextIndex = str.indexOf(old);\n\t        // if # of replacements to perform is 0, or the string to does\n\t        // not contain the old value, return the string\n\t        if(maxCount === 0 || nextIndex === -1){\n\t            return str;\n\t        }\n\n\t        var pos = 0;\n\t        var count = 0; // # of replacements made\n\n\t        while(nextIndex  > -1 && (maxCount === -1 || count < maxCount)){\n\t            // Grab the next chunk of src string and add it with the\n\t            // replacement, to the result\n\t            res += str.substring(pos, nextIndex) + new_;\n\t            // Increment our pointer in the src string\n\t            pos = nextIndex + old.length;\n\t            count++;\n\t            // See if there are any more replacements to be made\n\t            nextIndex = str.indexOf(old, pos);\n\t        }\n\n\t        // We've either reached the end, or done the max # of\n\t        // replacements, tack on any remaining string\n\t        if(pos < str.length) {\n\t            res += str.substring(pos);\n\t        }\n\n\t        return r.copySafeness(originalStr, res);\n\t    },\n\n\t    reverse: function(val) {\n\t        var arr;\n\t        if(lib.isString(val)) {\n\t            arr = filters.list(val);\n\t        }\n\t        else {\n\t            // Copy it\n\t            arr = lib.map(val, function(v) { return v; });\n\t        }\n\n\t        arr.reverse();\n\n\t        if(lib.isString(val)) {\n\t            return r.copySafeness(val, arr.join(''));\n\t        }\n\t        return arr;\n\t    },\n\n\t    round: function(val, precision, method) {\n\t        precision = precision || 0;\n\t        var factor = Math.pow(10, precision);\n\t        var rounder;\n\n\t        if(method === 'ceil') {\n\t            rounder = Math.ceil;\n\t        }\n\t        else if(method === 'floor') {\n\t            rounder = Math.floor;\n\t        }\n\t        else {\n\t            rounder = Math.round;\n\t        }\n\n\t        return rounder(val * factor) / factor;\n\t    },\n\n\t    slice: function(arr, slices, fillWith) {\n\t        var sliceLength = Math.floor(arr.length / slices);\n\t        var extra = arr.length % slices;\n\t        var offset = 0;\n\t        var res = [];\n\n\t        for(var i=0; i<slices; i++) {\n\t            var start = offset + i * sliceLength;\n\t            if(i < extra) {\n\t                offset++;\n\t            }\n\t            var end = offset + (i + 1) * sliceLength;\n\n\t            var slice = arr.slice(start, end);\n\t            if(fillWith && i >= extra) {\n\t                slice.push(fillWith);\n\t            }\n\t            res.push(slice);\n\t        }\n\n\t        return res;\n\t    },\n\n\t    sum: function(arr, attr, start) {\n\t        var sum = 0;\n\n\t        if(typeof start === 'number'){\n\t            sum += start;\n\t        }\n\n\t        if(attr) {\n\t            arr = lib.map(arr, function(v) {\n\t                return v[attr];\n\t            });\n\t        }\n\n\t        for(var i = 0; i < arr.length; i++) {\n\t            sum += arr[i];\n\t        }\n\n\t        return sum;\n\t    },\n\n\t    sort: r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function(arr, reverse, caseSens, attr) {\n\t         // Copy it\n\t        arr = lib.map(arr, function(v) { return v; });\n\n\t        arr.sort(function(a, b) {\n\t            var x, y;\n\n\t            if(attr) {\n\t                x = a[attr];\n\t                y = b[attr];\n\t            }\n\t            else {\n\t                x = a;\n\t                y = b;\n\t            }\n\n\t            if(!caseSens && lib.isString(x) && lib.isString(y)) {\n\t                x = x.toLowerCase();\n\t                y = y.toLowerCase();\n\t            }\n\n\t            if(x < y) {\n\t                return reverse ? 1 : -1;\n\t            }\n\t            else if(x > y) {\n\t                return reverse ? -1: 1;\n\t            }\n\t            else {\n\t                return 0;\n\t            }\n\t        });\n\n\t        return arr;\n\t    }),\n\n\t    string: function(obj) {\n\t        return r.copySafeness(obj, obj);\n\t    },\n\n\t    striptags: function(input, preserve_linebreaks) {\n\t        input = normalize(input, '');\n\t        preserve_linebreaks = preserve_linebreaks || false;\n\t        var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>|<!--[\\s\\S]*?-->/gi;\n\t        var trimmedInput = filters.trim(input.replace(tags, ''));\n\t        var res = '';\n\t        if (preserve_linebreaks) {\n\t            res = trimmedInput\n\t                .replace(/^ +| +$/gm, '')     // remove leading and trailing spaces\n\t                .replace(/ +/g, ' ')          // squash adjacent spaces\n\t                .replace(/(\\r\\n)/g, '\\n')     // normalize linebreaks (CRLF -> LF)\n\t                .replace(/\\n\\n\\n+/g, '\\n\\n'); // squash abnormal adjacent linebreaks\n\t        } else {\n\t            res = trimmedInput.replace(/\\s+/gi, ' ');\n\t        }\n\t        return r.copySafeness(input, res);\n\t    },\n\n\t    title: function(str) {\n\t        str = normalize(str, '');\n\t        var words = str.split(' ');\n\t        for(var i = 0; i < words.length; i++) {\n\t            words[i] = filters.capitalize(words[i]);\n\t        }\n\t        return r.copySafeness(str, words.join(' '));\n\t    },\n\n\t    trim: function(str) {\n\t        return r.copySafeness(str, str.replace(/^\\s*|\\s*$/g, ''));\n\t    },\n\n\t    truncate: function(input, length, killwords, end) {\n\t        var orig = input;\n\t        input = normalize(input, '');\n\t        length = length || 255;\n\n\t        if (input.length <= length)\n\t            return input;\n\n\t        if (killwords) {\n\t            input = input.substring(0, length);\n\t        } else {\n\t            var idx = input.lastIndexOf(' ', length);\n\t            if(idx === -1) {\n\t                idx = length;\n\t            }\n\n\t            input = input.substring(0, idx);\n\t        }\n\n\t        input += (end !== undefined && end !== null) ? end : '...';\n\t        return r.copySafeness(orig, input);\n\t    },\n\n\t    upper: function(str) {\n\t        str = normalize(str, '');\n\t        return str.toUpperCase();\n\t    },\n\n\t    urlencode: function(obj) {\n\t        var enc = encodeURIComponent;\n\t        if (lib.isString(obj)) {\n\t            return enc(obj);\n\t        } else {\n\t            var parts;\n\t            if (lib.isArray(obj)) {\n\t                parts = obj.map(function(item) {\n\t                    return enc(item[0]) + '=' + enc(item[1]);\n\t                });\n\t            } else {\n\t                parts = [];\n\t                for (var k in obj) {\n\t                    if (obj.hasOwnProperty(k)) {\n\t                        parts.push(enc(k) + '=' + enc(obj[k]));\n\t                    }\n\t                }\n\t            }\n\t            return parts.join('&');\n\t        }\n\t    },\n\n\t    urlize: function(str, length, nofollow) {\n\t        if (isNaN(length)) length = Infinity;\n\n\t        var noFollowAttr = (nofollow === true ? ' rel=\"nofollow\"' : '');\n\n\t        // For the jinja regexp, see\n\t        // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23\n\t        var puncRE = /^(?:\\(|<|&lt;)?(.*?)(?:\\.|,|\\)|\\n|&gt;)?$/;\n\t        // from http://blog.gerv.net/2011/05/html5_email_address_regexp/\n\t        var emailRE = /^[\\w.!#$%&'*+\\-\\/=?\\^`{|}~]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)+$/i;\n\t        var httpHttpsRE = /^https?:\\/\\/.*$/;\n\t        var wwwRE = /^www\\./;\n\t        var tldRE = /\\.(?:org|net|com)(?:\\:|\\/|$)/;\n\n\t        var words = str.split(/(\\s+)/).filter(function(word) {\n\t          // If the word has no length, bail. This can happen for str with\n\t          // trailing whitespace.\n\t          return word && word.length;\n\t        }).map(function(word) {\n\t          var matches = word.match(puncRE);\n\t          var possibleUrl = matches && matches[1] || word;\n\n\t          // url that starts with http or https\n\t          if (httpHttpsRE.test(possibleUrl))\n\t            return '<a href=\"' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n\t          // url that starts with www.\n\t          if (wwwRE.test(possibleUrl))\n\t            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n\t          // an email address of the form username@domain.tld\n\t          if (emailRE.test(possibleUrl))\n\t            return '<a href=\"mailto:' + possibleUrl + '\">' + possibleUrl + '</a>';\n\n\t          // url that ends in .com, .org or .net that is not an email address\n\t          if (tldRE.test(possibleUrl))\n\t            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n\t          return word;\n\n\t        });\n\n\t        return words.join('');\n\t    },\n\n\t    wordcount: function(str) {\n\t        str = normalize(str, '');\n\t        var words = (str) ? str.match(/\\w+/g) : null;\n\t        return (words) ? words.length : null;\n\t    },\n\n\t    'float': function(val, def) {\n\t        var res = parseFloat(val);\n\t        return isNaN(res) ? def : res;\n\t    },\n\n\t    'int': function(val, def) {\n\t        var res = parseInt(val, 10);\n\t        return isNaN(res) ? def : res;\n\t    }\n\t};\n\n\t// Aliases\n\tfilters.d = filters['default'];\n\tfilters.e = filters.escape;\n\n\tmodule.exports = filters;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Loader = __webpack_require__(15);\n\tvar PrecompiledLoader = __webpack_require__(16);\n\n\tvar WebLoader = Loader.extend({\n\t    init: function(baseURL, opts) {\n\t        this.baseURL = baseURL || '.';\n\t        opts = opts || {};\n\n\t        // By default, the cache is turned off because there's no way\n\t        // to \"watch\" templates over HTTP, so they are re-downloaded\n\t        // and compiled each time. (Remember, PRECOMPILE YOUR\n\t        // TEMPLATES in production!)\n\t        this.useCache = !!opts.useCache;\n\n\t        // We default `async` to false so that the simple synchronous\n\t        // API can be used when you aren't doing anything async in\n\t        // your templates (which is most of the time). This performs a\n\t        // sync ajax request, but that's ok because it should *only*\n\t        // happen in development. PRECOMPILE YOUR TEMPLATES.\n\t        this.async = !!opts.async;\n\t    },\n\n\t    resolve: function(from, to) { // jshint ignore:line\n\t        throw new Error('relative templates not support in the browser yet');\n\t    },\n\n\t    getSource: function(name, cb) {\n\t        var useCache = this.useCache;\n\t        var result;\n\t        this.fetch(this.baseURL + '/' + name, function(err, src) {\n\t            if(err) {\n\t                if(cb) {\n\t                    cb(err.content);\n\t                } else {\n\t                    if (err.status === 404) {\n\t                      result = null;\n\t                    } else {\n\t                      throw err.content;\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                result = { src: src,\n\t                           path: name,\n\t                           noCache: !useCache };\n\t                if(cb) {\n\t                    cb(null, result);\n\t                }\n\t            }\n\t        });\n\n\t        // if this WebLoader isn't running asynchronously, the\n\t        // fetch above would actually run sync and we'll have a\n\t        // result here\n\t        return result;\n\t    },\n\n\t    fetch: function(url, cb) {\n\t        // Only in the browser please\n\t        var ajax;\n\t        var loading = true;\n\n\t        if(window.XMLHttpRequest) { // Mozilla, Safari, ...\n\t            ajax = new XMLHttpRequest();\n\t        }\n\t        else if(window.ActiveXObject) { // IE 8 and older\n\t            /* global ActiveXObject */\n\t            ajax = new ActiveXObject('Microsoft.XMLHTTP');\n\t        }\n\n\t        ajax.onreadystatechange = function() {\n\t            if(ajax.readyState === 4 && loading) {\n\t                loading = false;\n\t                if(ajax.status === 0 || ajax.status === 200) {\n\t                    cb(null, ajax.responseText);\n\t                }\n\t                else {\n\t                    cb({ status: ajax.status, content: ajax.responseText });\n\t                }\n\t            }\n\t        };\n\n\t        url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' +\n\t               (new Date().getTime());\n\n\t        ajax.open('GET', url, this.async);\n\t        ajax.send();\n\t    }\n\t});\n\n\tmodule.exports = {\n\t    WebLoader: WebLoader,\n\t    PrecompiledLoader: PrecompiledLoader\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar path = __webpack_require__(3);\n\tvar Obj = __webpack_require__(6);\n\tvar lib = __webpack_require__(1);\n\n\tvar Loader = Obj.extend({\n\t    on: function(name, func) {\n\t        this.listeners = this.listeners || {};\n\t        this.listeners[name] = this.listeners[name] || [];\n\t        this.listeners[name].push(func);\n\t    },\n\n\t    emit: function(name /*, arg1, arg2, ...*/) {\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\n\t        if(this.listeners && this.listeners[name]) {\n\t            lib.each(this.listeners[name], function(listener) {\n\t                listener.apply(null, args);\n\t            });\n\t        }\n\t    },\n\n\t    resolve: function(from, to) {\n\t        return path.resolve(path.dirname(from), to);\n\t    },\n\n\t    isRelative: function(filename) {\n\t        return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);\n\t    }\n\t});\n\n\tmodule.exports = Loader;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Loader = __webpack_require__(15);\n\n\tvar PrecompiledLoader = Loader.extend({\n\t    init: function(compiledTemplates) {\n\t        this.precompiled = compiledTemplates || {};\n\t    },\n\n\t    getSource: function(name) {\n\t        if (this.precompiled[name]) {\n\t            return {\n\t                src: { type: 'code',\n\t                       obj: this.precompiled[name] },\n\t                path: name\n\t            };\n\t        }\n\t        return null;\n\t    }\n\t});\n\n\tmodule.exports = PrecompiledLoader;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tfunction cycler(items) {\n\t    var index = -1;\n\n\t    return {\n\t        current: null,\n\t        reset: function() {\n\t            index = -1;\n\t            this.current = null;\n\t        },\n\n\t        next: function() {\n\t            index++;\n\t            if(index >= items.length) {\n\t                index = 0;\n\t            }\n\n\t            this.current = items[index];\n\t            return this.current;\n\t        },\n\t    };\n\n\t}\n\n\tfunction joiner(sep) {\n\t    sep = sep || ',';\n\t    var first = true;\n\n\t    return function() {\n\t        var val = first ? '' : sep;\n\t        first = false;\n\t        return val;\n\t    };\n\t}\n\n\t// Making this a function instead so it returns a new object\n\t// each time it's called. That way, if something like an environment\n\t// uses it, they will each have their own copy.\n\tfunction globals() {\n\t    return {\n\t        range: function(start, stop, step) {\n\t            if(typeof stop === 'undefined') {\n\t                stop = start;\n\t                start = 0;\n\t                step = 1;\n\t            }\n\t            else if(!step) {\n\t                step = 1;\n\t            }\n\n\t            var arr = [];\n\t            var i;\n\t            if (step > 0) {\n\t                for (i=start; i<stop; i+=step) {\n\t                    arr.push(i);\n\t                }\n\t            } else {\n\t                for (i=start; i>stop; i+=step) {\n\t                    arr.push(i);\n\t                }\n\t            }\n\t            return arr;\n\t        },\n\n\t        // lipsum: function(n, html, min, max) {\n\t        // },\n\n\t        cycler: function() {\n\t            return cycler(Array.prototype.slice.call(arguments));\n\t        },\n\n\t        joiner: function(sep) {\n\t            return joiner(sep);\n\t        }\n\t    };\n\t}\n\n\tmodule.exports = globals;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, process) {// MIT license (by Elan Shanker).\n\t(function(globals) {\n\t  'use strict';\n\n\t  var executeSync = function(){\n\t    var args = Array.prototype.slice.call(arguments);\n\t    if (typeof args[0] === 'function'){\n\t      args[0].apply(null, args.splice(1));\n\t    }\n\t  };\n\n\t  var executeAsync = function(fn){\n\t    if (typeof setImmediate === 'function') {\n\t      setImmediate(fn);\n\t    } else if (typeof process !== 'undefined' && process.nextTick) {\n\t      process.nextTick(fn);\n\t    } else {\n\t      setTimeout(fn, 0);\n\t    }\n\t  };\n\n\t  var makeIterator = function (tasks) {\n\t    var makeCallback = function (index) {\n\t      var fn = function () {\n\t        if (tasks.length) {\n\t          tasks[index].apply(null, arguments);\n\t        }\n\t        return fn.next();\n\t      };\n\t      fn.next = function () {\n\t        return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n\t      };\n\t      return fn;\n\t    };\n\t    return makeCallback(0);\n\t  };\n\t  \n\t  var _isArray = Array.isArray || function(maybeArray){\n\t    return Object.prototype.toString.call(maybeArray) === '[object Array]';\n\t  };\n\n\t  var waterfall = function (tasks, callback, forceAsync) {\n\t    var nextTick = forceAsync ? executeAsync : executeSync;\n\t    callback = callback || function () {};\n\t    if (!_isArray(tasks)) {\n\t      var err = new Error('First argument to waterfall must be an array of functions');\n\t      return callback(err);\n\t    }\n\t    if (!tasks.length) {\n\t      return callback();\n\t    }\n\t    var wrapIterator = function (iterator) {\n\t      return function (err) {\n\t        if (err) {\n\t          callback.apply(null, arguments);\n\t          callback = function () {};\n\t        } else {\n\t          var args = Array.prototype.slice.call(arguments, 1);\n\t          var next = iterator.next();\n\t          if (next) {\n\t            args.push(wrapIterator(next));\n\t          } else {\n\t            args.push(callback);\n\t          }\n\t          nextTick(function () {\n\t            iterator.apply(null, args);\n\t          });\n\t        }\n\t      };\n\t    };\n\t    wrapIterator(makeIterator(tasks))();\n\t  };\n\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return waterfall;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS\n\t  } else if (typeof module !== 'undefined' && module.exports) {\n\t    module.exports = waterfall; // CommonJS\n\t  } else {\n\t    globals.waterfall = waterfall; // <script>\n\t  }\n\t})(this);\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19).setImmediate, __webpack_require__(3)))\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(20).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\n\t// DOM APIs, for completeness\n\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n\t  immediateIds[id] = true;\n\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\n\t  return id;\n\t};\n\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19).setImmediate, __webpack_require__(19).clearImmediate))\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\n\tfunction noop() {}\n\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tfunction installCompat() {\n\t  'use strict';\n\n\t  // This must be called like `nunjucks.installCompat` so that `this`\n\t  // references the nunjucks instance\n\t  var runtime = this.runtime; // jshint ignore:line\n\t  var lib = this.lib; // jshint ignore:line\n\n\t  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;\n\t  runtime.contextOrFrameLookup = function(context, frame, key) {\n\t    var val = orig_contextOrFrameLookup.apply(this, arguments);\n\t    if (val === undefined) {\n\t      switch (key) {\n\t      case 'True':\n\t        return true;\n\t      case 'False':\n\t        return false;\n\t      case 'None':\n\t        return null;\n\t      }\n\t    }\n\n\t    return val;\n\t  };\n\n\t  var orig_memberLookup = runtime.memberLookup;\n\t  var ARRAY_MEMBERS = {\n\t    pop: function(index) {\n\t      if (index === undefined) {\n\t        return this.pop();\n\t      }\n\t      if (index >= this.length || index < 0) {\n\t        throw new Error('KeyError');\n\t      }\n\t      return this.splice(index, 1);\n\t    },\n\t    append: function(element) {\n\t        return this.push(element);\n\t    },\n\t    remove: function(element) {\n\t      for (var i = 0; i < this.length; i++) {\n\t        if (this[i] === element) {\n\t          return this.splice(i, 1);\n\t        }\n\t      }\n\t      throw new Error('ValueError');\n\t    },\n\t    count: function(element) {\n\t      var count = 0;\n\t      for (var i = 0; i < this.length; i++) {\n\t        if (this[i] === element) {\n\t          count++;\n\t        }\n\t      }\n\t      return count;\n\t    },\n\t    index: function(element) {\n\t      var i;\n\t      if ((i = this.indexOf(element)) === -1) {\n\t        throw new Error('ValueError');\n\t      }\n\t      return i;\n\t    },\n\t    find: function(element) {\n\t      return this.indexOf(element);\n\t    },\n\t    insert: function(index, elem) {\n\t      return this.splice(index, 0, elem);\n\t    }\n\t  };\n\t  var OBJECT_MEMBERS = {\n\t    items: function() {\n\t      var ret = [];\n\t      for(var k in this) {\n\t        ret.push([k, this[k]]);\n\t      }\n\t      return ret;\n\t    },\n\t    values: function() {\n\t      var ret = [];\n\t      for(var k in this) {\n\t        ret.push(this[k]);\n\t      }\n\t      return ret;\n\t    },\n\t    keys: function() {\n\t      var ret = [];\n\t      for(var k in this) {\n\t        ret.push(k);\n\t      }\n\t      return ret;\n\t    },\n\t    get: function(key, def) {\n\t      var output = this[key];\n\t      if (output === undefined) {\n\t        output = def;\n\t      }\n\t      return output;\n\t    },\n\t    has_key: function(key) {\n\t      return this.hasOwnProperty(key);\n\t    },\n\t    pop: function(key, def) {\n\t      var output = this[key];\n\t      if (output === undefined && def !== undefined) {\n\t        output = def;\n\t      } else if (output === undefined) {\n\t        throw new Error('KeyError');\n\t      } else {\n\t        delete this[key];\n\t      }\n\t      return output;\n\t    },\n\t    popitem: function() {\n\t      for (var k in this) {\n\t        // Return the first object pair.\n\t        var val = this[k];\n\t        delete this[k];\n\t        return [k, val];\n\t      }\n\t      throw new Error('KeyError');\n\t    },\n\t    setdefault: function(key, def) {\n\t      if (key in this) {\n\t        return this[key];\n\t      }\n\t      if (def === undefined) {\n\t        def = null;\n\t      }\n\t      return this[key] = def;\n\t    },\n\t    update: function(kwargs) {\n\t      for (var k in kwargs) {\n\t        this[k] = kwargs[k];\n\t      }\n\t      return null;  // Always returns None\n\t    }\n\t  };\n\t  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;\n\t  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;\n\t  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;\n\t  runtime.memberLookup = function(obj, val, autoescape) { // jshint ignore:line\n\t    obj = obj || {};\n\n\t    // If the object is an object, return any of the methods that Python would\n\t    // otherwise provide.\n\t    if (lib.isArray(obj) && ARRAY_MEMBERS.hasOwnProperty(val)) {\n\t      return function() {return ARRAY_MEMBERS[val].apply(obj, arguments);};\n\t    }\n\n\t    if (lib.isObject(obj) && OBJECT_MEMBERS.hasOwnProperty(val)) {\n\t      return function() {return OBJECT_MEMBERS[val].apply(obj, arguments);};\n\t    }\n\n\t    return orig_memberLookup.apply(this, arguments);\n\t  };\n\t}\n\n\tmodule.exports = installCompat;\n\n\n/***/ }\n/******/ ])\n});\n;","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/browser/nunjucks-slim.js":"/*! Browser bundle of nunjucks 3.0.0 (slim, only works with precompiled templates) */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nunjucks\"] = factory();\n\telse\n\t\troot[\"nunjucks\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar env = __webpack_require__(2);\n\tvar Loader = __webpack_require__(14);\n\tvar loaders = __webpack_require__(3);\n\tvar precompile = __webpack_require__(3);\n\n\tmodule.exports = {};\n\tmodule.exports.Environment = env.Environment;\n\tmodule.exports.Template = env.Template;\n\n\tmodule.exports.Loader = Loader;\n\tmodule.exports.FileSystemLoader = loaders.FileSystemLoader;\n\tmodule.exports.PrecompiledLoader = loaders.PrecompiledLoader;\n\tmodule.exports.WebLoader = loaders.WebLoader;\n\n\tmodule.exports.compiler = __webpack_require__(3);\n\tmodule.exports.parser = __webpack_require__(3);\n\tmodule.exports.lexer = __webpack_require__(3);\n\tmodule.exports.runtime = __webpack_require__(8);\n\tmodule.exports.lib = lib;\n\tmodule.exports.nodes = __webpack_require__(3);\n\n\tmodule.exports.installJinjaCompat = __webpack_require__(15);\n\n\t// A single instance of an environment, since this is so commonly used\n\n\tvar e;\n\tmodule.exports.configure = function(templatesPath, opts) {\n\t    opts = opts || {};\n\t    if(lib.isObject(templatesPath)) {\n\t        opts = templatesPath;\n\t        templatesPath = null;\n\t    }\n\n\t    var TemplateLoader;\n\t    if(loaders.FileSystemLoader) {\n\t        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {\n\t            watch: opts.watch,\n\t            noCache: opts.noCache\n\t        });\n\t    }\n\t    else if(loaders.WebLoader) {\n\t        TemplateLoader = new loaders.WebLoader(templatesPath, {\n\t            useCache: opts.web && opts.web.useCache,\n\t            async: opts.web && opts.web.async\n\t        });\n\t    }\n\n\t    e = new env.Environment(TemplateLoader, opts);\n\n\t    if(opts && opts.express) {\n\t        e.express(opts.express);\n\t    }\n\n\t    return e;\n\t};\n\n\tmodule.exports.compile = function(src, env, path, eagerCompile) {\n\t    if(!e) {\n\t        module.exports.configure();\n\t    }\n\t    return new module.exports.Template(src, env, path, eagerCompile);\n\t};\n\n\tmodule.exports.render = function(name, ctx, cb) {\n\t    if(!e) {\n\t        module.exports.configure();\n\t    }\n\n\t    return e.render(name, ctx, cb);\n\t};\n\n\tmodule.exports.renderString = function(src, ctx, cb) {\n\t    if(!e) {\n\t        module.exports.configure();\n\t    }\n\n\t    return e.renderString(src, ctx, cb);\n\t};\n\n\tif(precompile) {\n\t    module.exports.precompile = precompile.precompile;\n\t    module.exports.precompileString = precompile.precompileString;\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tvar ArrayProto = Array.prototype;\n\tvar ObjProto = Object.prototype;\n\n\tvar escapeMap = {\n\t    '&': '&amp;',\n\t    '\"': '&quot;',\n\t    '\\'': '&#39;',\n\t    '<': '&lt;',\n\t    '>': '&gt;'\n\t};\n\n\tvar escapeRegex = /[&\"'<>]/g;\n\n\tvar lookupEscape = function(ch) {\n\t    return escapeMap[ch];\n\t};\n\n\tvar exports = module.exports = {};\n\n\texports.prettifyError = function(path, withInternals, err) {\n\t    // jshint -W022\n\t    // http://jslinterrors.com/do-not-assign-to-the-exception-parameter\n\t    if (!err.Update) {\n\t        // not one of ours, cast it\n\t        err = new exports.TemplateError(err);\n\t    }\n\t    err.Update(path);\n\n\t    // Unless they marked the dev flag, show them a trace from here\n\t    if (!withInternals) {\n\t        var old = err;\n\t        err = new Error(old.message);\n\t        err.name = old.name;\n\t    }\n\n\t    return err;\n\t};\n\n\texports.TemplateError = function(message, lineno, colno) {\n\t    var err = this;\n\n\t    if (message instanceof Error) { // for casting regular js errors\n\t        err = message;\n\t        message = message.name + ': ' + message.message;\n\n\t        try {\n\t            if(err.name = '') {}\n\t        }\n\t        catch(e) {\n\t            // If we can't set the name of the error object in this\n\t            // environment, don't use it\n\t            err = this;\n\t        }\n\t    } else {\n\t        if(Error.captureStackTrace) {\n\t            Error.captureStackTrace(err);\n\t        }\n\t    }\n\n\t    err.name = 'Template render error';\n\t    err.message = message;\n\t    err.lineno = lineno;\n\t    err.colno = colno;\n\t    err.firstUpdate = true;\n\n\t    err.Update = function(path) {\n\t        var message = '(' + (path || 'unknown path') + ')';\n\n\t        // only show lineno + colno next to path of template\n\t        // where error occurred\n\t        if (this.firstUpdate) {\n\t            if(this.lineno && this.colno) {\n\t                message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';\n\t            }\n\t            else if(this.lineno) {\n\t                message += ' [Line ' + this.lineno + ']';\n\t            }\n\t        }\n\n\t        message += '\\n ';\n\t        if (this.firstUpdate) {\n\t            message += ' ';\n\t        }\n\n\t        this.message = message + (this.message || '');\n\t        this.firstUpdate = false;\n\t        return this;\n\t    };\n\n\t    return err;\n\t};\n\n\texports.TemplateError.prototype = Error.prototype;\n\n\texports.escape = function(val) {\n\t  return val.replace(escapeRegex, lookupEscape);\n\t};\n\n\texports.isFunction = function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object Function]';\n\t};\n\n\texports.isArray = Array.isArray || function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object Array]';\n\t};\n\n\texports.isString = function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object String]';\n\t};\n\n\texports.isObject = function(obj) {\n\t    return ObjProto.toString.call(obj) === '[object Object]';\n\t};\n\n\texports.groupBy = function(obj, val) {\n\t    var result = {};\n\t    var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };\n\t    for(var i=0; i<obj.length; i++) {\n\t        var value = obj[i];\n\t        var key = iterator(value, i);\n\t        (result[key] || (result[key] = [])).push(value);\n\t    }\n\t    return result;\n\t};\n\n\texports.toArray = function(obj) {\n\t    return Array.prototype.slice.call(obj);\n\t};\n\n\texports.without = function(array) {\n\t    var result = [];\n\t    if (!array) {\n\t        return result;\n\t    }\n\t    var index = -1,\n\t    length = array.length,\n\t    contains = exports.toArray(arguments).slice(1);\n\n\t    while(++index < length) {\n\t        if(exports.indexOf(contains, array[index]) === -1) {\n\t            result.push(array[index]);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\texports.extend = function(obj, obj2) {\n\t    for(var k in obj2) {\n\t        obj[k] = obj2[k];\n\t    }\n\t    return obj;\n\t};\n\n\texports.repeat = function(char_, n) {\n\t    var str = '';\n\t    for(var i=0; i<n; i++) {\n\t        str += char_;\n\t    }\n\t    return str;\n\t};\n\n\texports.each = function(obj, func, context) {\n\t    if(obj == null) {\n\t        return;\n\t    }\n\n\t    if(ArrayProto.each && obj.each === ArrayProto.each) {\n\t        obj.forEach(func, context);\n\t    }\n\t    else if(obj.length === +obj.length) {\n\t        for(var i=0, l=obj.length; i<l; i++) {\n\t            func.call(context, obj[i], i, obj);\n\t        }\n\t    }\n\t};\n\n\texports.map = function(obj, func) {\n\t    var results = [];\n\t    if(obj == null) {\n\t        return results;\n\t    }\n\n\t    if(ArrayProto.map && obj.map === ArrayProto.map) {\n\t        return obj.map(func);\n\t    }\n\n\t    for(var i=0; i<obj.length; i++) {\n\t        results[results.length] = func(obj[i], i);\n\t    }\n\n\t    if(obj.length === +obj.length) {\n\t        results.length = obj.length;\n\t    }\n\n\t    return results;\n\t};\n\n\texports.asyncIter = function(arr, iter, cb) {\n\t    var i = -1;\n\n\t    function next() {\n\t        i++;\n\n\t        if(i < arr.length) {\n\t            iter(arr[i], i, next, cb);\n\t        }\n\t        else {\n\t            cb();\n\t        }\n\t    }\n\n\t    next();\n\t};\n\n\texports.asyncFor = function(obj, iter, cb) {\n\t    var keys = exports.keys(obj);\n\t    var len = keys.length;\n\t    var i = -1;\n\n\t    function next() {\n\t        i++;\n\t        var k = keys[i];\n\n\t        if(i < len) {\n\t            iter(k, obj[k], i, len, next);\n\t        }\n\t        else {\n\t            cb();\n\t        }\n\t    }\n\n\t    next();\n\t};\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill\n\texports.indexOf = Array.prototype.indexOf ?\n\t    function (arr, searchElement, fromIndex) {\n\t        return Array.prototype.indexOf.call(arr, searchElement, fromIndex);\n\t    } :\n\t    function (arr, searchElement, fromIndex) {\n\t        var length = this.length >>> 0; // Hack to convert object.length to a UInt32\n\n\t        fromIndex = +fromIndex || 0;\n\n\t        if(Math.abs(fromIndex) === Infinity) {\n\t            fromIndex = 0;\n\t        }\n\n\t        if(fromIndex < 0) {\n\t            fromIndex += length;\n\t            if (fromIndex < 0) {\n\t                fromIndex = 0;\n\t            }\n\t        }\n\n\t        for(;fromIndex < length; fromIndex++) {\n\t            if (arr[fromIndex] === searchElement) {\n\t                return fromIndex;\n\t            }\n\t        }\n\n\t        return -1;\n\t    };\n\n\tif(!Array.prototype.map) {\n\t    Array.prototype.map = function() {\n\t        throw new Error('map is unimplemented for this js engine');\n\t    };\n\t}\n\n\texports.keys = function(obj) {\n\t    if(Object.prototype.keys) {\n\t        return obj.keys();\n\t    }\n\t    else {\n\t        var keys = [];\n\t        for(var k in obj) {\n\t            if(obj.hasOwnProperty(k)) {\n\t                keys.push(k);\n\t            }\n\t        }\n\t        return keys;\n\t    }\n\t};\n\n\texports.inOperator = function (key, val) {\n\t    if (exports.isArray(val)) {\n\t        return exports.indexOf(val, key) !== -1;\n\t    } else if (exports.isObject(val)) {\n\t        return key in val;\n\t    } else if (exports.isString(val)) {\n\t        return val.indexOf(key) !== -1;\n\t    } else {\n\t        throw new Error('Cannot use \"in\" operator to search for \"'\n\t            + key + '\" in unexpected types.');\n\t    }\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar path = __webpack_require__(3);\n\tvar asap = __webpack_require__(4);\n\tvar lib = __webpack_require__(1);\n\tvar Obj = __webpack_require__(6);\n\tvar compiler = __webpack_require__(3);\n\tvar builtin_filters = __webpack_require__(7);\n\tvar builtin_loaders = __webpack_require__(3);\n\tvar runtime = __webpack_require__(8);\n\tvar globals = __webpack_require__(9);\n\tvar waterfall = __webpack_require__(10);\n\tvar Frame = runtime.Frame;\n\tvar Template;\n\n\t// Unconditionally load in this loader, even if no other ones are\n\t// included (possible in the slim browser build)\n\tbuiltin_loaders.PrecompiledLoader = __webpack_require__(13);\n\n\t// If the user is using the async API, *always* call it\n\t// asynchronously even if the template was synchronous.\n\tfunction callbackAsap(cb, err, res) {\n\t    asap(function() { cb(err, res); });\n\t}\n\n\tvar Environment = Obj.extend({\n\t    init: function(loaders, opts) {\n\t        // The dev flag determines the trace that'll be shown on errors.\n\t        // If set to true, returns the full trace from the error point,\n\t        // otherwise will return trace starting from Template.render\n\t        // (the full trace from within nunjucks may confuse developers using\n\t        //  the library)\n\t        // defaults to false\n\t        opts = this.opts = opts || {};\n\t        this.opts.dev = !!opts.dev;\n\n\t        // The autoescape flag sets global autoescaping. If true,\n\t        // every string variable will be escaped by default.\n\t        // If false, strings can be manually escaped using the `escape` filter.\n\t        // defaults to true\n\t        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;\n\n\t        // If true, this will make the system throw errors if trying\n\t        // to output a null or undefined value\n\t        this.opts.throwOnUndefined = !!opts.throwOnUndefined;\n\t        this.opts.trimBlocks = !!opts.trimBlocks;\n\t        this.opts.lstripBlocks = !!opts.lstripBlocks;\n\n\t        this.loaders = [];\n\n\t        if(!loaders) {\n\t            // The filesystem loader is only available server-side\n\t            if(builtin_loaders.FileSystemLoader) {\n\t                this.loaders = [new builtin_loaders.FileSystemLoader('views')];\n\t            }\n\t            else if(builtin_loaders.WebLoader) {\n\t                this.loaders = [new builtin_loaders.WebLoader('/views')];\n\t            }\n\t        }\n\t        else {\n\t            this.loaders = lib.isArray(loaders) ? loaders : [loaders];\n\t        }\n\n\t        // It's easy to use precompiled templates: just include them\n\t        // before you configure nunjucks and this will automatically\n\t        // pick it up and use it\n\t        if((true) && window.nunjucksPrecompiled) {\n\t            this.loaders.unshift(\n\t                new builtin_loaders.PrecompiledLoader(window.nunjucksPrecompiled)\n\t            );\n\t        }\n\n\t        this.initCache();\n\n\t        this.globals = globals();\n\t        this.filters = {};\n\t        this.asyncFilters = [];\n\t        this.extensions = {};\n\t        this.extensionsList = [];\n\n\t        for(var name in builtin_filters) {\n\t            this.addFilter(name, builtin_filters[name]);\n\t        }\n\t    },\n\n\t    initCache: function() {\n\t        // Caching and cache busting\n\t        lib.each(this.loaders, function(loader) {\n\t            loader.cache = {};\n\n\t            if(typeof loader.on === 'function') {\n\t                loader.on('update', function(template) {\n\t                    loader.cache[template] = null;\n\t                });\n\t            }\n\t        });\n\t    },\n\n\t    addExtension: function(name, extension) {\n\t        extension._name = name;\n\t        this.extensions[name] = extension;\n\t        this.extensionsList.push(extension);\n\t        return this;\n\t    },\n\n\t    removeExtension: function(name) {\n\t        var extension = this.getExtension(name);\n\t        if (!extension) return;\n\n\t        this.extensionsList = lib.without(this.extensionsList, extension);\n\t        delete this.extensions[name];\n\t    },\n\n\t    getExtension: function(name) {\n\t        return this.extensions[name];\n\t    },\n\n\t    hasExtension: function(name) {\n\t        return !!this.extensions[name];\n\t    },\n\n\t    addGlobal: function(name, value) {\n\t        this.globals[name] = value;\n\t        return this;\n\t    },\n\n\t    getGlobal: function(name) {\n\t        if(typeof this.globals[name] === 'undefined') {\n\t            throw new Error('global not found: ' + name);\n\t        }\n\t        return this.globals[name];\n\t    },\n\n\t    addFilter: function(name, func, async) {\n\t        var wrapped = func;\n\n\t        if(async) {\n\t            this.asyncFilters.push(name);\n\t        }\n\t        this.filters[name] = wrapped;\n\t        return this;\n\t    },\n\n\t    getFilter: function(name) {\n\t        if(!this.filters[name]) {\n\t            throw new Error('filter not found: ' + name);\n\t        }\n\t        return this.filters[name];\n\t    },\n\n\t    resolveTemplate: function(loader, parentName, filename) {\n\t        var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;\n\t        return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;\n\t    },\n\n\t    getTemplate: function(name, eagerCompile, parentName, ignoreMissing, cb) {\n\t        var that = this;\n\t        var tmpl = null;\n\t        if(name && name.raw) {\n\t            // this fixes autoescape for templates referenced in symbols\n\t            name = name.raw;\n\t        }\n\n\t        if(lib.isFunction(parentName)) {\n\t            cb = parentName;\n\t            parentName = null;\n\t            eagerCompile = eagerCompile || false;\n\t        }\n\n\t        if(lib.isFunction(eagerCompile)) {\n\t            cb = eagerCompile;\n\t            eagerCompile = false;\n\t        }\n\n\t        if (name instanceof Template) {\n\t             tmpl = name;\n\t        }\n\t        else if(typeof name !== 'string') {\n\t            throw new Error('template names must be a string: ' + name);\n\t        }\n\t        else {\n\t            for (var i = 0; i < this.loaders.length; i++) {\n\t                var _name = this.resolveTemplate(this.loaders[i], parentName, name);\n\t                tmpl = this.loaders[i].cache[_name];\n\t                if (tmpl) break;\n\t            }\n\t        }\n\n\t        if(tmpl) {\n\t            if(eagerCompile) {\n\t                tmpl.compile();\n\t            }\n\n\t            if(cb) {\n\t                cb(null, tmpl);\n\t            }\n\t            else {\n\t                return tmpl;\n\t            }\n\t        } else {\n\t            var syncResult;\n\t            var _this = this;\n\n\t            var createTemplate = function(err, info) {\n\t                if(!info && !err) {\n\t                    if(!ignoreMissing) {\n\t                        err = new Error('template not found: ' + name);\n\t                    }\n\t                }\n\n\t                if (err) {\n\t                    if(cb) {\n\t                        cb(err);\n\t                    }\n\t                    else {\n\t                        throw err;\n\t                    }\n\t                }\n\t                else {\n\t                    var tmpl;\n\t                    if(info) {\n\t                        tmpl = new Template(info.src, _this,\n\t                                            info.path, eagerCompile);\n\n\t                        if(!info.noCache) {\n\t                            info.loader.cache[name] = tmpl;\n\t                        }\n\t                    }\n\t                    else {\n\t                        tmpl = new Template('', _this,\n\t                                            '', eagerCompile);\n\t                    }\n\n\t                    if(cb) {\n\t                        cb(null, tmpl);\n\t                    }\n\t                    else {\n\t                        syncResult = tmpl;\n\t                    }\n\t                }\n\t            };\n\n\t            lib.asyncIter(this.loaders, function(loader, i, next, done) {\n\t                function handle(err, src) {\n\t                    if(err) {\n\t                        done(err);\n\t                    }\n\t                    else if(src) {\n\t                        src.loader = loader;\n\t                        done(null, src);\n\t                    }\n\t                    else {\n\t                        next();\n\t                    }\n\t                }\n\n\t                // Resolve name relative to parentName\n\t                name = that.resolveTemplate(loader, parentName, name);\n\n\t                if(loader.async) {\n\t                    loader.getSource(name, handle);\n\t                }\n\t                else {\n\t                    handle(null, loader.getSource(name));\n\t                }\n\t            }, createTemplate);\n\n\t            return syncResult;\n\t        }\n\t    },\n\n\t    express: function(app) {\n\t        var env = this;\n\n\t        function NunjucksView(name, opts) {\n\t            this.name          = name;\n\t            this.path          = name;\n\t            this.defaultEngine = opts.defaultEngine;\n\t            this.ext           = path.extname(name);\n\t            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');\n\t            if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);\n\t        }\n\n\t        NunjucksView.prototype.render = function(opts, cb) {\n\t          env.render(this.name, opts, cb);\n\t        };\n\n\t        app.set('view', NunjucksView);\n\t        app.set('nunjucksEnv', this);\n\t        return this;\n\t    },\n\n\t    render: function(name, ctx, cb) {\n\t        if(lib.isFunction(ctx)) {\n\t            cb = ctx;\n\t            ctx = null;\n\t        }\n\n\t        // We support a synchronous API to make it easier to migrate\n\t        // existing code to async. This works because if you don't do\n\t        // anything async work, the whole thing is actually run\n\t        // synchronously.\n\t        var syncResult = null;\n\n\t        this.getTemplate(name, function(err, tmpl) {\n\t            if(err && cb) {\n\t                callbackAsap(cb, err);\n\t            }\n\t            else if(err) {\n\t                throw err;\n\t            }\n\t            else {\n\t                syncResult = tmpl.render(ctx, cb);\n\t            }\n\t        });\n\n\t        return syncResult;\n\t    },\n\n\t    renderString: function(src, ctx, opts, cb) {\n\t        if(lib.isFunction(opts)) {\n\t            cb = opts;\n\t            opts = {};\n\t        }\n\t        opts = opts || {};\n\n\t        var tmpl = new Template(src, this, opts.path);\n\t        return tmpl.render(ctx, cb);\n\t    },\n\n\t    waterfall: waterfall\n\t});\n\n\tvar Context = Obj.extend({\n\t    init: function(ctx, blocks, env) {\n\t        // Has to be tied to an environment so we can tap into its globals.\n\t        this.env = env || new Environment();\n\n\t        // Make a duplicate of ctx\n\t        this.ctx = {};\n\t        for(var k in ctx) {\n\t            if(ctx.hasOwnProperty(k)) {\n\t                this.ctx[k] = ctx[k];\n\t            }\n\t        }\n\n\t        this.blocks = {};\n\t        this.exported = [];\n\n\t        for(var name in blocks) {\n\t            this.addBlock(name, blocks[name]);\n\t        }\n\t    },\n\n\t    lookup: function(name) {\n\t        // This is one of the most called functions, so optimize for\n\t        // the typical case where the name isn't in the globals\n\t        if(name in this.env.globals && !(name in this.ctx)) {\n\t            return this.env.globals[name];\n\t        }\n\t        else {\n\t            return this.ctx[name];\n\t        }\n\t    },\n\n\t    setVariable: function(name, val) {\n\t        this.ctx[name] = val;\n\t    },\n\n\t    getVariables: function() {\n\t        return this.ctx;\n\t    },\n\n\t    addBlock: function(name, block) {\n\t        this.blocks[name] = this.blocks[name] || [];\n\t        this.blocks[name].push(block);\n\t        return this;\n\t    },\n\n\t    getBlock: function(name) {\n\t        if(!this.blocks[name]) {\n\t            throw new Error('unknown block \"' + name + '\"');\n\t        }\n\n\t        return this.blocks[name][0];\n\t    },\n\n\t    getSuper: function(env, name, block, frame, runtime, cb) {\n\t        var idx = lib.indexOf(this.blocks[name] || [], block);\n\t        var blk = this.blocks[name][idx + 1];\n\t        var context = this;\n\n\t        if(idx === -1 || !blk) {\n\t            throw new Error('no super block available for \"' + name + '\"');\n\t        }\n\n\t        blk(env, context, frame, runtime, cb);\n\t    },\n\n\t    addExport: function(name) {\n\t        this.exported.push(name);\n\t    },\n\n\t    getExported: function() {\n\t        var exported = {};\n\t        for(var i=0; i<this.exported.length; i++) {\n\t            var name = this.exported[i];\n\t            exported[name] = this.ctx[name];\n\t        }\n\t        return exported;\n\t    }\n\t});\n\n\tTemplate = Obj.extend({\n\t    init: function (src, env, path, eagerCompile) {\n\t        this.env = env || new Environment();\n\n\t        if(lib.isObject(src)) {\n\t            switch(src.type) {\n\t            case 'code': this.tmplProps = src.obj; break;\n\t            case 'string': this.tmplStr = src.obj; break;\n\t            }\n\t        }\n\t        else if(lib.isString(src)) {\n\t            this.tmplStr = src;\n\t        }\n\t        else {\n\t            throw new Error('src must be a string or an object describing ' +\n\t                            'the source');\n\t        }\n\n\t        this.path = path;\n\n\t        if(eagerCompile) {\n\t            var _this = this;\n\t            try {\n\t                _this._compile();\n\t            }\n\t            catch(err) {\n\t                throw lib.prettifyError(this.path, this.env.opts.dev, err);\n\t            }\n\t        }\n\t        else {\n\t            this.compiled = false;\n\t        }\n\t    },\n\n\t    render: function(ctx, parentFrame, cb) {\n\t        if (typeof ctx === 'function') {\n\t            cb = ctx;\n\t            ctx = {};\n\t        }\n\t        else if (typeof parentFrame === 'function') {\n\t            cb = parentFrame;\n\t            parentFrame = null;\n\t        }\n\n\t        var forceAsync = true;\n\t        if(parentFrame) {\n\t            // If there is a frame, we are being called from internal\n\t            // code of another template, and the internal system\n\t            // depends on the sync/async nature of the parent template\n\t            // to be inherited, so force an async callback\n\t            forceAsync = false;\n\t        }\n\n\t        var _this = this;\n\t        // Catch compile errors for async rendering\n\t        try {\n\t            _this.compile();\n\t        } catch (_err) {\n\t            var err = lib.prettifyError(this.path, this.env.opts.dev, _err);\n\t            if (cb) return callbackAsap(cb, err);\n\t            else throw err;\n\t        }\n\n\t        var context = new Context(ctx || {}, _this.blocks, _this.env);\n\t        var frame = parentFrame ? parentFrame.push(true) : new Frame();\n\t        frame.topLevel = true;\n\t        var syncResult = null;\n\n\t        _this.rootRenderFunc(\n\t            _this.env,\n\t            context,\n\t            frame || new Frame(),\n\t            runtime,\n\t            function(err, res) {\n\t                if(err) {\n\t                    err = lib.prettifyError(_this.path, _this.env.opts.dev, err);\n\t                }\n\n\t                if(cb) {\n\t                    if(forceAsync) {\n\t                        callbackAsap(cb, err, res);\n\t                    }\n\t                    else {\n\t                        cb(err, res);\n\t                    }\n\t                }\n\t                else {\n\t                    if(err) { throw err; }\n\t                    syncResult = res;\n\t                }\n\t            }\n\t        );\n\n\t        return syncResult;\n\t    },\n\n\n\t    getExported: function(ctx, parentFrame, cb) {\n\t        if (typeof ctx === 'function') {\n\t            cb = ctx;\n\t            ctx = {};\n\t        }\n\n\t        if (typeof parentFrame === 'function') {\n\t            cb = parentFrame;\n\t            parentFrame = null;\n\t        }\n\n\t        // Catch compile errors for async rendering\n\t        try {\n\t            this.compile();\n\t        } catch (e) {\n\t            if (cb) return cb(e);\n\t            else throw e;\n\t        }\n\n\t        var frame = parentFrame ? parentFrame.push() : new Frame();\n\t        frame.topLevel = true;\n\n\t        // Run the rootRenderFunc to populate the context with exported vars\n\t        var context = new Context(ctx || {}, this.blocks, this.env);\n\t        this.rootRenderFunc(this.env,\n\t                            context,\n\t                            frame,\n\t                            runtime,\n\t                            function(err) {\n\t        \t\t        if ( err ) {\n\t        \t\t\t    cb(err, null);\n\t        \t\t        } else {\n\t        \t\t\t    cb(null, context.getExported());\n\t        \t\t        }\n\t                            });\n\t    },\n\n\t    compile: function() {\n\t        if(!this.compiled) {\n\t            this._compile();\n\t        }\n\t    },\n\n\t    _compile: function() {\n\t        var props;\n\n\t        if(this.tmplProps) {\n\t            props = this.tmplProps;\n\t        }\n\t        else {\n\t            var source = compiler.compile(this.tmplStr,\n\t                                          this.env.asyncFilters,\n\t                                          this.env.extensionsList,\n\t                                          this.path,\n\t                                          this.env.opts);\n\n\t            /* jslint evil: true */\n\t            var func = new Function(source);\n\t            props = func();\n\t        }\n\n\t        this.blocks = this._getBlocks(props);\n\t        this.rootRenderFunc = props.root;\n\t        this.compiled = true;\n\t    },\n\n\t    _getBlocks: function(props) {\n\t        var blocks = {};\n\n\t        for(var k in props) {\n\t            if(k.slice(0, 2) === 'b_') {\n\t                blocks[k.slice(2)] = props[k];\n\t            }\n\t        }\n\n\t        return blocks;\n\t    }\n\t});\n\n\tmodule.exports = {\n\t    Environment: Environment,\n\t    Template: Template\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\t// rawAsap provides everything we need except exception management.\n\tvar rawAsap = __webpack_require__(5);\n\t// RawTasks are recycled to reduce GC churn.\n\tvar freeTasks = [];\n\t// We queue errors to ensure they are thrown in right order (FIFO).\n\t// Array-as-queue is good enough here, since we are just dealing with exceptions.\n\tvar pendingErrors = [];\n\tvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\n\tfunction throwFirstError() {\n\t    if (pendingErrors.length) {\n\t        throw pendingErrors.shift();\n\t    }\n\t}\n\n\t/**\n\t * Calls a task as soon as possible after returning, in its own event, with priority\n\t * over other events like animation, reflow, and repaint. An error thrown from an\n\t * event will not interrupt, nor even substantially slow down the processing of\n\t * other events, but will be rather postponed to a lower priority event.\n\t * @param {{call}} task A callable object, typically a function that takes no\n\t * arguments.\n\t */\n\tmodule.exports = asap;\n\tfunction asap(task) {\n\t    var rawTask;\n\t    if (freeTasks.length) {\n\t        rawTask = freeTasks.pop();\n\t    } else {\n\t        rawTask = new RawTask();\n\t    }\n\t    rawTask.task = task;\n\t    rawAsap(rawTask);\n\t}\n\n\t// We wrap tasks with recyclable task objects.  A task object implements\n\t// `call`, just like a function.\n\tfunction RawTask() {\n\t    this.task = null;\n\t}\n\n\t// The sole purpose of wrapping the task is to catch the exception and recycle\n\t// the task object after its single use.\n\tRawTask.prototype.call = function () {\n\t    try {\n\t        this.task.call();\n\t    } catch (error) {\n\t        if (asap.onerror) {\n\t            // This hook exists purely for testing purposes.\n\t            // Its name will be periodically randomized to break any code that\n\t            // depends on its existence.\n\t            asap.onerror(error);\n\t        } else {\n\t            // In a web browser, exceptions are not fatal. However, to avoid\n\t            // slowing down the queue of pending tasks, we rethrow the error in a\n\t            // lower priority turn.\n\t            pendingErrors.push(error);\n\t            requestErrorThrow();\n\t        }\n\t    } finally {\n\t        this.task = null;\n\t        freeTasks[freeTasks.length] = this;\n\t    }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\n\t// Use the fastest means possible to execute a task in its own turn, with\n\t// priority over other events including IO, animation, reflow, and redraw\n\t// events in browsers.\n\t//\n\t// An exception thrown by a task will permanently interrupt the processing of\n\t// subsequent tasks. The higher level `asap` function ensures that if an\n\t// exception is thrown by a task, that the task queue will continue flushing as\n\t// soon as possible, but if you use `rawAsap` directly, you are responsible to\n\t// either ensure that no exceptions are thrown from your task, or to manually\n\t// call `rawAsap.requestFlush` if an exception is thrown.\n\tmodule.exports = rawAsap;\n\tfunction rawAsap(task) {\n\t    if (!queue.length) {\n\t        requestFlush();\n\t        flushing = true;\n\t    }\n\t    // Equivalent to push, but avoids a function call.\n\t    queue[queue.length] = task;\n\t}\n\n\tvar queue = [];\n\t// Once a flush has been requested, no further calls to `requestFlush` are\n\t// necessary until the next `flush` completes.\n\tvar flushing = false;\n\t// `requestFlush` is an implementation-specific method that attempts to kick\n\t// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n\t// the event queue before yielding to the browser's own event loop.\n\tvar requestFlush;\n\t// The position of the next task to execute in the task queue. This is\n\t// preserved between calls to `flush` so that it can be resumed if\n\t// a task throws an exception.\n\tvar index = 0;\n\t// If a task schedules additional tasks recursively, the task queue can grow\n\t// unbounded. To prevent memory exhaustion, the task queue will periodically\n\t// truncate already-completed tasks.\n\tvar capacity = 1024;\n\n\t// The flush function processes all tasks that have been scheduled with\n\t// `rawAsap` unless and until one of those tasks throws an exception.\n\t// If a task throws an exception, `flush` ensures that its state will remain\n\t// consistent and will resume where it left off when called again.\n\t// However, `flush` does not make any arrangements to be called again if an\n\t// exception is thrown.\n\tfunction flush() {\n\t    while (index < queue.length) {\n\t        var currentIndex = index;\n\t        // Advance the index before calling the task. This ensures that we will\n\t        // begin flushing on the next task the task throws an error.\n\t        index = index + 1;\n\t        queue[currentIndex].call();\n\t        // Prevent leaking memory for long chains of recursive calls to `asap`.\n\t        // If we call `asap` within tasks scheduled by `asap`, the queue will\n\t        // grow, but to avoid an O(n) walk for every task we execute, we don't\n\t        // shift tasks off the queue after they have been executed.\n\t        // Instead, we periodically shift 1024 tasks off the queue.\n\t        if (index > capacity) {\n\t            // Manually shift all values starting at the index back to the\n\t            // beginning of the queue.\n\t            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n\t                queue[scan] = queue[scan + index];\n\t            }\n\t            queue.length -= index;\n\t            index = 0;\n\t        }\n\t    }\n\t    queue.length = 0;\n\t    index = 0;\n\t    flushing = false;\n\t}\n\n\t// `requestFlush` is implemented using a strategy based on data collected from\n\t// every available SauceLabs Selenium web driver worker at time of writing.\n\t// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n\t// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n\t// have WebKitMutationObserver but not un-prefixed MutationObserver.\n\t// Must use `global` instead of `window` to work in both frames and web\n\t// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\tvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n\t// MutationObservers are desirable because they have high priority and work\n\t// reliably everywhere they are implemented.\n\t// They are implemented in all modern browsers.\n\t//\n\t// - Android 4-4.3\n\t// - Chrome 26-34\n\t// - Firefox 14-29\n\t// - Internet Explorer 11\n\t// - iPad Safari 6-7.1\n\t// - iPhone Safari 7-7.1\n\t// - Safari 6-7\n\tif (typeof BrowserMutationObserver === \"function\") {\n\t    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n\t// MessageChannels are desirable because they give direct access to the HTML\n\t// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n\t// 11-12, and in web workers in many engines.\n\t// Although message channels yield to any queued rendering and IO tasks, they\n\t// would be better than imposing the 4ms delay of timers.\n\t// However, they do not work reliably in Internet Explorer or Safari.\n\n\t// Internet Explorer 10 is the only browser that has setImmediate but does\n\t// not have MutationObservers.\n\t// Although setImmediate yields to the browser's renderer, it would be\n\t// preferrable to falling back to setTimeout since it does not have\n\t// the minimum 4ms penalty.\n\t// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n\t// Desktop to a lesser extent) that renders both setImmediate and\n\t// MessageChannel useless for the purposes of ASAP.\n\t// https://github.com/kriskowal/q/issues/396\n\n\t// Timers are implemented universally.\n\t// We fall back to timers in workers in most engines, and in foreground\n\t// contexts in the following browsers.\n\t// However, note that even this simple case requires nuances to operate in a\n\t// broad spectrum of browsers.\n\t//\n\t// - Firefox 3-13\n\t// - Internet Explorer 6-9\n\t// - iPad Safari 4.3\n\t// - Lynx 2.8.7\n\t} else {\n\t    requestFlush = makeRequestCallFromTimer(flush);\n\t}\n\n\t// `requestFlush` requests that the high priority event queue be flushed as\n\t// soon as possible.\n\t// This is useful to prevent an error thrown in a task from stalling the event\n\t// queue if the exception handled by Node.js’s\n\t// `process.on(\"uncaughtException\")` or by a domain.\n\trawAsap.requestFlush = requestFlush;\n\n\t// To request a high priority event, we induce a mutation observer by toggling\n\t// the text of a text node between \"1\" and \"-1\".\n\tfunction makeRequestCallFromMutationObserver(callback) {\n\t    var toggle = 1;\n\t    var observer = new BrowserMutationObserver(callback);\n\t    var node = document.createTextNode(\"\");\n\t    observer.observe(node, {characterData: true});\n\t    return function requestCall() {\n\t        toggle = -toggle;\n\t        node.data = toggle;\n\t    };\n\t}\n\n\t// The message channel technique was discovered by Malte Ubl and was the\n\t// original foundation for this library.\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\n\n\t// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n\t// page's first load. Thankfully, this version of Safari supports\n\t// MutationObservers, so we don't need to fall back in that case.\n\n\t// function makeRequestCallFromMessageChannel(callback) {\n\t//     var channel = new MessageChannel();\n\t//     channel.port1.onmessage = callback;\n\t//     return function requestCall() {\n\t//         channel.port2.postMessage(0);\n\t//     };\n\t// }\n\n\t// For reasons explained above, we are also unable to use `setImmediate`\n\t// under any circumstances.\n\t// Even if we were, there is another bug in Internet Explorer 10.\n\t// It is not sufficient to assign `setImmediate` to `requestFlush` because\n\t// `setImmediate` must be called *by name* and therefore must be wrapped in a\n\t// closure.\n\t// Never forget.\n\n\t// function makeRequestCallFromSetImmediate(callback) {\n\t//     return function requestCall() {\n\t//         setImmediate(callback);\n\t//     };\n\t// }\n\n\t// Safari 6.0 has a problem where timers will get lost while the user is\n\t// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n\t// mutation observers, so that implementation is used instead.\n\t// However, if we ever elect to use timers in Safari, the prevalent work-around\n\t// is to add a scroll event listener that calls for a flush.\n\n\t// `setTimeout` does not call the passed callback if the delay is less than\n\t// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n\t// even then.\n\n\tfunction makeRequestCallFromTimer(callback) {\n\t    return function requestCall() {\n\t        // We dispatch a timeout with a specified delay of 0 for engines that\n\t        // can reliably accommodate that request. This will usually be snapped\n\t        // to a 4 milisecond delay, but once we're flushing, there's no delay\n\t        // between events.\n\t        var timeoutHandle = setTimeout(handleTimer, 0);\n\t        // However, since this timer gets frequently dropped in Firefox\n\t        // workers, we enlist an interval handle that will try to fire\n\t        // an event 20 times per second until it succeeds.\n\t        var intervalHandle = setInterval(handleTimer, 50);\n\n\t        function handleTimer() {\n\t            // Whichever timer succeeds will cancel both timers and\n\t            // execute the callback.\n\t            clearTimeout(timeoutHandle);\n\t            clearInterval(intervalHandle);\n\t            callback();\n\t        }\n\t    };\n\t}\n\n\t// This is for `asap.js` only.\n\t// Its name will be periodically randomized to break any code that depends on\n\t// its existence.\n\trawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n\t// ASAP was originally a nextTick shim included in Q. This was factored out\n\t// into this ASAP package. It was later adapted to RSVP which made further\n\t// amendments. These decisions, particularly to marginalize MessageChannel and\n\t// to capture the MutationObserver implementation in a closure, were integrated\n\t// back into ASAP proper.\n\t// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\t// A simple class system, more documentation to come\n\n\tfunction extend(cls, name, props) {\n\t    // This does that same thing as Object.create, but with support for IE8\n\t    var F = function() {};\n\t    F.prototype = cls.prototype;\n\t    var prototype = new F();\n\n\t    // jshint undef: false\n\t    var fnTest = /xyz/.test(function(){ xyz; }) ? /\\bparent\\b/ : /.*/;\n\t    props = props || {};\n\n\t    for(var k in props) {\n\t        var src = props[k];\n\t        var parent = prototype[k];\n\n\t        if(typeof parent === 'function' &&\n\t           typeof src === 'function' &&\n\t           fnTest.test(src)) {\n\t            /*jshint -W083 */\n\t            prototype[k] = (function (src, parent) {\n\t                return function() {\n\t                    // Save the current parent method\n\t                    var tmp = this.parent;\n\n\t                    // Set parent to the previous method, call, and restore\n\t                    this.parent = parent;\n\t                    var res = src.apply(this, arguments);\n\t                    this.parent = tmp;\n\n\t                    return res;\n\t                };\n\t            })(src, parent);\n\t        }\n\t        else {\n\t            prototype[k] = src;\n\t        }\n\t    }\n\n\t    prototype.typename = name;\n\n\t    var new_cls = function() {\n\t        if(prototype.init) {\n\t            prototype.init.apply(this, arguments);\n\t        }\n\t    };\n\n\t    new_cls.prototype = prototype;\n\t    new_cls.prototype.constructor = new_cls;\n\n\t    new_cls.extend = function(name, props) {\n\t        if(typeof name === 'object') {\n\t            props = name;\n\t            name = 'anonymous';\n\t        }\n\t        return extend(new_cls, name, props);\n\t    };\n\n\t    return new_cls;\n\t}\n\n\tmodule.exports = extend(Object, 'Object', {});\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar r = __webpack_require__(8);\n\n\tfunction normalize(value, defaultValue) {\n\t    if(value === null || value === undefined || value === false) {\n\t        return defaultValue;\n\t    }\n\t    return value;\n\t}\n\n\tvar filters = {\n\t    abs: function(n) {\n\t        return Math.abs(n);\n\t    },\n\n\t    batch: function(arr, linecount, fill_with) {\n\t        var i;\n\t        var res = [];\n\t        var tmp = [];\n\n\t        for(i = 0; i < arr.length; i++) {\n\t            if(i % linecount === 0 && tmp.length) {\n\t                res.push(tmp);\n\t                tmp = [];\n\t            }\n\n\t            tmp.push(arr[i]);\n\t        }\n\n\t        if(tmp.length) {\n\t            if(fill_with) {\n\t                for(i = tmp.length; i < linecount; i++) {\n\t                    tmp.push(fill_with);\n\t                }\n\t            }\n\n\t            res.push(tmp);\n\t        }\n\n\t        return res;\n\t    },\n\n\t    capitalize: function(str) {\n\t        str = normalize(str, '');\n\t        var ret = str.toLowerCase();\n\t        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));\n\t    },\n\n\t    center: function(str, width) {\n\t        str = normalize(str, '');\n\t        width = width || 80;\n\n\t        if(str.length >= width) {\n\t            return str;\n\t        }\n\n\t        var spaces = width - str.length;\n\t        var pre = lib.repeat(' ', spaces/2 - spaces % 2);\n\t        var post = lib.repeat(' ', spaces/2);\n\t        return r.copySafeness(str, pre + str + post);\n\t    },\n\n\t    'default': function(val, def, bool) {\n\t        if(bool) {\n\t            return val ? val : def;\n\t        }\n\t        else {\n\t            return (val !== undefined) ? val : def;\n\t        }\n\t    },\n\n\t    dictsort: function(val, case_sensitive, by) {\n\t        if (!lib.isObject(val)) {\n\t            throw new lib.TemplateError('dictsort filter: val must be an object');\n\t        }\n\n\t        var array = [];\n\t        for (var k in val) {\n\t            // deliberately include properties from the object's prototype\n\t            array.push([k,val[k]]);\n\t        }\n\n\t        var si;\n\t        if (by === undefined || by === 'key') {\n\t            si = 0;\n\t        } else if (by === 'value') {\n\t            si = 1;\n\t        } else {\n\t            throw new lib.TemplateError(\n\t                'dictsort filter: You can only sort by either key or value');\n\t        }\n\n\t        array.sort(function(t1, t2) {\n\t            var a = t1[si];\n\t            var b = t2[si];\n\n\t            if (!case_sensitive) {\n\t                if (lib.isString(a)) {\n\t                    a = a.toUpperCase();\n\t                }\n\t                if (lib.isString(b)) {\n\t                    b = b.toUpperCase();\n\t                }\n\t            }\n\n\t            return a > b ? 1 : (a === b ? 0 : -1);\n\t        });\n\n\t        return array;\n\t    },\n\n\t    dump: function(obj, spaces) {\n\t        return JSON.stringify(obj, null, spaces);\n\t    },\n\n\t    escape: function(str) {\n\t        if(str instanceof r.SafeString) {\n\t            return str;\n\t        }\n\t        str = (str === null || str === undefined) ? '' : str;\n\t        return r.markSafe(lib.escape(str.toString()));\n\t    },\n\n\t    safe: function(str) {\n\t        if (str instanceof r.SafeString) {\n\t            return str;\n\t        }\n\t        str = (str === null || str === undefined) ? '' : str;\n\t        return r.markSafe(str.toString());\n\t    },\n\n\t    first: function(arr) {\n\t        return arr[0];\n\t    },\n\n\t    groupby: function(arr, attr) {\n\t        return lib.groupBy(arr, attr);\n\t    },\n\n\t    indent: function(str, width, indentfirst) {\n\t        str = normalize(str, '');\n\n\t        if (str === '') return '';\n\n\t        width = width || 4;\n\t        var res = '';\n\t        var lines = str.split('\\n');\n\t        var sp = lib.repeat(' ', width);\n\n\t        for(var i=0; i<lines.length; i++) {\n\t            if(i === 0 && !indentfirst) {\n\t                res += lines[i] + '\\n';\n\t            }\n\t            else {\n\t                res += sp + lines[i] + '\\n';\n\t            }\n\t        }\n\n\t        return r.copySafeness(str, res);\n\t    },\n\n\t    join: function(arr, del, attr) {\n\t        del = del || '';\n\n\t        if(attr) {\n\t            arr = lib.map(arr, function(v) {\n\t                return v[attr];\n\t            });\n\t        }\n\n\t        return arr.join(del);\n\t    },\n\n\t    last: function(arr) {\n\t        return arr[arr.length-1];\n\t    },\n\n\t    length: function(val) {\n\t        var value = normalize(val, '');\n\n\t        if(value !== undefined) {\n\t            if(\n\t                (typeof Map === 'function' && value instanceof Map) ||\n\t                (typeof Set === 'function' && value instanceof Set)\n\t            ) {\n\t                // ECMAScript 2015 Maps and Sets\n\t                return value.size;\n\t            }\n\t            if(lib.isObject(value) && !(value instanceof r.SafeString)) {\n\t                // Objects (besides SafeStrings), non-primative Arrays\n\t                return Object.keys(value).length;\n\t            }\n\t            return value.length;\n\t        }\n\t        return 0;\n\t    },\n\n\t    list: function(val) {\n\t        if(lib.isString(val)) {\n\t            return val.split('');\n\t        }\n\t        else if(lib.isObject(val)) {\n\t            var keys = [];\n\n\t            if(Object.keys) {\n\t                keys = Object.keys(val);\n\t            }\n\t            else {\n\t                for(var k in val) {\n\t                    keys.push(k);\n\t                }\n\t            }\n\n\t            return lib.map(keys, function(k) {\n\t                return { key: k,\n\t                         value: val[k] };\n\t            });\n\t        }\n\t        else if(lib.isArray(val)) {\n\t          return val;\n\t        }\n\t        else {\n\t            throw new lib.TemplateError('list filter: type not iterable');\n\t        }\n\t    },\n\n\t    lower: function(str) {\n\t        str = normalize(str, '');\n\t        return str.toLowerCase();\n\t    },\n\n\t    nl2br: function(str) {\n\t        if (str === null || str === undefined) {\n\t            return '';\n\t        }\n\t        return r.copySafeness(str, str.replace(/\\r\\n|\\n/g, '<br />\\n'));\n\t    },\n\n\t    random: function(arr) {\n\t        return arr[Math.floor(Math.random() * arr.length)];\n\t    },\n\n\t    rejectattr: function(arr, attr) {\n\t      return arr.filter(function (item) {\n\t        return !item[attr];\n\t      });\n\t    },\n\n\t    selectattr: function(arr, attr) {\n\t      return arr.filter(function (item) {\n\t        return !!item[attr];\n\t      });\n\t    },\n\n\t    replace: function(str, old, new_, maxCount) {\n\t        var originalStr = str;\n\n\t        if (old instanceof RegExp) {\n\t            return str.replace(old, new_);\n\t        }\n\n\t        if(typeof maxCount === 'undefined'){\n\t            maxCount = -1;\n\t        }\n\n\t        var res = '';  // Output\n\n\t        // Cast Numbers in the search term to string\n\t        if(typeof old === 'number'){\n\t            old = old + '';\n\t        }\n\t        else if(typeof old !== 'string') {\n\t            // If it is something other than number or string,\n\t            // return the original string\n\t            return str;\n\t        }\n\n\t        // Cast numbers in the replacement to string\n\t        if(typeof str === 'number'){\n\t            str = str + '';\n\t        }\n\n\t        // If by now, we don't have a string, throw it back\n\t        if(typeof str !== 'string' && !(str instanceof r.SafeString)){\n\t            return str;\n\t        }\n\n\t        // ShortCircuits\n\t        if(old === ''){\n\t            // Mimic the python behaviour: empty string is replaced\n\t            // by replacement e.g. \"abc\"|replace(\"\", \".\") -> .a.b.c.\n\t            res = new_ + str.split('').join(new_) + new_;\n\t            return r.copySafeness(str, res);\n\t        }\n\n\t        var nextIndex = str.indexOf(old);\n\t        // if # of replacements to perform is 0, or the string to does\n\t        // not contain the old value, return the string\n\t        if(maxCount === 0 || nextIndex === -1){\n\t            return str;\n\t        }\n\n\t        var pos = 0;\n\t        var count = 0; // # of replacements made\n\n\t        while(nextIndex  > -1 && (maxCount === -1 || count < maxCount)){\n\t            // Grab the next chunk of src string and add it with the\n\t            // replacement, to the result\n\t            res += str.substring(pos, nextIndex) + new_;\n\t            // Increment our pointer in the src string\n\t            pos = nextIndex + old.length;\n\t            count++;\n\t            // See if there are any more replacements to be made\n\t            nextIndex = str.indexOf(old, pos);\n\t        }\n\n\t        // We've either reached the end, or done the max # of\n\t        // replacements, tack on any remaining string\n\t        if(pos < str.length) {\n\t            res += str.substring(pos);\n\t        }\n\n\t        return r.copySafeness(originalStr, res);\n\t    },\n\n\t    reverse: function(val) {\n\t        var arr;\n\t        if(lib.isString(val)) {\n\t            arr = filters.list(val);\n\t        }\n\t        else {\n\t            // Copy it\n\t            arr = lib.map(val, function(v) { return v; });\n\t        }\n\n\t        arr.reverse();\n\n\t        if(lib.isString(val)) {\n\t            return r.copySafeness(val, arr.join(''));\n\t        }\n\t        return arr;\n\t    },\n\n\t    round: function(val, precision, method) {\n\t        precision = precision || 0;\n\t        var factor = Math.pow(10, precision);\n\t        var rounder;\n\n\t        if(method === 'ceil') {\n\t            rounder = Math.ceil;\n\t        }\n\t        else if(method === 'floor') {\n\t            rounder = Math.floor;\n\t        }\n\t        else {\n\t            rounder = Math.round;\n\t        }\n\n\t        return rounder(val * factor) / factor;\n\t    },\n\n\t    slice: function(arr, slices, fillWith) {\n\t        var sliceLength = Math.floor(arr.length / slices);\n\t        var extra = arr.length % slices;\n\t        var offset = 0;\n\t        var res = [];\n\n\t        for(var i=0; i<slices; i++) {\n\t            var start = offset + i * sliceLength;\n\t            if(i < extra) {\n\t                offset++;\n\t            }\n\t            var end = offset + (i + 1) * sliceLength;\n\n\t            var slice = arr.slice(start, end);\n\t            if(fillWith && i >= extra) {\n\t                slice.push(fillWith);\n\t            }\n\t            res.push(slice);\n\t        }\n\n\t        return res;\n\t    },\n\n\t    sum: function(arr, attr, start) {\n\t        var sum = 0;\n\n\t        if(typeof start === 'number'){\n\t            sum += start;\n\t        }\n\n\t        if(attr) {\n\t            arr = lib.map(arr, function(v) {\n\t                return v[attr];\n\t            });\n\t        }\n\n\t        for(var i = 0; i < arr.length; i++) {\n\t            sum += arr[i];\n\t        }\n\n\t        return sum;\n\t    },\n\n\t    sort: r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function(arr, reverse, caseSens, attr) {\n\t         // Copy it\n\t        arr = lib.map(arr, function(v) { return v; });\n\n\t        arr.sort(function(a, b) {\n\t            var x, y;\n\n\t            if(attr) {\n\t                x = a[attr];\n\t                y = b[attr];\n\t            }\n\t            else {\n\t                x = a;\n\t                y = b;\n\t            }\n\n\t            if(!caseSens && lib.isString(x) && lib.isString(y)) {\n\t                x = x.toLowerCase();\n\t                y = y.toLowerCase();\n\t            }\n\n\t            if(x < y) {\n\t                return reverse ? 1 : -1;\n\t            }\n\t            else if(x > y) {\n\t                return reverse ? -1: 1;\n\t            }\n\t            else {\n\t                return 0;\n\t            }\n\t        });\n\n\t        return arr;\n\t    }),\n\n\t    string: function(obj) {\n\t        return r.copySafeness(obj, obj);\n\t    },\n\n\t    striptags: function(input, preserve_linebreaks) {\n\t        input = normalize(input, '');\n\t        preserve_linebreaks = preserve_linebreaks || false;\n\t        var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>|<!--[\\s\\S]*?-->/gi;\n\t        var trimmedInput = filters.trim(input.replace(tags, ''));\n\t        var res = '';\n\t        if (preserve_linebreaks) {\n\t            res = trimmedInput\n\t                .replace(/^ +| +$/gm, '')     // remove leading and trailing spaces\n\t                .replace(/ +/g, ' ')          // squash adjacent spaces\n\t                .replace(/(\\r\\n)/g, '\\n')     // normalize linebreaks (CRLF -> LF)\n\t                .replace(/\\n\\n\\n+/g, '\\n\\n'); // squash abnormal adjacent linebreaks\n\t        } else {\n\t            res = trimmedInput.replace(/\\s+/gi, ' ');\n\t        }\n\t        return r.copySafeness(input, res);\n\t    },\n\n\t    title: function(str) {\n\t        str = normalize(str, '');\n\t        var words = str.split(' ');\n\t        for(var i = 0; i < words.length; i++) {\n\t            words[i] = filters.capitalize(words[i]);\n\t        }\n\t        return r.copySafeness(str, words.join(' '));\n\t    },\n\n\t    trim: function(str) {\n\t        return r.copySafeness(str, str.replace(/^\\s*|\\s*$/g, ''));\n\t    },\n\n\t    truncate: function(input, length, killwords, end) {\n\t        var orig = input;\n\t        input = normalize(input, '');\n\t        length = length || 255;\n\n\t        if (input.length <= length)\n\t            return input;\n\n\t        if (killwords) {\n\t            input = input.substring(0, length);\n\t        } else {\n\t            var idx = input.lastIndexOf(' ', length);\n\t            if(idx === -1) {\n\t                idx = length;\n\t            }\n\n\t            input = input.substring(0, idx);\n\t        }\n\n\t        input += (end !== undefined && end !== null) ? end : '...';\n\t        return r.copySafeness(orig, input);\n\t    },\n\n\t    upper: function(str) {\n\t        str = normalize(str, '');\n\t        return str.toUpperCase();\n\t    },\n\n\t    urlencode: function(obj) {\n\t        var enc = encodeURIComponent;\n\t        if (lib.isString(obj)) {\n\t            return enc(obj);\n\t        } else {\n\t            var parts;\n\t            if (lib.isArray(obj)) {\n\t                parts = obj.map(function(item) {\n\t                    return enc(item[0]) + '=' + enc(item[1]);\n\t                });\n\t            } else {\n\t                parts = [];\n\t                for (var k in obj) {\n\t                    if (obj.hasOwnProperty(k)) {\n\t                        parts.push(enc(k) + '=' + enc(obj[k]));\n\t                    }\n\t                }\n\t            }\n\t            return parts.join('&');\n\t        }\n\t    },\n\n\t    urlize: function(str, length, nofollow) {\n\t        if (isNaN(length)) length = Infinity;\n\n\t        var noFollowAttr = (nofollow === true ? ' rel=\"nofollow\"' : '');\n\n\t        // For the jinja regexp, see\n\t        // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23\n\t        var puncRE = /^(?:\\(|<|&lt;)?(.*?)(?:\\.|,|\\)|\\n|&gt;)?$/;\n\t        // from http://blog.gerv.net/2011/05/html5_email_address_regexp/\n\t        var emailRE = /^[\\w.!#$%&'*+\\-\\/=?\\^`{|}~]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)+$/i;\n\t        var httpHttpsRE = /^https?:\\/\\/.*$/;\n\t        var wwwRE = /^www\\./;\n\t        var tldRE = /\\.(?:org|net|com)(?:\\:|\\/|$)/;\n\n\t        var words = str.split(/(\\s+)/).filter(function(word) {\n\t          // If the word has no length, bail. This can happen for str with\n\t          // trailing whitespace.\n\t          return word && word.length;\n\t        }).map(function(word) {\n\t          var matches = word.match(puncRE);\n\t          var possibleUrl = matches && matches[1] || word;\n\n\t          // url that starts with http or https\n\t          if (httpHttpsRE.test(possibleUrl))\n\t            return '<a href=\"' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n\t          // url that starts with www.\n\t          if (wwwRE.test(possibleUrl))\n\t            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n\t          // an email address of the form username@domain.tld\n\t          if (emailRE.test(possibleUrl))\n\t            return '<a href=\"mailto:' + possibleUrl + '\">' + possibleUrl + '</a>';\n\n\t          // url that ends in .com, .org or .net that is not an email address\n\t          if (tldRE.test(possibleUrl))\n\t            return '<a href=\"http://' + possibleUrl + '\"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';\n\n\t          return word;\n\n\t        });\n\n\t        return words.join('');\n\t    },\n\n\t    wordcount: function(str) {\n\t        str = normalize(str, '');\n\t        var words = (str) ? str.match(/\\w+/g) : null;\n\t        return (words) ? words.length : null;\n\t    },\n\n\t    'float': function(val, def) {\n\t        var res = parseFloat(val);\n\t        return isNaN(res) ? def : res;\n\t    },\n\n\t    'int': function(val, def) {\n\t        var res = parseInt(val, 10);\n\t        return isNaN(res) ? def : res;\n\t    }\n\t};\n\n\t// Aliases\n\tfilters.d = filters['default'];\n\tfilters.e = filters.escape;\n\n\tmodule.exports = filters;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar lib = __webpack_require__(1);\n\tvar Obj = __webpack_require__(6);\n\n\t// Frames keep track of scoping both at compile-time and run-time so\n\t// we know how to access variables. Block tags can introduce special\n\t// variables, for example.\n\tvar Frame = Obj.extend({\n\t    init: function(parent, isolateWrites) {\n\t        this.variables = {};\n\t        this.parent = parent;\n\t        this.topLevel = false;\n\t        // if this is true, writes (set) should never propagate upwards past\n\t        // this frame to its parent (though reads may).\n\t        this.isolateWrites = isolateWrites;\n\t    },\n\n\t    set: function(name, val, resolveUp) {\n\t        // Allow variables with dots by automatically creating the\n\t        // nested structure\n\t        var parts = name.split('.');\n\t        var obj = this.variables;\n\t        var frame = this;\n\n\t        if(resolveUp) {\n\t            if((frame = this.resolve(parts[0], true))) {\n\t                frame.set(name, val);\n\t                return;\n\t            }\n\t        }\n\n\t        for(var i=0; i<parts.length - 1; i++) {\n\t            var id = parts[i];\n\n\t            if(!obj[id]) {\n\t                obj[id] = {};\n\t            }\n\t            obj = obj[id];\n\t        }\n\n\t        obj[parts[parts.length - 1]] = val;\n\t    },\n\n\t    get: function(name) {\n\t        var val = this.variables[name];\n\t        if(val !== undefined) {\n\t            return val;\n\t        }\n\t        return null;\n\t    },\n\n\t    lookup: function(name) {\n\t        var p = this.parent;\n\t        var val = this.variables[name];\n\t        if(val !== undefined) {\n\t            return val;\n\t        }\n\t        return p && p.lookup(name);\n\t    },\n\n\t    resolve: function(name, forWrite) {\n\t        var p = (forWrite && this.isolateWrites) ? undefined : this.parent;\n\t        var val = this.variables[name];\n\t        if(val !== undefined) {\n\t            return this;\n\t        }\n\t        return p && p.resolve(name);\n\t    },\n\n\t    push: function(isolateWrites) {\n\t        return new Frame(this, isolateWrites);\n\t    },\n\n\t    pop: function() {\n\t        return this.parent;\n\t    }\n\t});\n\n\tfunction makeMacro(argNames, kwargNames, func) {\n\t    return function() {\n\t        var argCount = numArgs(arguments);\n\t        var args;\n\t        var kwargs = getKeywordArgs(arguments);\n\t        var i;\n\n\t        if(argCount > argNames.length) {\n\t            args = Array.prototype.slice.call(arguments, 0, argNames.length);\n\n\t            // Positional arguments that should be passed in as\n\t            // keyword arguments (essentially default values)\n\t            var vals = Array.prototype.slice.call(arguments, args.length, argCount);\n\t            for(i = 0; i < vals.length; i++) {\n\t                if(i < kwargNames.length) {\n\t                    kwargs[kwargNames[i]] = vals[i];\n\t                }\n\t            }\n\n\t            args.push(kwargs);\n\t        }\n\t        else if(argCount < argNames.length) {\n\t            args = Array.prototype.slice.call(arguments, 0, argCount);\n\n\t            for(i = argCount; i < argNames.length; i++) {\n\t                var arg = argNames[i];\n\n\t                // Keyword arguments that should be passed as\n\t                // positional arguments, i.e. the caller explicitly\n\t                // used the name of a positional arg\n\t                args.push(kwargs[arg]);\n\t                delete kwargs[arg];\n\t            }\n\n\t            args.push(kwargs);\n\t        }\n\t        else {\n\t            args = arguments;\n\t        }\n\n\t        return func.apply(this, args);\n\t    };\n\t}\n\n\tfunction makeKeywordArgs(obj) {\n\t    obj.__keywords = true;\n\t    return obj;\n\t}\n\n\tfunction getKeywordArgs(args) {\n\t    var len = args.length;\n\t    if(len) {\n\t        var lastArg = args[len - 1];\n\t        if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n\t            return lastArg;\n\t        }\n\t    }\n\t    return {};\n\t}\n\n\tfunction numArgs(args) {\n\t    var len = args.length;\n\t    if(len === 0) {\n\t        return 0;\n\t    }\n\n\t    var lastArg = args[len - 1];\n\t    if(lastArg && lastArg.hasOwnProperty('__keywords')) {\n\t        return len - 1;\n\t    }\n\t    else {\n\t        return len;\n\t    }\n\t}\n\n\t// A SafeString object indicates that the string should not be\n\t// autoescaped. This happens magically because autoescaping only\n\t// occurs on primitive string objects.\n\tfunction SafeString(val) {\n\t    if(typeof val !== 'string') {\n\t        return val;\n\t    }\n\n\t    this.val = val;\n\t    this.length = val.length;\n\t}\n\n\tSafeString.prototype = Object.create(String.prototype, {\n\t    length: { writable: true, configurable: true, value: 0 }\n\t});\n\tSafeString.prototype.valueOf = function() {\n\t    return this.val;\n\t};\n\tSafeString.prototype.toString = function() {\n\t    return this.val;\n\t};\n\n\tfunction copySafeness(dest, target) {\n\t    if(dest instanceof SafeString) {\n\t        return new SafeString(target);\n\t    }\n\t    return target.toString();\n\t}\n\n\tfunction markSafe(val) {\n\t    var type = typeof val;\n\n\t    if(type === 'string') {\n\t        return new SafeString(val);\n\t    }\n\t    else if(type !== 'function') {\n\t        return val;\n\t    }\n\t    else {\n\t        return function() {\n\t            var ret = val.apply(this, arguments);\n\n\t            if(typeof ret === 'string') {\n\t                return new SafeString(ret);\n\t            }\n\n\t            return ret;\n\t        };\n\t    }\n\t}\n\n\tfunction suppressValue(val, autoescape) {\n\t    val = (val !== undefined && val !== null) ? val : '';\n\n\t    if(autoescape && !(val instanceof SafeString)) {\n\t        val = lib.escape(val.toString());\n\t    }\n\n\t    return val;\n\t}\n\n\tfunction ensureDefined(val, lineno, colno) {\n\t    if(val === null || val === undefined) {\n\t        throw new lib.TemplateError(\n\t            'attempted to output null or undefined value',\n\t            lineno + 1,\n\t            colno + 1\n\t        );\n\t    }\n\t    return val;\n\t}\n\n\tfunction memberLookup(obj, val) {\n\t    obj = obj || {};\n\n\t    if(typeof obj[val] === 'function') {\n\t        return function() {\n\t            return obj[val].apply(obj, arguments);\n\t        };\n\t    }\n\n\t    return obj[val];\n\t}\n\n\tfunction callWrap(obj, name, context, args) {\n\t    if(!obj) {\n\t        throw new Error('Unable to call `' + name + '`, which is undefined or falsey');\n\t    }\n\t    else if(typeof obj !== 'function') {\n\t        throw new Error('Unable to call `' + name + '`, which is not a function');\n\t    }\n\n\t    // jshint validthis: true\n\t    return obj.apply(context, args);\n\t}\n\n\tfunction contextOrFrameLookup(context, frame, name) {\n\t    var val = frame.lookup(name);\n\t    return (val !== undefined) ?\n\t        val :\n\t        context.lookup(name);\n\t}\n\n\tfunction handleError(error, lineno, colno) {\n\t    if(error.lineno) {\n\t        return error;\n\t    }\n\t    else {\n\t        return new lib.TemplateError(error, lineno, colno);\n\t    }\n\t}\n\n\tfunction asyncEach(arr, dimen, iter, cb) {\n\t    if(lib.isArray(arr)) {\n\t        var len = arr.length;\n\n\t        lib.asyncIter(arr, function(item, i, next) {\n\t            switch(dimen) {\n\t            case 1: iter(item, i, len, next); break;\n\t            case 2: iter(item[0], item[1], i, len, next); break;\n\t            case 3: iter(item[0], item[1], item[2], i, len, next); break;\n\t            default:\n\t                item.push(i, next);\n\t                iter.apply(this, item);\n\t            }\n\t        }, cb);\n\t    }\n\t    else {\n\t        lib.asyncFor(arr, function(key, val, i, len, next) {\n\t            iter(key, val, i, len, next);\n\t        }, cb);\n\t    }\n\t}\n\n\tfunction asyncAll(arr, dimen, func, cb) {\n\t    var finished = 0;\n\t    var len, i;\n\t    var outputArr;\n\n\t    function done(i, output) {\n\t        finished++;\n\t        outputArr[i] = output;\n\n\t        if(finished === len) {\n\t            cb(null, outputArr.join(''));\n\t        }\n\t    }\n\n\t    if(lib.isArray(arr)) {\n\t        len = arr.length;\n\t        outputArr = new Array(len);\n\n\t        if(len === 0) {\n\t            cb(null, '');\n\t        }\n\t        else {\n\t            for(i = 0; i < arr.length; i++) {\n\t                var item = arr[i];\n\n\t                switch(dimen) {\n\t                case 1: func(item, i, len, done); break;\n\t                case 2: func(item[0], item[1], i, len, done); break;\n\t                case 3: func(item[0], item[1], item[2], i, len, done); break;\n\t                default:\n\t                    item.push(i, done);\n\t                    // jshint validthis: true\n\t                    func.apply(this, item);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    else {\n\t        var keys = lib.keys(arr);\n\t        len = keys.length;\n\t        outputArr = new Array(len);\n\n\t        if(len === 0) {\n\t            cb(null, '');\n\t        }\n\t        else {\n\t            for(i = 0; i < keys.length; i++) {\n\t                var k = keys[i];\n\t                func(k, arr[k], i, len, done);\n\t            }\n\t        }\n\t    }\n\t}\n\n\tmodule.exports = {\n\t    Frame: Frame,\n\t    makeMacro: makeMacro,\n\t    makeKeywordArgs: makeKeywordArgs,\n\t    numArgs: numArgs,\n\t    suppressValue: suppressValue,\n\t    ensureDefined: ensureDefined,\n\t    memberLookup: memberLookup,\n\t    contextOrFrameLookup: contextOrFrameLookup,\n\t    callWrap: callWrap,\n\t    handleError: handleError,\n\t    isArray: lib.isArray,\n\t    keys: lib.keys,\n\t    SafeString: SafeString,\n\t    copySafeness: copySafeness,\n\t    markSafe: markSafe,\n\t    asyncEach: asyncEach,\n\t    asyncAll: asyncAll,\n\t    inOperator: lib.inOperator\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tfunction cycler(items) {\n\t    var index = -1;\n\n\t    return {\n\t        current: null,\n\t        reset: function() {\n\t            index = -1;\n\t            this.current = null;\n\t        },\n\n\t        next: function() {\n\t            index++;\n\t            if(index >= items.length) {\n\t                index = 0;\n\t            }\n\n\t            this.current = items[index];\n\t            return this.current;\n\t        },\n\t    };\n\n\t}\n\n\tfunction joiner(sep) {\n\t    sep = sep || ',';\n\t    var first = true;\n\n\t    return function() {\n\t        var val = first ? '' : sep;\n\t        first = false;\n\t        return val;\n\t    };\n\t}\n\n\t// Making this a function instead so it returns a new object\n\t// each time it's called. That way, if something like an environment\n\t// uses it, they will each have their own copy.\n\tfunction globals() {\n\t    return {\n\t        range: function(start, stop, step) {\n\t            if(typeof stop === 'undefined') {\n\t                stop = start;\n\t                start = 0;\n\t                step = 1;\n\t            }\n\t            else if(!step) {\n\t                step = 1;\n\t            }\n\n\t            var arr = [];\n\t            var i;\n\t            if (step > 0) {\n\t                for (i=start; i<stop; i+=step) {\n\t                    arr.push(i);\n\t                }\n\t            } else {\n\t                for (i=start; i>stop; i+=step) {\n\t                    arr.push(i);\n\t                }\n\t            }\n\t            return arr;\n\t        },\n\n\t        // lipsum: function(n, html, min, max) {\n\t        // },\n\n\t        cycler: function() {\n\t            return cycler(Array.prototype.slice.call(arguments));\n\t        },\n\n\t        joiner: function(sep) {\n\t            return joiner(sep);\n\t        }\n\t    };\n\t}\n\n\tmodule.exports = globals;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, process) {// MIT license (by Elan Shanker).\n\t(function(globals) {\n\t  'use strict';\n\n\t  var executeSync = function(){\n\t    var args = Array.prototype.slice.call(arguments);\n\t    if (typeof args[0] === 'function'){\n\t      args[0].apply(null, args.splice(1));\n\t    }\n\t  };\n\n\t  var executeAsync = function(fn){\n\t    if (typeof setImmediate === 'function') {\n\t      setImmediate(fn);\n\t    } else if (typeof process !== 'undefined' && process.nextTick) {\n\t      process.nextTick(fn);\n\t    } else {\n\t      setTimeout(fn, 0);\n\t    }\n\t  };\n\n\t  var makeIterator = function (tasks) {\n\t    var makeCallback = function (index) {\n\t      var fn = function () {\n\t        if (tasks.length) {\n\t          tasks[index].apply(null, arguments);\n\t        }\n\t        return fn.next();\n\t      };\n\t      fn.next = function () {\n\t        return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n\t      };\n\t      return fn;\n\t    };\n\t    return makeCallback(0);\n\t  };\n\t  \n\t  var _isArray = Array.isArray || function(maybeArray){\n\t    return Object.prototype.toString.call(maybeArray) === '[object Array]';\n\t  };\n\n\t  var waterfall = function (tasks, callback, forceAsync) {\n\t    var nextTick = forceAsync ? executeAsync : executeSync;\n\t    callback = callback || function () {};\n\t    if (!_isArray(tasks)) {\n\t      var err = new Error('First argument to waterfall must be an array of functions');\n\t      return callback(err);\n\t    }\n\t    if (!tasks.length) {\n\t      return callback();\n\t    }\n\t    var wrapIterator = function (iterator) {\n\t      return function (err) {\n\t        if (err) {\n\t          callback.apply(null, arguments);\n\t          callback = function () {};\n\t        } else {\n\t          var args = Array.prototype.slice.call(arguments, 1);\n\t          var next = iterator.next();\n\t          if (next) {\n\t            args.push(wrapIterator(next));\n\t          } else {\n\t            args.push(callback);\n\t          }\n\t          nextTick(function () {\n\t            iterator.apply(null, args);\n\t          });\n\t        }\n\t      };\n\t    };\n\t    wrapIterator(makeIterator(tasks))();\n\t  };\n\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return waterfall;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS\n\t  } else if (typeof module !== 'undefined' && module.exports) {\n\t    module.exports = waterfall; // CommonJS\n\t  } else {\n\t    globals.waterfall = waterfall; // <script>\n\t  }\n\t})(this);\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11).setImmediate, __webpack_require__(3)))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(12).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\n\t// DOM APIs, for completeness\n\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n\t  immediateIds[id] = true;\n\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\n\t  return id;\n\t};\n\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11).setImmediate, __webpack_require__(11).clearImmediate))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\n\tfunction noop() {}\n\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Loader = __webpack_require__(14);\n\n\tvar PrecompiledLoader = Loader.extend({\n\t    init: function(compiledTemplates) {\n\t        this.precompiled = compiledTemplates || {};\n\t    },\n\n\t    getSource: function(name) {\n\t        if (this.precompiled[name]) {\n\t            return {\n\t                src: { type: 'code',\n\t                       obj: this.precompiled[name] },\n\t                path: name\n\t            };\n\t        }\n\t        return null;\n\t    }\n\t});\n\n\tmodule.exports = PrecompiledLoader;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar path = __webpack_require__(3);\n\tvar Obj = __webpack_require__(6);\n\tvar lib = __webpack_require__(1);\n\n\tvar Loader = Obj.extend({\n\t    on: function(name, func) {\n\t        this.listeners = this.listeners || {};\n\t        this.listeners[name] = this.listeners[name] || [];\n\t        this.listeners[name].push(func);\n\t    },\n\n\t    emit: function(name /*, arg1, arg2, ...*/) {\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\n\t        if(this.listeners && this.listeners[name]) {\n\t            lib.each(this.listeners[name], function(listener) {\n\t                listener.apply(null, args);\n\t            });\n\t        }\n\t    },\n\n\t    resolve: function(from, to) {\n\t        return path.resolve(path.dirname(from), to);\n\t    },\n\n\t    isRelative: function(filename) {\n\t        return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);\n\t    }\n\t});\n\n\tmodule.exports = Loader;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tfunction installCompat() {\n\t  'use strict';\n\n\t  // This must be called like `nunjucks.installCompat` so that `this`\n\t  // references the nunjucks instance\n\t  var runtime = this.runtime; // jshint ignore:line\n\t  var lib = this.lib; // jshint ignore:line\n\n\t  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;\n\t  runtime.contextOrFrameLookup = function(context, frame, key) {\n\t    var val = orig_contextOrFrameLookup.apply(this, arguments);\n\t    if (val === undefined) {\n\t      switch (key) {\n\t      case 'True':\n\t        return true;\n\t      case 'False':\n\t        return false;\n\t      case 'None':\n\t        return null;\n\t      }\n\t    }\n\n\t    return val;\n\t  };\n\n\t  var orig_memberLookup = runtime.memberLookup;\n\t  var ARRAY_MEMBERS = {\n\t    pop: function(index) {\n\t      if (index === undefined) {\n\t        return this.pop();\n\t      }\n\t      if (index >= this.length || index < 0) {\n\t        throw new Error('KeyError');\n\t      }\n\t      return this.splice(index, 1);\n\t    },\n\t    append: function(element) {\n\t        return this.push(element);\n\t    },\n\t    remove: function(element) {\n\t      for (var i = 0; i < this.length; i++) {\n\t        if (this[i] === element) {\n\t          return this.splice(i, 1);\n\t        }\n\t      }\n\t      throw new Error('ValueError');\n\t    },\n\t    count: function(element) {\n\t      var count = 0;\n\t      for (var i = 0; i < this.length; i++) {\n\t        if (this[i] === element) {\n\t          count++;\n\t        }\n\t      }\n\t      return count;\n\t    },\n\t    index: function(element) {\n\t      var i;\n\t      if ((i = this.indexOf(element)) === -1) {\n\t        throw new Error('ValueError');\n\t      }\n\t      return i;\n\t    },\n\t    find: function(element) {\n\t      return this.indexOf(element);\n\t    },\n\t    insert: function(index, elem) {\n\t      return this.splice(index, 0, elem);\n\t    }\n\t  };\n\t  var OBJECT_MEMBERS = {\n\t    items: function() {\n\t      var ret = [];\n\t      for(var k in this) {\n\t        ret.push([k, this[k]]);\n\t      }\n\t      return ret;\n\t    },\n\t    values: function() {\n\t      var ret = [];\n\t      for(var k in this) {\n\t        ret.push(this[k]);\n\t      }\n\t      return ret;\n\t    },\n\t    keys: function() {\n\t      var ret = [];\n\t      for(var k in this) {\n\t        ret.push(k);\n\t      }\n\t      return ret;\n\t    },\n\t    get: function(key, def) {\n\t      var output = this[key];\n\t      if (output === undefined) {\n\t        output = def;\n\t      }\n\t      return output;\n\t    },\n\t    has_key: function(key) {\n\t      return this.hasOwnProperty(key);\n\t    },\n\t    pop: function(key, def) {\n\t      var output = this[key];\n\t      if (output === undefined && def !== undefined) {\n\t        output = def;\n\t      } else if (output === undefined) {\n\t        throw new Error('KeyError');\n\t      } else {\n\t        delete this[key];\n\t      }\n\t      return output;\n\t    },\n\t    popitem: function() {\n\t      for (var k in this) {\n\t        // Return the first object pair.\n\t        var val = this[k];\n\t        delete this[k];\n\t        return [k, val];\n\t      }\n\t      throw new Error('KeyError');\n\t    },\n\t    setdefault: function(key, def) {\n\t      if (key in this) {\n\t        return this[key];\n\t      }\n\t      if (def === undefined) {\n\t        def = null;\n\t      }\n\t      return this[key] = def;\n\t    },\n\t    update: function(kwargs) {\n\t      for (var k in kwargs) {\n\t        this[k] = kwargs[k];\n\t      }\n\t      return null;  // Always returns None\n\t    }\n\t  };\n\t  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;\n\t  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;\n\t  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;\n\t  runtime.memberLookup = function(obj, val, autoescape) { // jshint ignore:line\n\t    obj = obj || {};\n\n\t    // If the object is an object, return any of the methods that Python would\n\t    // otherwise provide.\n\t    if (lib.isArray(obj) && ARRAY_MEMBERS.hasOwnProperty(val)) {\n\t      return function() {return ARRAY_MEMBERS[val].apply(obj, arguments);};\n\t    }\n\n\t    if (lib.isObject(obj) && OBJECT_MEMBERS.hasOwnProperty(val)) {\n\t      return function() {return OBJECT_MEMBERS[val].apply(obj, arguments);};\n\t    }\n\n\t    return orig_memberLookup.apply(this, arguments);\n\t  };\n\t}\n\n\tmodule.exports = installCompat;\n\n\n/***/ }\n/******/ ])\n});\n;","/home/travis/build/npmtest/node-npmtest-nunjucks/node_modules/nunjucks/src/web-loaders.js":"'use strict';\n\nvar Loader = require('./loader');\nvar PrecompiledLoader = require('./precompiled-loader.js');\n\nvar WebLoader = Loader.extend({\n    init: function(baseURL, opts) {\n        this.baseURL = baseURL || '.';\n        opts = opts || {};\n\n        // By default, the cache is turned off because there's no way\n        // to \"watch\" templates over HTTP, so they are re-downloaded\n        // and compiled each time. (Remember, PRECOMPILE YOUR\n        // TEMPLATES in production!)\n        this.useCache = !!opts.useCache;\n\n        // We default `async` to false so that the simple synchronous\n        // API can be used when you aren't doing anything async in\n        // your templates (which is most of the time). This performs a\n        // sync ajax request, but that's ok because it should *only*\n        // happen in development. PRECOMPILE YOUR TEMPLATES.\n        this.async = !!opts.async;\n    },\n\n    resolve: function(from, to) { // jshint ignore:line\n        throw new Error('relative templates not support in the browser yet');\n    },\n\n    getSource: function(name, cb) {\n        var useCache = this.useCache;\n        var result;\n        this.fetch(this.baseURL + '/' + name, function(err, src) {\n            if(err) {\n                if(cb) {\n                    cb(err.content);\n                } else {\n                    if (err.status === 404) {\n                      result = null;\n                    } else {\n                      throw err.content;\n                    }\n                }\n            }\n            else {\n                result = { src: src,\n                           path: name,\n                           noCache: !useCache };\n                if(cb) {\n                    cb(null, result);\n                }\n            }\n        });\n\n        // if this WebLoader isn't running asynchronously, the\n        // fetch above would actually run sync and we'll have a\n        // result here\n        return result;\n    },\n\n    fetch: function(url, cb) {\n        // Only in the browser please\n        var ajax;\n        var loading = true;\n\n        if(window.XMLHttpRequest) { // Mozilla, Safari, ...\n            ajax = new XMLHttpRequest();\n        }\n        else if(window.ActiveXObject) { // IE 8 and older\n            /* global ActiveXObject */\n            ajax = new ActiveXObject('Microsoft.XMLHTTP');\n        }\n\n        ajax.onreadystatechange = function() {\n            if(ajax.readyState === 4 && loading) {\n                loading = false;\n                if(ajax.status === 0 || ajax.status === 200) {\n                    cb(null, ajax.responseText);\n                }\n                else {\n                    cb({ status: ajax.status, content: ajax.responseText });\n                }\n            }\n        };\n\n        url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' +\n               (new Date().getTime());\n\n        ajax.open('GET', url, this.async);\n        ajax.send();\n    }\n});\n\nmodule.exports = {\n    WebLoader: WebLoader,\n    PrecompiledLoader: PrecompiledLoader\n};\n"}